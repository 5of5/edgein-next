import { useMutation, useQuery, UseMutationOptions, UseQueryOptions } from 'react-query';
import { fetcher } from './fetcher';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  date: any;
  float8: any;
  geography: any;
  geometry: any;
  jsonb: any;
  numeric: any;
  time: any;
  timestamp: any;
  timestamptz: any;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Boolean']>;
  _gt: InputMaybe<Scalars['Boolean']>;
  _gte: InputMaybe<Scalars['Boolean']>;
  _in: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Boolean']>;
  _lte: InputMaybe<Scalars['Boolean']>;
  _neq: InputMaybe<Scalars['Boolean']>;
  _nin: InputMaybe<Array<Scalars['Boolean']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Int']>;
  _gt: InputMaybe<Scalars['Int']>;
  _gte: InputMaybe<Scalars['Int']>;
  _in: InputMaybe<Array<Scalars['Int']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Int']>;
  _lte: InputMaybe<Scalars['Int']>;
  _neq: InputMaybe<Scalars['Int']>;
  _nin: InputMaybe<Array<Scalars['Int']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq: InputMaybe<Scalars['String']>;
  _gt: InputMaybe<Scalars['String']>;
  _gte: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike: InputMaybe<Scalars['String']>;
  _in: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex: InputMaybe<Scalars['String']>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like: InputMaybe<Scalars['String']>;
  _lt: InputMaybe<Scalars['String']>;
  _lte: InputMaybe<Scalars['String']>;
  _neq: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike: InputMaybe<Scalars['String']>;
  _nin: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "actions" */
export type Actions = {
  __typename?: 'actions';
  action: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  page: Scalars['String'];
  partner: Maybe<Scalars['Int']>;
  properties: Scalars['jsonb'];
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  user: Maybe<Scalars['Int']>;
};


/** columns and relationships of "actions" */
export type ActionsPropertiesArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "actions" */
export type Actions_Aggregate = {
  __typename?: 'actions_aggregate';
  aggregate: Maybe<Actions_Aggregate_Fields>;
  nodes: Array<Actions>;
};

/** aggregate fields of "actions" */
export type Actions_Aggregate_Fields = {
  __typename?: 'actions_aggregate_fields';
  avg: Maybe<Actions_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Actions_Max_Fields>;
  min: Maybe<Actions_Min_Fields>;
  stddev: Maybe<Actions_Stddev_Fields>;
  stddev_pop: Maybe<Actions_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Actions_Stddev_Samp_Fields>;
  sum: Maybe<Actions_Sum_Fields>;
  var_pop: Maybe<Actions_Var_Pop_Fields>;
  var_samp: Maybe<Actions_Var_Samp_Fields>;
  variance: Maybe<Actions_Variance_Fields>;
};


/** aggregate fields of "actions" */
export type Actions_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Actions_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Actions_Append_Input = {
  properties: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Actions_Avg_Fields = {
  __typename?: 'actions_avg_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "actions". All fields are combined with a logical 'AND'. */
export type Actions_Bool_Exp = {
  _and: InputMaybe<Array<Actions_Bool_Exp>>;
  _not: InputMaybe<Actions_Bool_Exp>;
  _or: InputMaybe<Array<Actions_Bool_Exp>>;
  action: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  page: InputMaybe<String_Comparison_Exp>;
  partner: InputMaybe<Int_Comparison_Exp>;
  properties: InputMaybe<Jsonb_Comparison_Exp>;
  resource: InputMaybe<String_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  user: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "actions" */
export enum Actions_Constraint {
  /** unique or primary key constraint on columns "id" */
  ActionsPkey = 'actions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Actions_Delete_At_Path_Input = {
  properties: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Actions_Delete_Elem_Input = {
  properties: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Actions_Delete_Key_Input = {
  properties: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "actions" */
export type Actions_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  partner: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "actions" */
export type Actions_Insert_Input = {
  action: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  page: InputMaybe<Scalars['String']>;
  partner: InputMaybe<Scalars['Int']>;
  properties: InputMaybe<Scalars['jsonb']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Actions_Max_Fields = {
  __typename?: 'actions_max_fields';
  action: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  page: Maybe<Scalars['String']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  user: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Actions_Min_Fields = {
  __typename?: 'actions_min_fields';
  action: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  page: Maybe<Scalars['String']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  user: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "actions" */
export type Actions_Mutation_Response = {
  __typename?: 'actions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Actions>;
};

/** input type for inserting object relation for remote table "actions" */
export type Actions_Obj_Rel_Insert_Input = {
  data: Actions_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Actions_On_Conflict>;
};

/** on_conflict condition type for table "actions" */
export type Actions_On_Conflict = {
  constraint: Actions_Constraint;
  update_columns: Array<Actions_Update_Column>;
  where: InputMaybe<Actions_Bool_Exp>;
};

/** Ordering options when selecting data from "actions". */
export type Actions_Order_By = {
  action: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  page: InputMaybe<Order_By>;
  partner: InputMaybe<Order_By>;
  properties: InputMaybe<Order_By>;
  resource: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user: InputMaybe<Order_By>;
};

/** primary key columns input for table: actions */
export type Actions_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Actions_Prepend_Input = {
  properties: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "actions" */
export enum Actions_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Page = 'page',
  /** column name */
  Partner = 'partner',
  /** column name */
  Properties = 'properties',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  User = 'user'
}

/** input type for updating data in table "actions" */
export type Actions_Set_Input = {
  action: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  page: InputMaybe<Scalars['String']>;
  partner: InputMaybe<Scalars['Int']>;
  properties: InputMaybe<Scalars['jsonb']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Actions_Stddev_Fields = {
  __typename?: 'actions_stddev_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Actions_Stddev_Pop_Fields = {
  __typename?: 'actions_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Actions_Stddev_Samp_Fields = {
  __typename?: 'actions_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "actions" */
export type Actions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Actions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Actions_Stream_Cursor_Value_Input = {
  action: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  page: InputMaybe<Scalars['String']>;
  partner: InputMaybe<Scalars['Int']>;
  properties: InputMaybe<Scalars['jsonb']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Actions_Sum_Fields = {
  __typename?: 'actions_sum_fields';
  id: Maybe<Scalars['Int']>;
  partner: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user: Maybe<Scalars['Int']>;
};

/** update columns of table "actions" */
export enum Actions_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Page = 'page',
  /** column name */
  Partner = 'partner',
  /** column name */
  Properties = 'properties',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  User = 'user'
}

export type Actions_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Actions_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Actions_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Actions_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Actions_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Actions_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Actions_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Actions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Actions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Actions_Var_Pop_Fields = {
  __typename?: 'actions_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Actions_Var_Samp_Fields = {
  __typename?: 'actions_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Actions_Variance_Fields = {
  __typename?: 'actions_variance_fields';
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user: Maybe<Scalars['Float']>;
};

/** Allowed email Ids */
export type Allowed_Emails = {
  __typename?: 'allowed_emails';
  created_at: Scalars['date'];
  email: Scalars['String'];
  id: Scalars['Int'];
  match_type: Scalars['String'];
  person_id: Maybe<Scalars['Int']>;
  updated_at: Scalars['date'];
};

/** aggregated selection of "allowed_emails" */
export type Allowed_Emails_Aggregate = {
  __typename?: 'allowed_emails_aggregate';
  aggregate: Maybe<Allowed_Emails_Aggregate_Fields>;
  nodes: Array<Allowed_Emails>;
};

/** aggregate fields of "allowed_emails" */
export type Allowed_Emails_Aggregate_Fields = {
  __typename?: 'allowed_emails_aggregate_fields';
  avg: Maybe<Allowed_Emails_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Allowed_Emails_Max_Fields>;
  min: Maybe<Allowed_Emails_Min_Fields>;
  stddev: Maybe<Allowed_Emails_Stddev_Fields>;
  stddev_pop: Maybe<Allowed_Emails_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Allowed_Emails_Stddev_Samp_Fields>;
  sum: Maybe<Allowed_Emails_Sum_Fields>;
  var_pop: Maybe<Allowed_Emails_Var_Pop_Fields>;
  var_samp: Maybe<Allowed_Emails_Var_Samp_Fields>;
  variance: Maybe<Allowed_Emails_Variance_Fields>;
};


/** aggregate fields of "allowed_emails" */
export type Allowed_Emails_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Allowed_Emails_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Allowed_Emails_Avg_Fields = {
  __typename?: 'allowed_emails_avg_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "allowed_emails". All fields are combined with a logical 'AND'. */
export type Allowed_Emails_Bool_Exp = {
  _and: InputMaybe<Array<Allowed_Emails_Bool_Exp>>;
  _not: InputMaybe<Allowed_Emails_Bool_Exp>;
  _or: InputMaybe<Array<Allowed_Emails_Bool_Exp>>;
  created_at: InputMaybe<Date_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  match_type: InputMaybe<String_Comparison_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  updated_at: InputMaybe<Date_Comparison_Exp>;
};

/** unique or primary key constraints on table "allowed_emails" */
export enum Allowed_Emails_Constraint {
  /** unique or primary key constraint on columns "email" */
  AllowedEmailsEmailKey = 'allowed_emails_email_key',
  /** unique or primary key constraint on columns "person_id" */
  AllowedEmailsPersonIdKey = 'allowed_emails_person_id_key',
  /** unique or primary key constraint on columns "id" */
  AllowedEmailsPkey = 'allowed_emails_pkey'
}

/** input type for incrementing numeric columns in table "allowed_emails" */
export type Allowed_Emails_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "allowed_emails" */
export type Allowed_Emails_Insert_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
  person_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate max on columns */
export type Allowed_Emails_Max_Fields = {
  __typename?: 'allowed_emails_max_fields';
  created_at: Maybe<Scalars['date']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  match_type: Maybe<Scalars['String']>;
  person_id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['date']>;
};

/** aggregate min on columns */
export type Allowed_Emails_Min_Fields = {
  __typename?: 'allowed_emails_min_fields';
  created_at: Maybe<Scalars['date']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  match_type: Maybe<Scalars['String']>;
  person_id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['date']>;
};

/** response of any mutation on the table "allowed_emails" */
export type Allowed_Emails_Mutation_Response = {
  __typename?: 'allowed_emails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Allowed_Emails>;
};

/** on_conflict condition type for table "allowed_emails" */
export type Allowed_Emails_On_Conflict = {
  constraint: Allowed_Emails_Constraint;
  update_columns: Array<Allowed_Emails_Update_Column>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};

/** Ordering options when selecting data from "allowed_emails". */
export type Allowed_Emails_Order_By = {
  created_at: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  match_type: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: allowed_emails */
export type Allowed_Emails_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "allowed_emails" */
export enum Allowed_Emails_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  MatchType = 'match_type',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "allowed_emails" */
export type Allowed_Emails_Set_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
  person_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate stddev on columns */
export type Allowed_Emails_Stddev_Fields = {
  __typename?: 'allowed_emails_stddev_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Allowed_Emails_Stddev_Pop_Fields = {
  __typename?: 'allowed_emails_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Allowed_Emails_Stddev_Samp_Fields = {
  __typename?: 'allowed_emails_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "allowed_emails" */
export type Allowed_Emails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Allowed_Emails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Allowed_Emails_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
  person_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate sum on columns */
export type Allowed_Emails_Sum_Fields = {
  __typename?: 'allowed_emails_sum_fields';
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** update columns of table "allowed_emails" */
export enum Allowed_Emails_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  MatchType = 'match_type',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Allowed_Emails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Allowed_Emails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Allowed_Emails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Allowed_Emails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Allowed_Emails_Var_Pop_Fields = {
  __typename?: 'allowed_emails_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Allowed_Emails_Var_Samp_Fields = {
  __typename?: 'allowed_emails_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Allowed_Emails_Variance_Fields = {
  __typename?: 'allowed_emails_variance_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "application_meta" */
export type Application_Meta = {
  __typename?: 'application_meta';
  created_at: Scalars['timestamptz'];
  error: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  key: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  value: Scalars['timestamptz'];
};

/** aggregated selection of "application_meta" */
export type Application_Meta_Aggregate = {
  __typename?: 'application_meta_aggregate';
  aggregate: Maybe<Application_Meta_Aggregate_Fields>;
  nodes: Array<Application_Meta>;
};

/** aggregate fields of "application_meta" */
export type Application_Meta_Aggregate_Fields = {
  __typename?: 'application_meta_aggregate_fields';
  avg: Maybe<Application_Meta_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Application_Meta_Max_Fields>;
  min: Maybe<Application_Meta_Min_Fields>;
  stddev: Maybe<Application_Meta_Stddev_Fields>;
  stddev_pop: Maybe<Application_Meta_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Application_Meta_Stddev_Samp_Fields>;
  sum: Maybe<Application_Meta_Sum_Fields>;
  var_pop: Maybe<Application_Meta_Var_Pop_Fields>;
  var_samp: Maybe<Application_Meta_Var_Samp_Fields>;
  variance: Maybe<Application_Meta_Variance_Fields>;
};


/** aggregate fields of "application_meta" */
export type Application_Meta_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Application_Meta_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Application_Meta_Avg_Fields = {
  __typename?: 'application_meta_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "application_meta". All fields are combined with a logical 'AND'. */
export type Application_Meta_Bool_Exp = {
  _and: InputMaybe<Array<Application_Meta_Bool_Exp>>;
  _not: InputMaybe<Application_Meta_Bool_Exp>;
  _or: InputMaybe<Array<Application_Meta_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  error: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  key: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  value: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "application_meta" */
export enum Application_Meta_Constraint {
  /** unique or primary key constraint on columns "id" */
  ApplicationMetaPkey = 'application_meta_pkey'
}

/** input type for incrementing numeric columns in table "application_meta" */
export type Application_Meta_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "application_meta" */
export type Application_Meta_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  error: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  key: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  value: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Application_Meta_Max_Fields = {
  __typename?: 'application_meta_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  error: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  key: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  value: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Application_Meta_Min_Fields = {
  __typename?: 'application_meta_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  error: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  key: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  value: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "application_meta" */
export type Application_Meta_Mutation_Response = {
  __typename?: 'application_meta_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Application_Meta>;
};

/** on_conflict condition type for table "application_meta" */
export type Application_Meta_On_Conflict = {
  constraint: Application_Meta_Constraint;
  update_columns: Array<Application_Meta_Update_Column>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};

/** Ordering options when selecting data from "application_meta". */
export type Application_Meta_Order_By = {
  created_at: InputMaybe<Order_By>;
  error: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  key: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** primary key columns input for table: application_meta */
export type Application_Meta_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "application_meta" */
export enum Application_Meta_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Error = 'error',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "application_meta" */
export type Application_Meta_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  error: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  key: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  value: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Application_Meta_Stddev_Fields = {
  __typename?: 'application_meta_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Application_Meta_Stddev_Pop_Fields = {
  __typename?: 'application_meta_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Application_Meta_Stddev_Samp_Fields = {
  __typename?: 'application_meta_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "application_meta" */
export type Application_Meta_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Application_Meta_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Application_Meta_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  error: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  key: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  value: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Application_Meta_Sum_Fields = {
  __typename?: 'application_meta_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "application_meta" */
export enum Application_Meta_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Error = 'error',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

export type Application_Meta_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Application_Meta_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Application_Meta_Set_Input>;
  /** filter the rows which have to be updated */
  where: Application_Meta_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Application_Meta_Var_Pop_Fields = {
  __typename?: 'application_meta_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Application_Meta_Var_Samp_Fields = {
  __typename?: 'application_meta_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Application_Meta_Variance_Fields = {
  __typename?: 'application_meta_variance_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq: InputMaybe<Scalars['bigint']>;
  _gt: InputMaybe<Scalars['bigint']>;
  _gte: InputMaybe<Scalars['bigint']>;
  _in: InputMaybe<Array<Scalars['bigint']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['bigint']>;
  _lte: InputMaybe<Scalars['bigint']>;
  _neq: InputMaybe<Scalars['bigint']>;
  _nin: InputMaybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "billing_org" */
export type Billing_Org = {
  __typename?: 'billing_org';
  created_at: Scalars['timestamptz'];
  customer_id: Scalars['String'];
  id: Scalars['Int'];
  plan: Scalars['String'];
  status: Scalars['String'];
  user_limit: Scalars['Int'];
  /** An object relationship */
  users: Maybe<Users>;
};

/** aggregated selection of "billing_org" */
export type Billing_Org_Aggregate = {
  __typename?: 'billing_org_aggregate';
  aggregate: Maybe<Billing_Org_Aggregate_Fields>;
  nodes: Array<Billing_Org>;
};

/** aggregate fields of "billing_org" */
export type Billing_Org_Aggregate_Fields = {
  __typename?: 'billing_org_aggregate_fields';
  avg: Maybe<Billing_Org_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Billing_Org_Max_Fields>;
  min: Maybe<Billing_Org_Min_Fields>;
  stddev: Maybe<Billing_Org_Stddev_Fields>;
  stddev_pop: Maybe<Billing_Org_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Billing_Org_Stddev_Samp_Fields>;
  sum: Maybe<Billing_Org_Sum_Fields>;
  var_pop: Maybe<Billing_Org_Var_Pop_Fields>;
  var_samp: Maybe<Billing_Org_Var_Samp_Fields>;
  variance: Maybe<Billing_Org_Variance_Fields>;
};


/** aggregate fields of "billing_org" */
export type Billing_Org_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Billing_Org_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Billing_Org_Avg_Fields = {
  __typename?: 'billing_org_avg_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "billing_org". All fields are combined with a logical 'AND'. */
export type Billing_Org_Bool_Exp = {
  _and: InputMaybe<Array<Billing_Org_Bool_Exp>>;
  _not: InputMaybe<Billing_Org_Bool_Exp>;
  _or: InputMaybe<Array<Billing_Org_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  plan: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  user_limit: InputMaybe<Int_Comparison_Exp>;
  users: InputMaybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "billing_org" */
export enum Billing_Org_Constraint {
  /** unique or primary key constraint on columns "id" */
  BillingOrgPkey = 'billing_org_pkey'
}

/** input type for incrementing numeric columns in table "billing_org" */
export type Billing_Org_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  user_limit: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "billing_org" */
export type Billing_Org_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  customer_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  plan: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  user_limit: InputMaybe<Scalars['Int']>;
  users: InputMaybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Billing_Org_Max_Fields = {
  __typename?: 'billing_org_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  customer_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  plan: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  user_limit: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Billing_Org_Min_Fields = {
  __typename?: 'billing_org_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  customer_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  plan: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  user_limit: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "billing_org" */
export type Billing_Org_Mutation_Response = {
  __typename?: 'billing_org_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Org>;
};

/** input type for inserting object relation for remote table "billing_org" */
export type Billing_Org_Obj_Rel_Insert_Input = {
  data: Billing_Org_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Billing_Org_On_Conflict>;
};

/** on_conflict condition type for table "billing_org" */
export type Billing_Org_On_Conflict = {
  constraint: Billing_Org_Constraint;
  update_columns: Array<Billing_Org_Update_Column>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};

/** Ordering options when selecting data from "billing_org". */
export type Billing_Org_Order_By = {
  created_at: InputMaybe<Order_By>;
  customer_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  plan: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  user_limit: InputMaybe<Order_By>;
  users: InputMaybe<Users_Order_By>;
};

/** primary key columns input for table: billing_org */
export type Billing_Org_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "billing_org" */
export enum Billing_Org_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  Plan = 'plan',
  /** column name */
  Status = 'status',
  /** column name */
  UserLimit = 'user_limit'
}

/** input type for updating data in table "billing_org" */
export type Billing_Org_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  customer_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  plan: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  user_limit: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Billing_Org_Stddev_Fields = {
  __typename?: 'billing_org_stddev_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Billing_Org_Stddev_Pop_Fields = {
  __typename?: 'billing_org_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Billing_Org_Stddev_Samp_Fields = {
  __typename?: 'billing_org_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "billing_org" */
export type Billing_Org_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Org_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Org_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  customer_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  plan: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  user_limit: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Billing_Org_Sum_Fields = {
  __typename?: 'billing_org_sum_fields';
  id: Maybe<Scalars['Int']>;
  user_limit: Maybe<Scalars['Int']>;
};

/** update columns of table "billing_org" */
export enum Billing_Org_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  Plan = 'plan',
  /** column name */
  Status = 'status',
  /** column name */
  UserLimit = 'user_limit'
}

export type Billing_Org_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Billing_Org_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Billing_Org_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Org_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Billing_Org_Var_Pop_Fields = {
  __typename?: 'billing_org_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Billing_Org_Var_Samp_Fields = {
  __typename?: 'billing_org_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Billing_Org_Variance_Fields = {
  __typename?: 'billing_org_variance_fields';
  id: Maybe<Scalars['Float']>;
  user_limit: Maybe<Scalars['Float']>;
};

/** columns and relationships of "blockchains" */
export type Blockchains = {
  __typename?: 'blockchains';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** aggregated selection of "blockchains" */
export type Blockchains_Aggregate = {
  __typename?: 'blockchains_aggregate';
  aggregate: Maybe<Blockchains_Aggregate_Fields>;
  nodes: Array<Blockchains>;
};

/** aggregate fields of "blockchains" */
export type Blockchains_Aggregate_Fields = {
  __typename?: 'blockchains_aggregate_fields';
  avg: Maybe<Blockchains_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Blockchains_Max_Fields>;
  min: Maybe<Blockchains_Min_Fields>;
  stddev: Maybe<Blockchains_Stddev_Fields>;
  stddev_pop: Maybe<Blockchains_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Blockchains_Stddev_Samp_Fields>;
  sum: Maybe<Blockchains_Sum_Fields>;
  var_pop: Maybe<Blockchains_Var_Pop_Fields>;
  var_samp: Maybe<Blockchains_Var_Samp_Fields>;
  variance: Maybe<Blockchains_Variance_Fields>;
};


/** aggregate fields of "blockchains" */
export type Blockchains_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Blockchains_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Blockchains_Avg_Fields = {
  __typename?: 'blockchains_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "blockchains". All fields are combined with a logical 'AND'. */
export type Blockchains_Bool_Exp = {
  _and: InputMaybe<Array<Blockchains_Bool_Exp>>;
  _not: InputMaybe<Blockchains_Bool_Exp>;
  _or: InputMaybe<Array<Blockchains_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "blockchains" */
export enum Blockchains_Constraint {
  /** unique or primary key constraint on columns "id" */
  BlockchainPkey = 'blockchain_pkey'
}

/** input type for incrementing numeric columns in table "blockchains" */
export type Blockchains_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "blockchains" */
export type Blockchains_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Blockchains_Max_Fields = {
  __typename?: 'blockchains_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Blockchains_Min_Fields = {
  __typename?: 'blockchains_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "blockchains" */
export type Blockchains_Mutation_Response = {
  __typename?: 'blockchains_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Blockchains>;
};

/** input type for inserting object relation for remote table "blockchains" */
export type Blockchains_Obj_Rel_Insert_Input = {
  data: Blockchains_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Blockchains_On_Conflict>;
};

/** on_conflict condition type for table "blockchains" */
export type Blockchains_On_Conflict = {
  constraint: Blockchains_Constraint;
  update_columns: Array<Blockchains_Update_Column>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};

/** Ordering options when selecting data from "blockchains". */
export type Blockchains_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
};

/** primary key columns input for table: blockchains */
export type Blockchains_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "blockchains" */
export enum Blockchains_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "blockchains" */
export type Blockchains_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Blockchains_Stddev_Fields = {
  __typename?: 'blockchains_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Blockchains_Stddev_Pop_Fields = {
  __typename?: 'blockchains_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Blockchains_Stddev_Samp_Fields = {
  __typename?: 'blockchains_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "blockchains" */
export type Blockchains_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Blockchains_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Blockchains_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Blockchains_Sum_Fields = {
  __typename?: 'blockchains_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "blockchains" */
export enum Blockchains_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Blockchains_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Blockchains_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Blockchains_Set_Input>;
  /** filter the rows which have to be updated */
  where: Blockchains_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Blockchains_Var_Pop_Fields = {
  __typename?: 'blockchains_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Blockchains_Var_Samp_Fields = {
  __typename?: 'blockchains_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Blockchains_Variance_Fields = {
  __typename?: 'blockchains_variance_fields';
  id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "coins" */
export type Coins = {
  __typename?: 'coins';
  /** An object relationship */
  blockchain: Maybe<Blockchains>;
  blockchain_id: Maybe<Scalars['Int']>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  external_id: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  ticker: Scalars['String'];
  type: Maybe<Scalars['String']>;
};

/** aggregated selection of "coins" */
export type Coins_Aggregate = {
  __typename?: 'coins_aggregate';
  aggregate: Maybe<Coins_Aggregate_Fields>;
  nodes: Array<Coins>;
};

/** aggregate fields of "coins" */
export type Coins_Aggregate_Fields = {
  __typename?: 'coins_aggregate_fields';
  avg: Maybe<Coins_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Coins_Max_Fields>;
  min: Maybe<Coins_Min_Fields>;
  stddev: Maybe<Coins_Stddev_Fields>;
  stddev_pop: Maybe<Coins_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Coins_Stddev_Samp_Fields>;
  sum: Maybe<Coins_Sum_Fields>;
  var_pop: Maybe<Coins_Var_Pop_Fields>;
  var_samp: Maybe<Coins_Var_Samp_Fields>;
  variance: Maybe<Coins_Variance_Fields>;
};


/** aggregate fields of "coins" */
export type Coins_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Coins_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Coins_Avg_Fields = {
  __typename?: 'coins_avg_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "coins". All fields are combined with a logical 'AND'. */
export type Coins_Bool_Exp = {
  _and: InputMaybe<Array<Coins_Bool_Exp>>;
  _not: InputMaybe<Coins_Bool_Exp>;
  _or: InputMaybe<Array<Coins_Bool_Exp>>;
  blockchain: InputMaybe<Blockchains_Bool_Exp>;
  blockchain_id: InputMaybe<Int_Comparison_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  ticker: InputMaybe<String_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "coins" */
export enum Coins_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  CoinsExternalIdKey = 'coins_external_id_key',
  /** unique or primary key constraint on columns "id" */
  CoinsPkey = 'coins_pkey'
}

/** input type for incrementing numeric columns in table "coins" */
export type Coins_Inc_Input = {
  blockchain_id: InputMaybe<Scalars['Int']>;
  company_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "coins" */
export type Coins_Insert_Input = {
  blockchain: InputMaybe<Blockchains_Obj_Rel_Insert_Input>;
  blockchain_id: InputMaybe<Scalars['Int']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  ticker: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Coins_Max_Fields = {
  __typename?: 'coins_max_fields';
  blockchain_id: Maybe<Scalars['Int']>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  ticker: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Coins_Min_Fields = {
  __typename?: 'coins_min_fields';
  blockchain_id: Maybe<Scalars['Int']>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  ticker: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coins" */
export type Coins_Mutation_Response = {
  __typename?: 'coins_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Coins>;
};

/** input type for inserting object relation for remote table "coins" */
export type Coins_Obj_Rel_Insert_Input = {
  data: Coins_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Coins_On_Conflict>;
};

/** on_conflict condition type for table "coins" */
export type Coins_On_Conflict = {
  constraint: Coins_Constraint;
  update_columns: Array<Coins_Update_Column>;
  where: InputMaybe<Coins_Bool_Exp>;
};

/** Ordering options when selecting data from "coins". */
export type Coins_Order_By = {
  blockchain: InputMaybe<Blockchains_Order_By>;
  blockchain_id: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  ticker: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** primary key columns input for table: coins */
export type Coins_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "coins" */
export enum Coins_Select_Column {
  /** column name */
  BlockchainId = 'blockchain_id',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Ticker = 'ticker',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "coins" */
export type Coins_Set_Input = {
  blockchain_id: InputMaybe<Scalars['Int']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  ticker: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Coins_Stddev_Fields = {
  __typename?: 'coins_stddev_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Coins_Stddev_Pop_Fields = {
  __typename?: 'coins_stddev_pop_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Coins_Stddev_Samp_Fields = {
  __typename?: 'coins_stddev_samp_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "coins" */
export type Coins_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coins_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coins_Stream_Cursor_Value_Input = {
  blockchain_id: InputMaybe<Scalars['Int']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  ticker: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Coins_Sum_Fields = {
  __typename?: 'coins_sum_fields';
  blockchain_id: Maybe<Scalars['Int']>;
  company_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "coins" */
export enum Coins_Update_Column {
  /** column name */
  BlockchainId = 'blockchain_id',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Ticker = 'ticker',
  /** column name */
  Type = 'type'
}

export type Coins_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Coins_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Coins_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coins_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Coins_Var_Pop_Fields = {
  __typename?: 'coins_var_pop_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Coins_Var_Samp_Fields = {
  __typename?: 'coins_var_samp_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Coins_Variance_Fields = {
  __typename?: 'coins_variance_fields';
  blockchain_id: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "comments" */
export type Comments = {
  __typename?: 'comments';
  content: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  created_by_user: Maybe<Users_Public>;
  created_by_user_id: Scalars['Int'];
  id: Scalars['Int'];
  /** An object relationship */
  note: Maybe<Notes>;
  note_id: Scalars['Int'];
};

/** aggregated selection of "comments" */
export type Comments_Aggregate = {
  __typename?: 'comments_aggregate';
  aggregate: Maybe<Comments_Aggregate_Fields>;
  nodes: Array<Comments>;
};

export type Comments_Aggregate_Bool_Exp = {
  count: InputMaybe<Comments_Aggregate_Bool_Exp_Count>;
};

export type Comments_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Comments_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Comments_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "comments" */
export type Comments_Aggregate_Fields = {
  __typename?: 'comments_aggregate_fields';
  avg: Maybe<Comments_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Comments_Max_Fields>;
  min: Maybe<Comments_Min_Fields>;
  stddev: Maybe<Comments_Stddev_Fields>;
  stddev_pop: Maybe<Comments_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Comments_Stddev_Samp_Fields>;
  sum: Maybe<Comments_Sum_Fields>;
  var_pop: Maybe<Comments_Var_Pop_Fields>;
  var_samp: Maybe<Comments_Var_Samp_Fields>;
  variance: Maybe<Comments_Variance_Fields>;
};


/** aggregate fields of "comments" */
export type Comments_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Comments_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "comments" */
export type Comments_Aggregate_Order_By = {
  avg: InputMaybe<Comments_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Comments_Max_Order_By>;
  min: InputMaybe<Comments_Min_Order_By>;
  stddev: InputMaybe<Comments_Stddev_Order_By>;
  stddev_pop: InputMaybe<Comments_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Comments_Stddev_Samp_Order_By>;
  sum: InputMaybe<Comments_Sum_Order_By>;
  var_pop: InputMaybe<Comments_Var_Pop_Order_By>;
  var_samp: InputMaybe<Comments_Var_Samp_Order_By>;
  variance: InputMaybe<Comments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "comments" */
export type Comments_Arr_Rel_Insert_Input = {
  data: Array<Comments_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Comments_On_Conflict>;
};

/** aggregate avg on columns */
export type Comments_Avg_Fields = {
  __typename?: 'comments_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "comments" */
export type Comments_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'. */
export type Comments_Bool_Exp = {
  _and: InputMaybe<Array<Comments_Bool_Exp>>;
  _not: InputMaybe<Comments_Bool_Exp>;
  _or: InputMaybe<Array<Comments_Bool_Exp>>;
  content: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by_user: InputMaybe<Users_Public_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  note: InputMaybe<Notes_Bool_Exp>;
  note_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "comments" */
export enum Comments_Constraint {
  /** unique or primary key constraint on columns "id" */
  CommentsPkey = 'comments_pkey'
}

/** input type for incrementing numeric columns in table "comments" */
export type Comments_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "comments" */
export type Comments_Insert_Input = {
  content: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note: InputMaybe<Notes_Obj_Rel_Insert_Input>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Comments_Max_Fields = {
  __typename?: 'comments_max_fields';
  content: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "comments" */
export type Comments_Max_Order_By = {
  content: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Comments_Min_Fields = {
  __typename?: 'comments_min_fields';
  content: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "comments" */
export type Comments_Min_Order_By = {
  content: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "comments" */
export type Comments_Mutation_Response = {
  __typename?: 'comments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Comments>;
};

/** on_conflict condition type for table "comments" */
export type Comments_On_Conflict = {
  constraint: Comments_Constraint;
  update_columns: Array<Comments_Update_Column>;
  where: InputMaybe<Comments_Bool_Exp>;
};

/** Ordering options when selecting data from "comments". */
export type Comments_Order_By = {
  content: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by_user: InputMaybe<Users_Public_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note: InputMaybe<Notes_Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: comments */
export type Comments_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "comments" */
export enum Comments_Select_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  NoteId = 'note_id'
}

/** input type for updating data in table "comments" */
export type Comments_Set_Input = {
  content: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Comments_Stddev_Fields = {
  __typename?: 'comments_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "comments" */
export type Comments_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Comments_Stddev_Pop_Fields = {
  __typename?: 'comments_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "comments" */
export type Comments_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Comments_Stddev_Samp_Fields = {
  __typename?: 'comments_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "comments" */
export type Comments_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "comments" */
export type Comments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Comments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Comments_Stream_Cursor_Value_Input = {
  content: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Comments_Sum_Fields = {
  __typename?: 'comments_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "comments" */
export type Comments_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** update columns of table "comments" */
export enum Comments_Update_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  NoteId = 'note_id'
}

export type Comments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Comments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Comments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Comments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Comments_Var_Pop_Fields = {
  __typename?: 'comments_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "comments" */
export type Comments_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Comments_Var_Samp_Fields = {
  __typename?: 'comments_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "comments" */
export type Comments_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Comments_Variance_Fields = {
  __typename?: 'comments_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "comments" */
export type Comments_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** columns and relationships of "companies" */
export type Companies = {
  __typename?: 'companies';
  aliases: Maybe<Scalars['String']>;
  audit_file: Maybe<Scalars['String']>;
  bitcointalk: Maybe<Scalars['String']>;
  blockchain_explorer: Maybe<Scalars['String']>;
  careers_page: Maybe<Scalars['String']>;
  /** An object relationship */
  coin: Maybe<Coins>;
  coin_id: Maybe<Scalars['Int']>;
  company_linkedin: Maybe<Scalars['String']>;
  company_size: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  data_enriched_at: Maybe<Scalars['timestamp']>;
  datapoints_count: Scalars['Int'];
  date_added: Maybe<Scalars['date']>;
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Scalars['Int'];
  external_id: Maybe<Scalars['String']>;
  facebook: Maybe<Scalars['String']>;
  /** An array relationship */
  follows: Array<Follows_Companies>;
  /** An aggregate relationship */
  follows_aggregate: Follows_Companies_Aggregate;
  /** An array relationship */
  from_links: Array<Resource_Links>;
  /** An aggregate relationship */
  from_links_aggregate: Resource_Links_Aggregate;
  geopoint: Maybe<Scalars['geography']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  ico_end: Maybe<Scalars['date']>;
  ico_start: Maybe<Scalars['date']>;
  id: Scalars['Int'];
  instagram: Maybe<Scalars['String']>;
  /** An array relationship */
  investment_rounds: Array<Investment_Rounds>;
  /** An aggregate relationship */
  investment_rounds_aggregate: Investment_Rounds_Aggregate;
  investor_amount: Maybe<Scalars['bigint']>;
  latitude: Maybe<Scalars['float8']>;
  layer: Maybe<Scalars['String']>;
  layer_detail: Maybe<Scalars['String']>;
  library: Maybe<Scalars['jsonb']>;
  location_json: Maybe<Scalars['jsonb']>;
  logo: Maybe<Scalars['jsonb']>;
  longitude: Maybe<Scalars['float8']>;
  market_verified: Maybe<Scalars['String']>;
  medium: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  /** An array relationship */
  news_links: Array<News_Organizations>;
  /** An aggregate relationship */
  news_links_aggregate: News_Organizations_Aggregate;
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  reddit: Maybe<Scalars['String']>;
  search_count: Maybe<Scalars['Int']>;
  sentiment: Maybe<Scalars['jsonb']>;
  slug: Scalars['String'];
  status: Scalars['String'];
  status_tags: Maybe<Scalars['jsonb']>;
  tags: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  teamMembers: Array<Team_Members>;
  /** An aggregate relationship */
  teamMembers_aggregate: Team_Members_Aggregate;
  team_enrichment_status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  /** An array relationship */
  to_links: Array<Resource_Links>;
  /** An aggregate relationship */
  to_links_aggregate: Resource_Links_Aggregate;
  total_employees: Maybe<Scalars['numeric']>;
  total_valuation: Maybe<Scalars['String']>;
  trajectory: Maybe<Scalars['float8']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  velocity_linkedin: Maybe<Scalars['String']>;
  velocity_token: Maybe<Scalars['String']>;
  web3_address: Maybe<Scalars['jsonb']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  white_paper: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
  youtube: Maybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesFollowsArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesFollows_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesFrom_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesFrom_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesInvestment_RoundsArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesInvestment_Rounds_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesLibraryArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesLocation_JsonArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesLogoArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesNews_LinksArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesNews_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesSentimentArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesStatus_TagsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesTagsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "companies" */
export type CompaniesTeamMembersArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesTeamMembers_AggregateArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesTo_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesTo_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "companies" */
export type CompaniesWeb3_AddressArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "companies" */
export type Companies_Aggregate = {
  __typename?: 'companies_aggregate';
  aggregate: Maybe<Companies_Aggregate_Fields>;
  nodes: Array<Companies>;
};

/** aggregate fields of "companies" */
export type Companies_Aggregate_Fields = {
  __typename?: 'companies_aggregate_fields';
  avg: Maybe<Companies_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Companies_Max_Fields>;
  min: Maybe<Companies_Min_Fields>;
  stddev: Maybe<Companies_Stddev_Fields>;
  stddev_pop: Maybe<Companies_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Companies_Stddev_Samp_Fields>;
  sum: Maybe<Companies_Sum_Fields>;
  var_pop: Maybe<Companies_Var_Pop_Fields>;
  var_samp: Maybe<Companies_Var_Samp_Fields>;
  variance: Maybe<Companies_Variance_Fields>;
};


/** aggregate fields of "companies" */
export type Companies_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Companies_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Companies_Append_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Companies_Avg_Fields = {
  __typename?: 'companies_avg_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'. */
export type Companies_Bool_Exp = {
  _and: InputMaybe<Array<Companies_Bool_Exp>>;
  _not: InputMaybe<Companies_Bool_Exp>;
  _or: InputMaybe<Array<Companies_Bool_Exp>>;
  aliases: InputMaybe<String_Comparison_Exp>;
  audit_file: InputMaybe<String_Comparison_Exp>;
  bitcointalk: InputMaybe<String_Comparison_Exp>;
  blockchain_explorer: InputMaybe<String_Comparison_Exp>;
  careers_page: InputMaybe<String_Comparison_Exp>;
  coin: InputMaybe<Coins_Bool_Exp>;
  coin_id: InputMaybe<Int_Comparison_Exp>;
  company_linkedin: InputMaybe<String_Comparison_Exp>;
  company_size: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_enriched_at: InputMaybe<Timestamp_Comparison_Exp>;
  datapoints_count: InputMaybe<Int_Comparison_Exp>;
  date_added: InputMaybe<Date_Comparison_Exp>;
  discord: InputMaybe<String_Comparison_Exp>;
  domain_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email_domain: InputMaybe<String_Comparison_Exp>;
  enrichment_priority: InputMaybe<Int_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  facebook: InputMaybe<String_Comparison_Exp>;
  follows: InputMaybe<Follows_Companies_Bool_Exp>;
  follows_aggregate: InputMaybe<Follows_Companies_Aggregate_Bool_Exp>;
  from_links: InputMaybe<Resource_Links_Bool_Exp>;
  from_links_aggregate: InputMaybe<Resource_Links_Aggregate_Bool_Exp>;
  geopoint: InputMaybe<Geography_Comparison_Exp>;
  github: InputMaybe<String_Comparison_Exp>;
  glassdoor: InputMaybe<String_Comparison_Exp>;
  ico_end: InputMaybe<Date_Comparison_Exp>;
  ico_start: InputMaybe<Date_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  instagram: InputMaybe<String_Comparison_Exp>;
  investment_rounds: InputMaybe<Investment_Rounds_Bool_Exp>;
  investment_rounds_aggregate: InputMaybe<Investment_Rounds_Aggregate_Bool_Exp>;
  investor_amount: InputMaybe<Bigint_Comparison_Exp>;
  latitude: InputMaybe<Float8_Comparison_Exp>;
  layer: InputMaybe<String_Comparison_Exp>;
  layer_detail: InputMaybe<String_Comparison_Exp>;
  library: InputMaybe<Jsonb_Comparison_Exp>;
  location_json: InputMaybe<Jsonb_Comparison_Exp>;
  logo: InputMaybe<Jsonb_Comparison_Exp>;
  longitude: InputMaybe<Float8_Comparison_Exp>;
  market_verified: InputMaybe<String_Comparison_Exp>;
  medium: InputMaybe<String_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  news_links: InputMaybe<News_Organizations_Bool_Exp>;
  news_links_aggregate: InputMaybe<News_Organizations_Aggregate_Bool_Exp>;
  notes: InputMaybe<String_Comparison_Exp>;
  num_of_views: InputMaybe<Int_Comparison_Exp>;
  overview: InputMaybe<String_Comparison_Exp>;
  reddit: InputMaybe<String_Comparison_Exp>;
  search_count: InputMaybe<Int_Comparison_Exp>;
  sentiment: InputMaybe<Jsonb_Comparison_Exp>;
  slug: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  status_tags: InputMaybe<Jsonb_Comparison_Exp>;
  tags: InputMaybe<Jsonb_Comparison_Exp>;
  teamMembers: InputMaybe<Team_Members_Bool_Exp>;
  teamMembers_aggregate: InputMaybe<Team_Members_Aggregate_Bool_Exp>;
  team_enrichment_status: InputMaybe<String_Comparison_Exp>;
  telegram: InputMaybe<String_Comparison_Exp>;
  to_links: InputMaybe<Resource_Links_Bool_Exp>;
  to_links_aggregate: InputMaybe<Resource_Links_Aggregate_Bool_Exp>;
  total_employees: InputMaybe<Numeric_Comparison_Exp>;
  total_valuation: InputMaybe<String_Comparison_Exp>;
  trajectory: InputMaybe<Float8_Comparison_Exp>;
  twitter: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  velocity_linkedin: InputMaybe<String_Comparison_Exp>;
  velocity_token: InputMaybe<String_Comparison_Exp>;
  web3_address: InputMaybe<Jsonb_Comparison_Exp>;
  web_domain: InputMaybe<String_Comparison_Exp>;
  website: InputMaybe<String_Comparison_Exp>;
  white_paper: InputMaybe<String_Comparison_Exp>;
  year_founded: InputMaybe<String_Comparison_Exp>;
  youtube: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "companies" */
export enum Companies_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  CompaniesExternalIdKey = 'companies_external_id_key',
  /** unique or primary key constraint on columns "id" */
  CompaniesPkey = 'companies_pkey',
  /** unique or primary key constraint on columns "slug" */
  CompaniesSlugKey = 'companies_slug_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Companies_Delete_At_Path_Input = {
  library: InputMaybe<Array<Scalars['String']>>;
  location_json: InputMaybe<Array<Scalars['String']>>;
  logo: InputMaybe<Array<Scalars['String']>>;
  sentiment: InputMaybe<Array<Scalars['String']>>;
  status_tags: InputMaybe<Array<Scalars['String']>>;
  tags: InputMaybe<Array<Scalars['String']>>;
  web3_address: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Companies_Delete_Elem_Input = {
  library: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['Int']>;
  logo: InputMaybe<Scalars['Int']>;
  sentiment: InputMaybe<Scalars['Int']>;
  status_tags: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['Int']>;
  web3_address: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Companies_Delete_Key_Input = {
  library: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['String']>;
  logo: InputMaybe<Scalars['String']>;
  sentiment: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['String']>;
  tags: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "companies_edit_access" */
export type Companies_Edit_Access = {
  __typename?: 'companies_edit_access';
  /** An object relationship */
  company: Maybe<Companies>;
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "companies_edit_access" */
export type Companies_Edit_Access_Aggregate = {
  __typename?: 'companies_edit_access_aggregate';
  aggregate: Maybe<Companies_Edit_Access_Aggregate_Fields>;
  nodes: Array<Companies_Edit_Access>;
};

export type Companies_Edit_Access_Aggregate_Bool_Exp = {
  count: InputMaybe<Companies_Edit_Access_Aggregate_Bool_Exp_Count>;
};

export type Companies_Edit_Access_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Companies_Edit_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "companies_edit_access" */
export type Companies_Edit_Access_Aggregate_Fields = {
  __typename?: 'companies_edit_access_aggregate_fields';
  avg: Maybe<Companies_Edit_Access_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Companies_Edit_Access_Max_Fields>;
  min: Maybe<Companies_Edit_Access_Min_Fields>;
  stddev: Maybe<Companies_Edit_Access_Stddev_Fields>;
  stddev_pop: Maybe<Companies_Edit_Access_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Companies_Edit_Access_Stddev_Samp_Fields>;
  sum: Maybe<Companies_Edit_Access_Sum_Fields>;
  var_pop: Maybe<Companies_Edit_Access_Var_Pop_Fields>;
  var_samp: Maybe<Companies_Edit_Access_Var_Samp_Fields>;
  variance: Maybe<Companies_Edit_Access_Variance_Fields>;
};


/** aggregate fields of "companies_edit_access" */
export type Companies_Edit_Access_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "companies_edit_access" */
export type Companies_Edit_Access_Aggregate_Order_By = {
  avg: InputMaybe<Companies_Edit_Access_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Companies_Edit_Access_Max_Order_By>;
  min: InputMaybe<Companies_Edit_Access_Min_Order_By>;
  stddev: InputMaybe<Companies_Edit_Access_Stddev_Order_By>;
  stddev_pop: InputMaybe<Companies_Edit_Access_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Companies_Edit_Access_Stddev_Samp_Order_By>;
  sum: InputMaybe<Companies_Edit_Access_Sum_Order_By>;
  var_pop: InputMaybe<Companies_Edit_Access_Var_Pop_Order_By>;
  var_samp: InputMaybe<Companies_Edit_Access_Var_Samp_Order_By>;
  variance: InputMaybe<Companies_Edit_Access_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "companies_edit_access" */
export type Companies_Edit_Access_Arr_Rel_Insert_Input = {
  data: Array<Companies_Edit_Access_Insert_Input>;
};

/** aggregate avg on columns */
export type Companies_Edit_Access_Avg_Fields = {
  __typename?: 'companies_edit_access_avg_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "companies_edit_access". All fields are combined with a logical 'AND'. */
export type Companies_Edit_Access_Bool_Exp = {
  _and: InputMaybe<Array<Companies_Edit_Access_Bool_Exp>>;
  _not: InputMaybe<Companies_Edit_Access_Bool_Exp>;
  _or: InputMaybe<Array<Companies_Edit_Access_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "companies_edit_access" */
export type Companies_Edit_Access_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "companies_edit_access" */
export type Companies_Edit_Access_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Companies_Edit_Access_Max_Fields = {
  __typename?: 'companies_edit_access_max_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Max_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Companies_Edit_Access_Min_Fields = {
  __typename?: 'companies_edit_access_min_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Min_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "companies_edit_access" */
export type Companies_Edit_Access_Mutation_Response = {
  __typename?: 'companies_edit_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Companies_Edit_Access>;
};

/** Ordering options when selecting data from "companies_edit_access". */
export type Companies_Edit_Access_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** select columns of table "companies_edit_access" */
export enum Companies_Edit_Access_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "companies_edit_access" */
export type Companies_Edit_Access_Set_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Companies_Edit_Access_Stddev_Fields = {
  __typename?: 'companies_edit_access_stddev_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Companies_Edit_Access_Stddev_Pop_Fields = {
  __typename?: 'companies_edit_access_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Companies_Edit_Access_Stddev_Samp_Fields = {
  __typename?: 'companies_edit_access_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "companies_edit_access" */
export type Companies_Edit_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Companies_Edit_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Companies_Edit_Access_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Companies_Edit_Access_Sum_Fields = {
  __typename?: 'companies_edit_access_sum_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

export type Companies_Edit_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Companies_Edit_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Companies_Edit_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Companies_Edit_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Companies_Edit_Access_Var_Pop_Fields = {
  __typename?: 'companies_edit_access_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Companies_Edit_Access_Var_Samp_Fields = {
  __typename?: 'companies_edit_access_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Companies_Edit_Access_Variance_Fields = {
  __typename?: 'companies_edit_access_variance_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "companies_edit_access" */
export type Companies_Edit_Access_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** input type for incrementing numeric columns in table "companies" */
export type Companies_Inc_Input = {
  coin_id: InputMaybe<Scalars['Int']>;
  company_size: InputMaybe<Scalars['Int']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  investor_amount: InputMaybe<Scalars['bigint']>;
  latitude: InputMaybe<Scalars['float8']>;
  longitude: InputMaybe<Scalars['float8']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  search_count: InputMaybe<Scalars['Int']>;
  total_employees: InputMaybe<Scalars['numeric']>;
  trajectory: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "companies" */
export type Companies_Insert_Input = {
  aliases: InputMaybe<Scalars['String']>;
  audit_file: InputMaybe<Scalars['String']>;
  bitcointalk: InputMaybe<Scalars['String']>;
  blockchain_explorer: InputMaybe<Scalars['String']>;
  careers_page: InputMaybe<Scalars['String']>;
  coin: InputMaybe<Coins_Obj_Rel_Insert_Input>;
  coin_id: InputMaybe<Scalars['Int']>;
  company_linkedin: InputMaybe<Scalars['String']>;
  company_size: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamp']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  date_added: InputMaybe<Scalars['date']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook: InputMaybe<Scalars['String']>;
  follows: InputMaybe<Follows_Companies_Arr_Rel_Insert_Input>;
  from_links: InputMaybe<Resource_Links_Arr_Rel_Insert_Input>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  ico_end: InputMaybe<Scalars['date']>;
  ico_start: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  investment_rounds: InputMaybe<Investment_Rounds_Arr_Rel_Insert_Input>;
  investor_amount: InputMaybe<Scalars['bigint']>;
  latitude: InputMaybe<Scalars['float8']>;
  layer: InputMaybe<Scalars['String']>;
  layer_detail: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  market_verified: InputMaybe<Scalars['String']>;
  medium: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  news_links: InputMaybe<News_Organizations_Arr_Rel_Insert_Input>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  reddit: InputMaybe<Scalars['String']>;
  search_count: InputMaybe<Scalars['Int']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  teamMembers: InputMaybe<Team_Members_Arr_Rel_Insert_Input>;
  team_enrichment_status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  to_links: InputMaybe<Resource_Links_Arr_Rel_Insert_Input>;
  total_employees: InputMaybe<Scalars['numeric']>;
  total_valuation: InputMaybe<Scalars['String']>;
  trajectory: InputMaybe<Scalars['float8']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  velocity_linkedin: InputMaybe<Scalars['String']>;
  velocity_token: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  white_paper: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
  youtube: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Companies_Max_Fields = {
  __typename?: 'companies_max_fields';
  aliases: Maybe<Scalars['String']>;
  audit_file: Maybe<Scalars['String']>;
  bitcointalk: Maybe<Scalars['String']>;
  blockchain_explorer: Maybe<Scalars['String']>;
  careers_page: Maybe<Scalars['String']>;
  coin_id: Maybe<Scalars['Int']>;
  company_linkedin: Maybe<Scalars['String']>;
  company_size: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamp']>;
  datapoints_count: Maybe<Scalars['Int']>;
  date_added: Maybe<Scalars['date']>;
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  facebook: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  ico_end: Maybe<Scalars['date']>;
  ico_start: Maybe<Scalars['date']>;
  id: Maybe<Scalars['Int']>;
  instagram: Maybe<Scalars['String']>;
  investor_amount: Maybe<Scalars['bigint']>;
  latitude: Maybe<Scalars['float8']>;
  layer: Maybe<Scalars['String']>;
  layer_detail: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  market_verified: Maybe<Scalars['String']>;
  medium: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  reddit: Maybe<Scalars['String']>;
  search_count: Maybe<Scalars['Int']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  team_enrichment_status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  total_employees: Maybe<Scalars['numeric']>;
  total_valuation: Maybe<Scalars['String']>;
  trajectory: Maybe<Scalars['float8']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  velocity_linkedin: Maybe<Scalars['String']>;
  velocity_token: Maybe<Scalars['String']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  white_paper: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
  youtube: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Companies_Min_Fields = {
  __typename?: 'companies_min_fields';
  aliases: Maybe<Scalars['String']>;
  audit_file: Maybe<Scalars['String']>;
  bitcointalk: Maybe<Scalars['String']>;
  blockchain_explorer: Maybe<Scalars['String']>;
  careers_page: Maybe<Scalars['String']>;
  coin_id: Maybe<Scalars['Int']>;
  company_linkedin: Maybe<Scalars['String']>;
  company_size: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamp']>;
  datapoints_count: Maybe<Scalars['Int']>;
  date_added: Maybe<Scalars['date']>;
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  facebook: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  ico_end: Maybe<Scalars['date']>;
  ico_start: Maybe<Scalars['date']>;
  id: Maybe<Scalars['Int']>;
  instagram: Maybe<Scalars['String']>;
  investor_amount: Maybe<Scalars['bigint']>;
  latitude: Maybe<Scalars['float8']>;
  layer: Maybe<Scalars['String']>;
  layer_detail: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  market_verified: Maybe<Scalars['String']>;
  medium: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  reddit: Maybe<Scalars['String']>;
  search_count: Maybe<Scalars['Int']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  team_enrichment_status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  total_employees: Maybe<Scalars['numeric']>;
  total_valuation: Maybe<Scalars['String']>;
  trajectory: Maybe<Scalars['float8']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  velocity_linkedin: Maybe<Scalars['String']>;
  velocity_token: Maybe<Scalars['String']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  white_paper: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
  youtube: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "companies" */
export type Companies_Mutation_Response = {
  __typename?: 'companies_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Companies>;
};

/** input type for inserting object relation for remote table "companies" */
export type Companies_Obj_Rel_Insert_Input = {
  data: Companies_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Companies_On_Conflict>;
};

/** on_conflict condition type for table "companies" */
export type Companies_On_Conflict = {
  constraint: Companies_Constraint;
  update_columns: Array<Companies_Update_Column>;
  where: InputMaybe<Companies_Bool_Exp>;
};

/** Ordering options when selecting data from "companies". */
export type Companies_Order_By = {
  aliases: InputMaybe<Order_By>;
  audit_file: InputMaybe<Order_By>;
  bitcointalk: InputMaybe<Order_By>;
  blockchain_explorer: InputMaybe<Order_By>;
  careers_page: InputMaybe<Order_By>;
  coin: InputMaybe<Coins_Order_By>;
  coin_id: InputMaybe<Order_By>;
  company_linkedin: InputMaybe<Order_By>;
  company_size: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  datapoints_count: InputMaybe<Order_By>;
  date_added: InputMaybe<Order_By>;
  discord: InputMaybe<Order_By>;
  domain_enriched_at: InputMaybe<Order_By>;
  email_domain: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  facebook: InputMaybe<Order_By>;
  follows_aggregate: InputMaybe<Follows_Companies_Aggregate_Order_By>;
  from_links_aggregate: InputMaybe<Resource_Links_Aggregate_Order_By>;
  geopoint: InputMaybe<Order_By>;
  github: InputMaybe<Order_By>;
  glassdoor: InputMaybe<Order_By>;
  ico_end: InputMaybe<Order_By>;
  ico_start: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  instagram: InputMaybe<Order_By>;
  investment_rounds_aggregate: InputMaybe<Investment_Rounds_Aggregate_Order_By>;
  investor_amount: InputMaybe<Order_By>;
  latitude: InputMaybe<Order_By>;
  layer: InputMaybe<Order_By>;
  layer_detail: InputMaybe<Order_By>;
  library: InputMaybe<Order_By>;
  location_json: InputMaybe<Order_By>;
  logo: InputMaybe<Order_By>;
  longitude: InputMaybe<Order_By>;
  market_verified: InputMaybe<Order_By>;
  medium: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  news_links_aggregate: InputMaybe<News_Organizations_Aggregate_Order_By>;
  notes: InputMaybe<Order_By>;
  num_of_views: InputMaybe<Order_By>;
  overview: InputMaybe<Order_By>;
  reddit: InputMaybe<Order_By>;
  search_count: InputMaybe<Order_By>;
  sentiment: InputMaybe<Order_By>;
  slug: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  status_tags: InputMaybe<Order_By>;
  tags: InputMaybe<Order_By>;
  teamMembers_aggregate: InputMaybe<Team_Members_Aggregate_Order_By>;
  team_enrichment_status: InputMaybe<Order_By>;
  telegram: InputMaybe<Order_By>;
  to_links_aggregate: InputMaybe<Resource_Links_Aggregate_Order_By>;
  total_employees: InputMaybe<Order_By>;
  total_valuation: InputMaybe<Order_By>;
  trajectory: InputMaybe<Order_By>;
  twitter: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  velocity_linkedin: InputMaybe<Order_By>;
  velocity_token: InputMaybe<Order_By>;
  web3_address: InputMaybe<Order_By>;
  web_domain: InputMaybe<Order_By>;
  website: InputMaybe<Order_By>;
  white_paper: InputMaybe<Order_By>;
  year_founded: InputMaybe<Order_By>;
  youtube: InputMaybe<Order_By>;
};

/** primary key columns input for table: companies */
export type Companies_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Companies_Prepend_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "companies" */
export enum Companies_Select_Column {
  /** column name */
  Aliases = 'aliases',
  /** column name */
  AuditFile = 'audit_file',
  /** column name */
  Bitcointalk = 'bitcointalk',
  /** column name */
  BlockchainExplorer = 'blockchain_explorer',
  /** column name */
  CareersPage = 'careers_page',
  /** column name */
  CoinId = 'coin_id',
  /** column name */
  CompanyLinkedin = 'company_linkedin',
  /** column name */
  CompanySize = 'company_size',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  DateAdded = 'date_added',
  /** column name */
  Discord = 'discord',
  /** column name */
  DomainEnrichedAt = 'domain_enriched_at',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Facebook = 'facebook',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Glassdoor = 'glassdoor',
  /** column name */
  IcoEnd = 'ico_end',
  /** column name */
  IcoStart = 'ico_start',
  /** column name */
  Id = 'id',
  /** column name */
  Instagram = 'instagram',
  /** column name */
  InvestorAmount = 'investor_amount',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Layer = 'layer',
  /** column name */
  LayerDetail = 'layer_detail',
  /** column name */
  Library = 'library',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Logo = 'logo',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MarketVerified = 'market_verified',
  /** column name */
  Medium = 'medium',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  Reddit = 'reddit',
  /** column name */
  SearchCount = 'search_count',
  /** column name */
  Sentiment = 'sentiment',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusTags = 'status_tags',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamEnrichmentStatus = 'team_enrichment_status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  TotalEmployees = 'total_employees',
  /** column name */
  TotalValuation = 'total_valuation',
  /** column name */
  Trajectory = 'trajectory',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VelocityLinkedin = 'velocity_linkedin',
  /** column name */
  VelocityToken = 'velocity_token',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebDomain = 'web_domain',
  /** column name */
  Website = 'website',
  /** column name */
  WhitePaper = 'white_paper',
  /** column name */
  YearFounded = 'year_founded',
  /** column name */
  Youtube = 'youtube'
}

/** input type for updating data in table "companies" */
export type Companies_Set_Input = {
  aliases: InputMaybe<Scalars['String']>;
  audit_file: InputMaybe<Scalars['String']>;
  bitcointalk: InputMaybe<Scalars['String']>;
  blockchain_explorer: InputMaybe<Scalars['String']>;
  careers_page: InputMaybe<Scalars['String']>;
  coin_id: InputMaybe<Scalars['Int']>;
  company_linkedin: InputMaybe<Scalars['String']>;
  company_size: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamp']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  date_added: InputMaybe<Scalars['date']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  ico_end: InputMaybe<Scalars['date']>;
  ico_start: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  investor_amount: InputMaybe<Scalars['bigint']>;
  latitude: InputMaybe<Scalars['float8']>;
  layer: InputMaybe<Scalars['String']>;
  layer_detail: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  market_verified: InputMaybe<Scalars['String']>;
  medium: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  reddit: InputMaybe<Scalars['String']>;
  search_count: InputMaybe<Scalars['Int']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  team_enrichment_status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  total_employees: InputMaybe<Scalars['numeric']>;
  total_valuation: InputMaybe<Scalars['String']>;
  trajectory: InputMaybe<Scalars['float8']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  velocity_linkedin: InputMaybe<Scalars['String']>;
  velocity_token: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  white_paper: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
  youtube: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Companies_Stddev_Fields = {
  __typename?: 'companies_stddev_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Companies_Stddev_Pop_Fields = {
  __typename?: 'companies_stddev_pop_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Companies_Stddev_Samp_Fields = {
  __typename?: 'companies_stddev_samp_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "companies" */
export type Companies_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Companies_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Companies_Stream_Cursor_Value_Input = {
  aliases: InputMaybe<Scalars['String']>;
  audit_file: InputMaybe<Scalars['String']>;
  bitcointalk: InputMaybe<Scalars['String']>;
  blockchain_explorer: InputMaybe<Scalars['String']>;
  careers_page: InputMaybe<Scalars['String']>;
  coin_id: InputMaybe<Scalars['Int']>;
  company_linkedin: InputMaybe<Scalars['String']>;
  company_size: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamp']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  date_added: InputMaybe<Scalars['date']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  ico_end: InputMaybe<Scalars['date']>;
  ico_start: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  investor_amount: InputMaybe<Scalars['bigint']>;
  latitude: InputMaybe<Scalars['float8']>;
  layer: InputMaybe<Scalars['String']>;
  layer_detail: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  market_verified: InputMaybe<Scalars['String']>;
  medium: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  reddit: InputMaybe<Scalars['String']>;
  search_count: InputMaybe<Scalars['Int']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  team_enrichment_status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  total_employees: InputMaybe<Scalars['numeric']>;
  total_valuation: InputMaybe<Scalars['String']>;
  trajectory: InputMaybe<Scalars['float8']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  velocity_linkedin: InputMaybe<Scalars['String']>;
  velocity_token: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  white_paper: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
  youtube: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Companies_Sum_Fields = {
  __typename?: 'companies_sum_fields';
  coin_id: Maybe<Scalars['Int']>;
  company_size: Maybe<Scalars['Int']>;
  datapoints_count: Maybe<Scalars['Int']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  investor_amount: Maybe<Scalars['bigint']>;
  latitude: Maybe<Scalars['float8']>;
  longitude: Maybe<Scalars['float8']>;
  num_of_views: Maybe<Scalars['Int']>;
  search_count: Maybe<Scalars['Int']>;
  total_employees: Maybe<Scalars['numeric']>;
  trajectory: Maybe<Scalars['float8']>;
};

/** update columns of table "companies" */
export enum Companies_Update_Column {
  /** column name */
  Aliases = 'aliases',
  /** column name */
  AuditFile = 'audit_file',
  /** column name */
  Bitcointalk = 'bitcointalk',
  /** column name */
  BlockchainExplorer = 'blockchain_explorer',
  /** column name */
  CareersPage = 'careers_page',
  /** column name */
  CoinId = 'coin_id',
  /** column name */
  CompanyLinkedin = 'company_linkedin',
  /** column name */
  CompanySize = 'company_size',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  DateAdded = 'date_added',
  /** column name */
  Discord = 'discord',
  /** column name */
  DomainEnrichedAt = 'domain_enriched_at',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Facebook = 'facebook',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Glassdoor = 'glassdoor',
  /** column name */
  IcoEnd = 'ico_end',
  /** column name */
  IcoStart = 'ico_start',
  /** column name */
  Id = 'id',
  /** column name */
  Instagram = 'instagram',
  /** column name */
  InvestorAmount = 'investor_amount',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Layer = 'layer',
  /** column name */
  LayerDetail = 'layer_detail',
  /** column name */
  Library = 'library',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Logo = 'logo',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MarketVerified = 'market_verified',
  /** column name */
  Medium = 'medium',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  Reddit = 'reddit',
  /** column name */
  SearchCount = 'search_count',
  /** column name */
  Sentiment = 'sentiment',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusTags = 'status_tags',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamEnrichmentStatus = 'team_enrichment_status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  TotalEmployees = 'total_employees',
  /** column name */
  TotalValuation = 'total_valuation',
  /** column name */
  Trajectory = 'trajectory',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VelocityLinkedin = 'velocity_linkedin',
  /** column name */
  VelocityToken = 'velocity_token',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebDomain = 'web_domain',
  /** column name */
  Website = 'website',
  /** column name */
  WhitePaper = 'white_paper',
  /** column name */
  YearFounded = 'year_founded',
  /** column name */
  Youtube = 'youtube'
}

export type Companies_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Companies_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Companies_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Companies_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Companies_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Companies_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Companies_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Companies_Set_Input>;
  /** filter the rows which have to be updated */
  where: Companies_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Companies_Var_Pop_Fields = {
  __typename?: 'companies_var_pop_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Companies_Var_Samp_Fields = {
  __typename?: 'companies_var_samp_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Companies_Variance_Fields = {
  __typename?: 'companies_variance_fields';
  coin_id: Maybe<Scalars['Float']>;
  company_size: Maybe<Scalars['Float']>;
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investor_amount: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  search_count: Maybe<Scalars['Float']>;
  total_employees: Maybe<Scalars['Float']>;
  trajectory: Maybe<Scalars['Float']>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "data_actions" */
export type Data_Actions = {
  __typename?: 'data_actions';
  created_at: Scalars['timestamptz'];
  name: Scalars['String'];
  owner_value: Scalars['Int'];
  partner_value: Scalars['Int'];
  user_value: Scalars['Int'];
};

/** aggregated selection of "data_actions" */
export type Data_Actions_Aggregate = {
  __typename?: 'data_actions_aggregate';
  aggregate: Maybe<Data_Actions_Aggregate_Fields>;
  nodes: Array<Data_Actions>;
};

/** aggregate fields of "data_actions" */
export type Data_Actions_Aggregate_Fields = {
  __typename?: 'data_actions_aggregate_fields';
  avg: Maybe<Data_Actions_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Actions_Max_Fields>;
  min: Maybe<Data_Actions_Min_Fields>;
  stddev: Maybe<Data_Actions_Stddev_Fields>;
  stddev_pop: Maybe<Data_Actions_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Actions_Stddev_Samp_Fields>;
  sum: Maybe<Data_Actions_Sum_Fields>;
  var_pop: Maybe<Data_Actions_Var_Pop_Fields>;
  var_samp: Maybe<Data_Actions_Var_Samp_Fields>;
  variance: Maybe<Data_Actions_Variance_Fields>;
};


/** aggregate fields of "data_actions" */
export type Data_Actions_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Actions_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Data_Actions_Avg_Fields = {
  __typename?: 'data_actions_avg_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_actions". All fields are combined with a logical 'AND'. */
export type Data_Actions_Bool_Exp = {
  _and: InputMaybe<Array<Data_Actions_Bool_Exp>>;
  _not: InputMaybe<Data_Actions_Bool_Exp>;
  _or: InputMaybe<Array<Data_Actions_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  owner_value: InputMaybe<Int_Comparison_Exp>;
  partner_value: InputMaybe<Int_Comparison_Exp>;
  user_value: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_actions" */
export enum Data_Actions_Constraint {
  /** unique or primary key constraint on columns "name" */
  DataActionsPkey = 'data_actions_pkey'
}

/** input type for incrementing numeric columns in table "data_actions" */
export type Data_Actions_Inc_Input = {
  owner_value: InputMaybe<Scalars['Int']>;
  partner_value: InputMaybe<Scalars['Int']>;
  user_value: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "data_actions" */
export type Data_Actions_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  name: InputMaybe<Scalars['String']>;
  owner_value: InputMaybe<Scalars['Int']>;
  partner_value: InputMaybe<Scalars['Int']>;
  user_value: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Data_Actions_Max_Fields = {
  __typename?: 'data_actions_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  name: Maybe<Scalars['String']>;
  owner_value: Maybe<Scalars['Int']>;
  partner_value: Maybe<Scalars['Int']>;
  user_value: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Data_Actions_Min_Fields = {
  __typename?: 'data_actions_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  name: Maybe<Scalars['String']>;
  owner_value: Maybe<Scalars['Int']>;
  partner_value: Maybe<Scalars['Int']>;
  user_value: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "data_actions" */
export type Data_Actions_Mutation_Response = {
  __typename?: 'data_actions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Actions>;
};

/** on_conflict condition type for table "data_actions" */
export type Data_Actions_On_Conflict = {
  constraint: Data_Actions_Constraint;
  update_columns: Array<Data_Actions_Update_Column>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};

/** Ordering options when selecting data from "data_actions". */
export type Data_Actions_Order_By = {
  created_at: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  owner_value: InputMaybe<Order_By>;
  partner_value: InputMaybe<Order_By>;
  user_value: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_actions */
export type Data_Actions_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "data_actions" */
export enum Data_Actions_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerValue = 'owner_value',
  /** column name */
  PartnerValue = 'partner_value',
  /** column name */
  UserValue = 'user_value'
}

/** input type for updating data in table "data_actions" */
export type Data_Actions_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  name: InputMaybe<Scalars['String']>;
  owner_value: InputMaybe<Scalars['Int']>;
  partner_value: InputMaybe<Scalars['Int']>;
  user_value: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Data_Actions_Stddev_Fields = {
  __typename?: 'data_actions_stddev_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Actions_Stddev_Pop_Fields = {
  __typename?: 'data_actions_stddev_pop_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Actions_Stddev_Samp_Fields = {
  __typename?: 'data_actions_stddev_samp_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_actions" */
export type Data_Actions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Actions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Actions_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  name: InputMaybe<Scalars['String']>;
  owner_value: InputMaybe<Scalars['Int']>;
  partner_value: InputMaybe<Scalars['Int']>;
  user_value: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Data_Actions_Sum_Fields = {
  __typename?: 'data_actions_sum_fields';
  owner_value: Maybe<Scalars['Int']>;
  partner_value: Maybe<Scalars['Int']>;
  user_value: Maybe<Scalars['Int']>;
};

/** update columns of table "data_actions" */
export enum Data_Actions_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerValue = 'owner_value',
  /** column name */
  PartnerValue = 'partner_value',
  /** column name */
  UserValue = 'user_value'
}

export type Data_Actions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Actions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Actions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Actions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Actions_Var_Pop_Fields = {
  __typename?: 'data_actions_var_pop_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Actions_Var_Samp_Fields = {
  __typename?: 'data_actions_var_samp_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Actions_Variance_Fields = {
  __typename?: 'data_actions_variance_fields';
  owner_value: Maybe<Scalars['Float']>;
  partner_value: Maybe<Scalars['Float']>;
  user_value: Maybe<Scalars['Float']>;
};

/** columns and relationships of "data_discard" */
export type Data_Discard = {
  __typename?: 'data_discard';
  accuracy_weight: Scalars['Int'];
  created_at: Scalars['timestamp'];
  field: Scalars['String'];
  id: Scalars['bigint'];
  partner: Scalars['Int'];
  resource: Scalars['String'];
  resource_id: Scalars['Int'];
  value: Scalars['jsonb'];
};


/** columns and relationships of "data_discard" */
export type Data_DiscardValueArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "data_discard" */
export type Data_Discard_Aggregate = {
  __typename?: 'data_discard_aggregate';
  aggregate: Maybe<Data_Discard_Aggregate_Fields>;
  nodes: Array<Data_Discard>;
};

/** aggregate fields of "data_discard" */
export type Data_Discard_Aggregate_Fields = {
  __typename?: 'data_discard_aggregate_fields';
  avg: Maybe<Data_Discard_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Discard_Max_Fields>;
  min: Maybe<Data_Discard_Min_Fields>;
  stddev: Maybe<Data_Discard_Stddev_Fields>;
  stddev_pop: Maybe<Data_Discard_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Discard_Stddev_Samp_Fields>;
  sum: Maybe<Data_Discard_Sum_Fields>;
  var_pop: Maybe<Data_Discard_Var_Pop_Fields>;
  var_samp: Maybe<Data_Discard_Var_Samp_Fields>;
  variance: Maybe<Data_Discard_Variance_Fields>;
};


/** aggregate fields of "data_discard" */
export type Data_Discard_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Discard_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Data_Discard_Append_Input = {
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Data_Discard_Avg_Fields = {
  __typename?: 'data_discard_avg_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_discard". All fields are combined with a logical 'AND'. */
export type Data_Discard_Bool_Exp = {
  _and: InputMaybe<Array<Data_Discard_Bool_Exp>>;
  _not: InputMaybe<Data_Discard_Bool_Exp>;
  _or: InputMaybe<Array<Data_Discard_Bool_Exp>>;
  accuracy_weight: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamp_Comparison_Exp>;
  field: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Bigint_Comparison_Exp>;
  partner: InputMaybe<Int_Comparison_Exp>;
  resource: InputMaybe<String_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  value: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_discard" */
export enum Data_Discard_Constraint {
  /** unique or primary key constraint on columns "id" */
  DataDiscardPkey = 'data_discard_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Data_Discard_Delete_At_Path_Input = {
  value: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Data_Discard_Delete_Elem_Input = {
  value: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Data_Discard_Delete_Key_Input = {
  value: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "data_discard" */
export type Data_Discard_Inc_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  partner: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "data_discard" */
export type Data_Discard_Insert_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Data_Discard_Max_Fields = {
  __typename?: 'data_discard_max_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  field: Maybe<Scalars['String']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Data_Discard_Min_Fields = {
  __typename?: 'data_discard_min_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  field: Maybe<Scalars['String']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "data_discard" */
export type Data_Discard_Mutation_Response = {
  __typename?: 'data_discard_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Discard>;
};

/** on_conflict condition type for table "data_discard" */
export type Data_Discard_On_Conflict = {
  constraint: Data_Discard_Constraint;
  update_columns: Array<Data_Discard_Update_Column>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};

/** Ordering options when selecting data from "data_discard". */
export type Data_Discard_Order_By = {
  accuracy_weight: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  field: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  partner: InputMaybe<Order_By>;
  resource: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_discard */
export type Data_Discard_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Data_Discard_Prepend_Input = {
  value: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "data_discard" */
export enum Data_Discard_Select_Column {
  /** column name */
  AccuracyWeight = 'accuracy_weight',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Field = 'field',
  /** column name */
  Id = 'id',
  /** column name */
  Partner = 'partner',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "data_discard" */
export type Data_Discard_Set_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate stddev on columns */
export type Data_Discard_Stddev_Fields = {
  __typename?: 'data_discard_stddev_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Discard_Stddev_Pop_Fields = {
  __typename?: 'data_discard_stddev_pop_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Discard_Stddev_Samp_Fields = {
  __typename?: 'data_discard_stddev_samp_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_discard" */
export type Data_Discard_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Discard_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Discard_Stream_Cursor_Value_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate sum on columns */
export type Data_Discard_Sum_Fields = {
  __typename?: 'data_discard_sum_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** update columns of table "data_discard" */
export enum Data_Discard_Update_Column {
  /** column name */
  AccuracyWeight = 'accuracy_weight',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Field = 'field',
  /** column name */
  Id = 'id',
  /** column name */
  Partner = 'partner',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  Value = 'value'
}

export type Data_Discard_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Data_Discard_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Data_Discard_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Data_Discard_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Data_Discard_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Discard_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Data_Discard_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Discard_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Discard_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Discard_Var_Pop_Fields = {
  __typename?: 'data_discard_var_pop_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Discard_Var_Samp_Fields = {
  __typename?: 'data_discard_var_samp_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Discard_Variance_Fields = {
  __typename?: 'data_discard_variance_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "data_fields" */
export type Data_Fields = {
  __typename?: 'data_fields';
  created_at: Scalars['timestamptz'];
  data_type: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  is_valid_identifier: Scalars['Boolean'];
  name: Scalars['String'];
  path: Scalars['String'];
  regex_test: Maybe<Scalars['String']>;
  regex_transform: Maybe<Scalars['String']>;
  resource: Scalars['String'];
  restricted_admin: Scalars['Boolean'];
  weight: Scalars['Int'];
};

/** aggregated selection of "data_fields" */
export type Data_Fields_Aggregate = {
  __typename?: 'data_fields_aggregate';
  aggregate: Maybe<Data_Fields_Aggregate_Fields>;
  nodes: Array<Data_Fields>;
};

/** aggregate fields of "data_fields" */
export type Data_Fields_Aggregate_Fields = {
  __typename?: 'data_fields_aggregate_fields';
  avg: Maybe<Data_Fields_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Fields_Max_Fields>;
  min: Maybe<Data_Fields_Min_Fields>;
  stddev: Maybe<Data_Fields_Stddev_Fields>;
  stddev_pop: Maybe<Data_Fields_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Fields_Stddev_Samp_Fields>;
  sum: Maybe<Data_Fields_Sum_Fields>;
  var_pop: Maybe<Data_Fields_Var_Pop_Fields>;
  var_samp: Maybe<Data_Fields_Var_Samp_Fields>;
  variance: Maybe<Data_Fields_Variance_Fields>;
};


/** aggregate fields of "data_fields" */
export type Data_Fields_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Fields_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Data_Fields_Avg_Fields = {
  __typename?: 'data_fields_avg_fields';
  weight: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_fields". All fields are combined with a logical 'AND'. */
export type Data_Fields_Bool_Exp = {
  _and: InputMaybe<Array<Data_Fields_Bool_Exp>>;
  _not: InputMaybe<Data_Fields_Bool_Exp>;
  _or: InputMaybe<Array<Data_Fields_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_type: InputMaybe<String_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  is_valid_identifier: InputMaybe<Boolean_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  path: InputMaybe<String_Comparison_Exp>;
  regex_test: InputMaybe<String_Comparison_Exp>;
  regex_transform: InputMaybe<String_Comparison_Exp>;
  resource: InputMaybe<String_Comparison_Exp>;
  restricted_admin: InputMaybe<Boolean_Comparison_Exp>;
  weight: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_fields" */
export enum Data_Fields_Constraint {
  /** unique or primary key constraint on columns "path" */
  DataFieldsPkey = 'data_fields_pkey'
}

/** input type for incrementing numeric columns in table "data_fields" */
export type Data_Fields_Inc_Input = {
  weight: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "data_fields" */
export type Data_Fields_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_type: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  is_valid_identifier: InputMaybe<Scalars['Boolean']>;
  name: InputMaybe<Scalars['String']>;
  path: InputMaybe<Scalars['String']>;
  regex_test: InputMaybe<Scalars['String']>;
  regex_transform: InputMaybe<Scalars['String']>;
  resource: InputMaybe<Scalars['String']>;
  restricted_admin: InputMaybe<Scalars['Boolean']>;
  weight: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Data_Fields_Max_Fields = {
  __typename?: 'data_fields_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  data_type: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  path: Maybe<Scalars['String']>;
  regex_test: Maybe<Scalars['String']>;
  regex_transform: Maybe<Scalars['String']>;
  resource: Maybe<Scalars['String']>;
  weight: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Data_Fields_Min_Fields = {
  __typename?: 'data_fields_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  data_type: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  path: Maybe<Scalars['String']>;
  regex_test: Maybe<Scalars['String']>;
  regex_transform: Maybe<Scalars['String']>;
  resource: Maybe<Scalars['String']>;
  weight: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "data_fields" */
export type Data_Fields_Mutation_Response = {
  __typename?: 'data_fields_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Fields>;
};

/** on_conflict condition type for table "data_fields" */
export type Data_Fields_On_Conflict = {
  constraint: Data_Fields_Constraint;
  update_columns: Array<Data_Fields_Update_Column>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};

/** Ordering options when selecting data from "data_fields". */
export type Data_Fields_Order_By = {
  created_at: InputMaybe<Order_By>;
  data_type: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  is_valid_identifier: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  path: InputMaybe<Order_By>;
  regex_test: InputMaybe<Order_By>;
  regex_transform: InputMaybe<Order_By>;
  resource: InputMaybe<Order_By>;
  restricted_admin: InputMaybe<Order_By>;
  weight: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_fields */
export type Data_Fields_Pk_Columns_Input = {
  path: Scalars['String'];
};

/** select columns of table "data_fields" */
export enum Data_Fields_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  Description = 'description',
  /** column name */
  IsValidIdentifier = 'is_valid_identifier',
  /** column name */
  Name = 'name',
  /** column name */
  Path = 'path',
  /** column name */
  RegexTest = 'regex_test',
  /** column name */
  RegexTransform = 'regex_transform',
  /** column name */
  Resource = 'resource',
  /** column name */
  RestrictedAdmin = 'restricted_admin',
  /** column name */
  Weight = 'weight'
}

/** input type for updating data in table "data_fields" */
export type Data_Fields_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_type: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  is_valid_identifier: InputMaybe<Scalars['Boolean']>;
  name: InputMaybe<Scalars['String']>;
  path: InputMaybe<Scalars['String']>;
  regex_test: InputMaybe<Scalars['String']>;
  regex_transform: InputMaybe<Scalars['String']>;
  resource: InputMaybe<Scalars['String']>;
  restricted_admin: InputMaybe<Scalars['Boolean']>;
  weight: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Data_Fields_Stddev_Fields = {
  __typename?: 'data_fields_stddev_fields';
  weight: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Fields_Stddev_Pop_Fields = {
  __typename?: 'data_fields_stddev_pop_fields';
  weight: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Fields_Stddev_Samp_Fields = {
  __typename?: 'data_fields_stddev_samp_fields';
  weight: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_fields" */
export type Data_Fields_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Fields_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Fields_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_type: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  is_valid_identifier: InputMaybe<Scalars['Boolean']>;
  name: InputMaybe<Scalars['String']>;
  path: InputMaybe<Scalars['String']>;
  regex_test: InputMaybe<Scalars['String']>;
  regex_transform: InputMaybe<Scalars['String']>;
  resource: InputMaybe<Scalars['String']>;
  restricted_admin: InputMaybe<Scalars['Boolean']>;
  weight: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Data_Fields_Sum_Fields = {
  __typename?: 'data_fields_sum_fields';
  weight: Maybe<Scalars['Int']>;
};

/** update columns of table "data_fields" */
export enum Data_Fields_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataType = 'data_type',
  /** column name */
  Description = 'description',
  /** column name */
  IsValidIdentifier = 'is_valid_identifier',
  /** column name */
  Name = 'name',
  /** column name */
  Path = 'path',
  /** column name */
  RegexTest = 'regex_test',
  /** column name */
  RegexTransform = 'regex_transform',
  /** column name */
  Resource = 'resource',
  /** column name */
  RestrictedAdmin = 'restricted_admin',
  /** column name */
  Weight = 'weight'
}

export type Data_Fields_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Fields_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Fields_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Fields_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Fields_Var_Pop_Fields = {
  __typename?: 'data_fields_var_pop_fields';
  weight: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Fields_Var_Samp_Fields = {
  __typename?: 'data_fields_var_samp_fields';
  weight: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Fields_Variance_Fields = {
  __typename?: 'data_fields_variance_fields';
  weight: Maybe<Scalars['Float']>;
};

/** columns and relationships of "data_partners" */
export type Data_Partners = {
  __typename?: 'data_partners';
  api_key: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** aggregated selection of "data_partners" */
export type Data_Partners_Aggregate = {
  __typename?: 'data_partners_aggregate';
  aggregate: Maybe<Data_Partners_Aggregate_Fields>;
  nodes: Array<Data_Partners>;
};

/** aggregate fields of "data_partners" */
export type Data_Partners_Aggregate_Fields = {
  __typename?: 'data_partners_aggregate_fields';
  avg: Maybe<Data_Partners_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Partners_Max_Fields>;
  min: Maybe<Data_Partners_Min_Fields>;
  stddev: Maybe<Data_Partners_Stddev_Fields>;
  stddev_pop: Maybe<Data_Partners_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Partners_Stddev_Samp_Fields>;
  sum: Maybe<Data_Partners_Sum_Fields>;
  var_pop: Maybe<Data_Partners_Var_Pop_Fields>;
  var_samp: Maybe<Data_Partners_Var_Samp_Fields>;
  variance: Maybe<Data_Partners_Variance_Fields>;
};


/** aggregate fields of "data_partners" */
export type Data_Partners_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Partners_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Data_Partners_Avg_Fields = {
  __typename?: 'data_partners_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_partners". All fields are combined with a logical 'AND'. */
export type Data_Partners_Bool_Exp = {
  _and: InputMaybe<Array<Data_Partners_Bool_Exp>>;
  _not: InputMaybe<Data_Partners_Bool_Exp>;
  _or: InputMaybe<Array<Data_Partners_Bool_Exp>>;
  api_key: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_partners" */
export enum Data_Partners_Constraint {
  /** unique or primary key constraint on columns "id" */
  DataPartnersPkey = 'data_partners_pkey'
}

/** input type for incrementing numeric columns in table "data_partners" */
export type Data_Partners_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "data_partners" */
export type Data_Partners_Insert_Input = {
  api_key: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Data_Partners_Max_Fields = {
  __typename?: 'data_partners_max_fields';
  api_key: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Data_Partners_Min_Fields = {
  __typename?: 'data_partners_min_fields';
  api_key: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "data_partners" */
export type Data_Partners_Mutation_Response = {
  __typename?: 'data_partners_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Partners>;
};

/** on_conflict condition type for table "data_partners" */
export type Data_Partners_On_Conflict = {
  constraint: Data_Partners_Constraint;
  update_columns: Array<Data_Partners_Update_Column>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};

/** Ordering options when selecting data from "data_partners". */
export type Data_Partners_Order_By = {
  api_key: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_partners */
export type Data_Partners_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "data_partners" */
export enum Data_Partners_Select_Column {
  /** column name */
  ApiKey = 'api_key',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "data_partners" */
export type Data_Partners_Set_Input = {
  api_key: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Data_Partners_Stddev_Fields = {
  __typename?: 'data_partners_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Partners_Stddev_Pop_Fields = {
  __typename?: 'data_partners_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Partners_Stddev_Samp_Fields = {
  __typename?: 'data_partners_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_partners" */
export type Data_Partners_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Partners_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Partners_Stream_Cursor_Value_Input = {
  api_key: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Data_Partners_Sum_Fields = {
  __typename?: 'data_partners_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "data_partners" */
export enum Data_Partners_Update_Column {
  /** column name */
  ApiKey = 'api_key',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Data_Partners_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Partners_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Partners_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Partners_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Partners_Var_Pop_Fields = {
  __typename?: 'data_partners_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Partners_Var_Samp_Fields = {
  __typename?: 'data_partners_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Partners_Variance_Fields = {
  __typename?: 'data_partners_variance_fields';
  id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "data_raw" */
export type Data_Raw = {
  __typename?: 'data_raw';
  accuracy_weight: Scalars['Int'];
  created_at: Scalars['timestamp'];
  field: Scalars['String'];
  id: Scalars['bigint'];
  is_active: Scalars['Boolean'];
  partner: Scalars['Int'];
  resource: Scalars['String'];
  resource_id: Scalars['Int'];
  user_id: Maybe<Scalars['Int']>;
  value: Scalars['jsonb'];
};


/** columns and relationships of "data_raw" */
export type Data_RawValueArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "data_raw" */
export type Data_Raw_Aggregate = {
  __typename?: 'data_raw_aggregate';
  aggregate: Maybe<Data_Raw_Aggregate_Fields>;
  nodes: Array<Data_Raw>;
};

/** aggregate fields of "data_raw" */
export type Data_Raw_Aggregate_Fields = {
  __typename?: 'data_raw_aggregate_fields';
  avg: Maybe<Data_Raw_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Raw_Max_Fields>;
  min: Maybe<Data_Raw_Min_Fields>;
  stddev: Maybe<Data_Raw_Stddev_Fields>;
  stddev_pop: Maybe<Data_Raw_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Raw_Stddev_Samp_Fields>;
  sum: Maybe<Data_Raw_Sum_Fields>;
  var_pop: Maybe<Data_Raw_Var_Pop_Fields>;
  var_samp: Maybe<Data_Raw_Var_Samp_Fields>;
  variance: Maybe<Data_Raw_Variance_Fields>;
};


/** aggregate fields of "data_raw" */
export type Data_Raw_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Raw_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Data_Raw_Append_Input = {
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Data_Raw_Avg_Fields = {
  __typename?: 'data_raw_avg_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_raw". All fields are combined with a logical 'AND'. */
export type Data_Raw_Bool_Exp = {
  _and: InputMaybe<Array<Data_Raw_Bool_Exp>>;
  _not: InputMaybe<Data_Raw_Bool_Exp>;
  _or: InputMaybe<Array<Data_Raw_Bool_Exp>>;
  accuracy_weight: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamp_Comparison_Exp>;
  field: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Bigint_Comparison_Exp>;
  is_active: InputMaybe<Boolean_Comparison_Exp>;
  partner: InputMaybe<Int_Comparison_Exp>;
  resource: InputMaybe<String_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
  value: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_raw" */
export enum Data_Raw_Constraint {
  /** unique or primary key constraint on columns "id" */
  DataRawPkey = 'data_raw_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Data_Raw_Delete_At_Path_Input = {
  value: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Data_Raw_Delete_Elem_Input = {
  value: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Data_Raw_Delete_Key_Input = {
  value: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "data_raw" */
export type Data_Raw_Inc_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  partner: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "data_raw" */
export type Data_Raw_Insert_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  is_active: InputMaybe<Scalars['Boolean']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Data_Raw_Max_Fields = {
  __typename?: 'data_raw_max_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  field: Maybe<Scalars['String']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Data_Raw_Min_Fields = {
  __typename?: 'data_raw_min_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  field: Maybe<Scalars['String']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "data_raw" */
export type Data_Raw_Mutation_Response = {
  __typename?: 'data_raw_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Raw>;
};

/** on_conflict condition type for table "data_raw" */
export type Data_Raw_On_Conflict = {
  constraint: Data_Raw_Constraint;
  update_columns: Array<Data_Raw_Update_Column>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};

/** Ordering options when selecting data from "data_raw". */
export type Data_Raw_Order_By = {
  accuracy_weight: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  field: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  is_active: InputMaybe<Order_By>;
  partner: InputMaybe<Order_By>;
  resource: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_raw */
export type Data_Raw_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Data_Raw_Prepend_Input = {
  value: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "data_raw" */
export enum Data_Raw_Select_Column {
  /** column name */
  AccuracyWeight = 'accuracy_weight',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Field = 'field',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Partner = 'partner',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "data_raw" */
export type Data_Raw_Set_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  is_active: InputMaybe<Scalars['Boolean']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate stddev on columns */
export type Data_Raw_Stddev_Fields = {
  __typename?: 'data_raw_stddev_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Raw_Stddev_Pop_Fields = {
  __typename?: 'data_raw_stddev_pop_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Raw_Stddev_Samp_Fields = {
  __typename?: 'data_raw_stddev_samp_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_raw" */
export type Data_Raw_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Raw_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Raw_Stream_Cursor_Value_Input = {
  accuracy_weight: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  field: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['bigint']>;
  is_active: InputMaybe<Scalars['Boolean']>;
  partner: InputMaybe<Scalars['Int']>;
  resource: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
  value: InputMaybe<Scalars['jsonb']>;
};

/** aggregate sum on columns */
export type Data_Raw_Sum_Fields = {
  __typename?: 'data_raw_sum_fields';
  accuracy_weight: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['bigint']>;
  partner: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "data_raw" */
export enum Data_Raw_Update_Column {
  /** column name */
  AccuracyWeight = 'accuracy_weight',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Field = 'field',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Partner = 'partner',
  /** column name */
  Resource = 'resource',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Value = 'value'
}

export type Data_Raw_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Data_Raw_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Data_Raw_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Data_Raw_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Data_Raw_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Raw_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Data_Raw_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Raw_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Raw_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Raw_Var_Pop_Fields = {
  __typename?: 'data_raw_var_pop_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Raw_Var_Samp_Fields = {
  __typename?: 'data_raw_var_samp_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Raw_Variance_Fields = {
  __typename?: 'data_raw_variance_fields';
  accuracy_weight: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  partner: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "data_runs" */
export type Data_Runs = {
  __typename?: 'data_runs';
  ambiguity_score: Maybe<Scalars['float8']>;
  classification: Scalars['String'];
  created_at: Scalars['timestamptz'];
  data_raw: Scalars['Int'];
  id: Scalars['bigint'];
  max_weight: Maybe<Scalars['Int']>;
  run_at: Scalars['timestamptz'];
  weight: Scalars['Int'];
  weight_normalized: Scalars['float8'];
};

/** aggregated selection of "data_runs" */
export type Data_Runs_Aggregate = {
  __typename?: 'data_runs_aggregate';
  aggregate: Maybe<Data_Runs_Aggregate_Fields>;
  nodes: Array<Data_Runs>;
};

/** aggregate fields of "data_runs" */
export type Data_Runs_Aggregate_Fields = {
  __typename?: 'data_runs_aggregate_fields';
  avg: Maybe<Data_Runs_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Data_Runs_Max_Fields>;
  min: Maybe<Data_Runs_Min_Fields>;
  stddev: Maybe<Data_Runs_Stddev_Fields>;
  stddev_pop: Maybe<Data_Runs_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Data_Runs_Stddev_Samp_Fields>;
  sum: Maybe<Data_Runs_Sum_Fields>;
  var_pop: Maybe<Data_Runs_Var_Pop_Fields>;
  var_samp: Maybe<Data_Runs_Var_Samp_Fields>;
  variance: Maybe<Data_Runs_Variance_Fields>;
};


/** aggregate fields of "data_runs" */
export type Data_Runs_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Data_Runs_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Data_Runs_Avg_Fields = {
  __typename?: 'data_runs_avg_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "data_runs". All fields are combined with a logical 'AND'. */
export type Data_Runs_Bool_Exp = {
  _and: InputMaybe<Array<Data_Runs_Bool_Exp>>;
  _not: InputMaybe<Data_Runs_Bool_Exp>;
  _or: InputMaybe<Array<Data_Runs_Bool_Exp>>;
  ambiguity_score: InputMaybe<Float8_Comparison_Exp>;
  classification: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_raw: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Bigint_Comparison_Exp>;
  max_weight: InputMaybe<Int_Comparison_Exp>;
  run_at: InputMaybe<Timestamptz_Comparison_Exp>;
  weight: InputMaybe<Int_Comparison_Exp>;
  weight_normalized: InputMaybe<Float8_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_runs" */
export enum Data_Runs_Constraint {
  /** unique or primary key constraint on columns "id" */
  DataRunsPkey = 'data_runs_pkey'
}

/** input type for incrementing numeric columns in table "data_runs" */
export type Data_Runs_Inc_Input = {
  ambiguity_score: InputMaybe<Scalars['float8']>;
  data_raw: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  max_weight: InputMaybe<Scalars['Int']>;
  weight: InputMaybe<Scalars['Int']>;
  weight_normalized: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "data_runs" */
export type Data_Runs_Insert_Input = {
  ambiguity_score: InputMaybe<Scalars['float8']>;
  classification: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_raw: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  max_weight: InputMaybe<Scalars['Int']>;
  run_at: InputMaybe<Scalars['timestamptz']>;
  weight: InputMaybe<Scalars['Int']>;
  weight_normalized: InputMaybe<Scalars['float8']>;
};

/** aggregate max on columns */
export type Data_Runs_Max_Fields = {
  __typename?: 'data_runs_max_fields';
  ambiguity_score: Maybe<Scalars['float8']>;
  classification: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_raw: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['bigint']>;
  max_weight: Maybe<Scalars['Int']>;
  run_at: Maybe<Scalars['timestamptz']>;
  weight: Maybe<Scalars['Int']>;
  weight_normalized: Maybe<Scalars['float8']>;
};

/** aggregate min on columns */
export type Data_Runs_Min_Fields = {
  __typename?: 'data_runs_min_fields';
  ambiguity_score: Maybe<Scalars['float8']>;
  classification: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_raw: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['bigint']>;
  max_weight: Maybe<Scalars['Int']>;
  run_at: Maybe<Scalars['timestamptz']>;
  weight: Maybe<Scalars['Int']>;
  weight_normalized: Maybe<Scalars['float8']>;
};

/** response of any mutation on the table "data_runs" */
export type Data_Runs_Mutation_Response = {
  __typename?: 'data_runs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Runs>;
};

/** on_conflict condition type for table "data_runs" */
export type Data_Runs_On_Conflict = {
  constraint: Data_Runs_Constraint;
  update_columns: Array<Data_Runs_Update_Column>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};

/** Ordering options when selecting data from "data_runs". */
export type Data_Runs_Order_By = {
  ambiguity_score: InputMaybe<Order_By>;
  classification: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_raw: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  max_weight: InputMaybe<Order_By>;
  run_at: InputMaybe<Order_By>;
  weight: InputMaybe<Order_By>;
  weight_normalized: InputMaybe<Order_By>;
};

/** primary key columns input for table: data_runs */
export type Data_Runs_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "data_runs" */
export enum Data_Runs_Select_Column {
  /** column name */
  AmbiguityScore = 'ambiguity_score',
  /** column name */
  Classification = 'classification',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataRaw = 'data_raw',
  /** column name */
  Id = 'id',
  /** column name */
  MaxWeight = 'max_weight',
  /** column name */
  RunAt = 'run_at',
  /** column name */
  Weight = 'weight',
  /** column name */
  WeightNormalized = 'weight_normalized'
}

/** input type for updating data in table "data_runs" */
export type Data_Runs_Set_Input = {
  ambiguity_score: InputMaybe<Scalars['float8']>;
  classification: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_raw: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  max_weight: InputMaybe<Scalars['Int']>;
  run_at: InputMaybe<Scalars['timestamptz']>;
  weight: InputMaybe<Scalars['Int']>;
  weight_normalized: InputMaybe<Scalars['float8']>;
};

/** aggregate stddev on columns */
export type Data_Runs_Stddev_Fields = {
  __typename?: 'data_runs_stddev_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Data_Runs_Stddev_Pop_Fields = {
  __typename?: 'data_runs_stddev_pop_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Data_Runs_Stddev_Samp_Fields = {
  __typename?: 'data_runs_stddev_samp_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "data_runs" */
export type Data_Runs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Runs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Runs_Stream_Cursor_Value_Input = {
  ambiguity_score: InputMaybe<Scalars['float8']>;
  classification: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_raw: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['bigint']>;
  max_weight: InputMaybe<Scalars['Int']>;
  run_at: InputMaybe<Scalars['timestamptz']>;
  weight: InputMaybe<Scalars['Int']>;
  weight_normalized: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type Data_Runs_Sum_Fields = {
  __typename?: 'data_runs_sum_fields';
  ambiguity_score: Maybe<Scalars['float8']>;
  data_raw: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['bigint']>;
  max_weight: Maybe<Scalars['Int']>;
  weight: Maybe<Scalars['Int']>;
  weight_normalized: Maybe<Scalars['float8']>;
};

/** update columns of table "data_runs" */
export enum Data_Runs_Update_Column {
  /** column name */
  AmbiguityScore = 'ambiguity_score',
  /** column name */
  Classification = 'classification',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataRaw = 'data_raw',
  /** column name */
  Id = 'id',
  /** column name */
  MaxWeight = 'max_weight',
  /** column name */
  RunAt = 'run_at',
  /** column name */
  Weight = 'weight',
  /** column name */
  WeightNormalized = 'weight_normalized'
}

export type Data_Runs_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Data_Runs_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Data_Runs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Runs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Data_Runs_Var_Pop_Fields = {
  __typename?: 'data_runs_var_pop_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Data_Runs_Var_Samp_Fields = {
  __typename?: 'data_runs_var_samp_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Data_Runs_Variance_Fields = {
  __typename?: 'data_runs_variance_fields';
  ambiguity_score: Maybe<Scalars['Float']>;
  data_raw: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  max_weight: Maybe<Scalars['Float']>;
  weight: Maybe<Scalars['Float']>;
  weight_normalized: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq: InputMaybe<Scalars['date']>;
  _gt: InputMaybe<Scalars['date']>;
  _gte: InputMaybe<Scalars['date']>;
  _in: InputMaybe<Array<Scalars['date']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['date']>;
  _lte: InputMaybe<Scalars['date']>;
  _neq: InputMaybe<Scalars['date']>;
  _nin: InputMaybe<Array<Scalars['date']>>;
};

/** columns and relationships of "disabled_emails" */
export type Disabled_Emails = {
  __typename?: 'disabled_emails';
  created_at: Scalars['timestamptz'];
  email: Scalars['String'];
  id: Scalars['Int'];
  match_type: Scalars['String'];
};

/** aggregated selection of "disabled_emails" */
export type Disabled_Emails_Aggregate = {
  __typename?: 'disabled_emails_aggregate';
  aggregate: Maybe<Disabled_Emails_Aggregate_Fields>;
  nodes: Array<Disabled_Emails>;
};

/** aggregate fields of "disabled_emails" */
export type Disabled_Emails_Aggregate_Fields = {
  __typename?: 'disabled_emails_aggregate_fields';
  avg: Maybe<Disabled_Emails_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Disabled_Emails_Max_Fields>;
  min: Maybe<Disabled_Emails_Min_Fields>;
  stddev: Maybe<Disabled_Emails_Stddev_Fields>;
  stddev_pop: Maybe<Disabled_Emails_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Disabled_Emails_Stddev_Samp_Fields>;
  sum: Maybe<Disabled_Emails_Sum_Fields>;
  var_pop: Maybe<Disabled_Emails_Var_Pop_Fields>;
  var_samp: Maybe<Disabled_Emails_Var_Samp_Fields>;
  variance: Maybe<Disabled_Emails_Variance_Fields>;
};


/** aggregate fields of "disabled_emails" */
export type Disabled_Emails_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Disabled_Emails_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Disabled_Emails_Avg_Fields = {
  __typename?: 'disabled_emails_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "disabled_emails". All fields are combined with a logical 'AND'. */
export type Disabled_Emails_Bool_Exp = {
  _and: InputMaybe<Array<Disabled_Emails_Bool_Exp>>;
  _not: InputMaybe<Disabled_Emails_Bool_Exp>;
  _or: InputMaybe<Array<Disabled_Emails_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  match_type: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "disabled_emails" */
export enum Disabled_Emails_Constraint {
  /** unique or primary key constraint on columns "id" */
  DisabledEmailsPkey = 'disabled_emails_pkey'
}

/** input type for incrementing numeric columns in table "disabled_emails" */
export type Disabled_Emails_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "disabled_emails" */
export type Disabled_Emails_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Disabled_Emails_Max_Fields = {
  __typename?: 'disabled_emails_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  match_type: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Disabled_Emails_Min_Fields = {
  __typename?: 'disabled_emails_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  match_type: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "disabled_emails" */
export type Disabled_Emails_Mutation_Response = {
  __typename?: 'disabled_emails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Disabled_Emails>;
};

/** on_conflict condition type for table "disabled_emails" */
export type Disabled_Emails_On_Conflict = {
  constraint: Disabled_Emails_Constraint;
  update_columns: Array<Disabled_Emails_Update_Column>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};

/** Ordering options when selecting data from "disabled_emails". */
export type Disabled_Emails_Order_By = {
  created_at: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  match_type: InputMaybe<Order_By>;
};

/** primary key columns input for table: disabled_emails */
export type Disabled_Emails_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "disabled_emails" */
export enum Disabled_Emails_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  MatchType = 'match_type'
}

/** input type for updating data in table "disabled_emails" */
export type Disabled_Emails_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Disabled_Emails_Stddev_Fields = {
  __typename?: 'disabled_emails_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Disabled_Emails_Stddev_Pop_Fields = {
  __typename?: 'disabled_emails_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Disabled_Emails_Stddev_Samp_Fields = {
  __typename?: 'disabled_emails_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "disabled_emails" */
export type Disabled_Emails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Disabled_Emails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Disabled_Emails_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  match_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Disabled_Emails_Sum_Fields = {
  __typename?: 'disabled_emails_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "disabled_emails" */
export enum Disabled_Emails_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  MatchType = 'match_type'
}

export type Disabled_Emails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Disabled_Emails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Disabled_Emails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Disabled_Emails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Disabled_Emails_Var_Pop_Fields = {
  __typename?: 'disabled_emails_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Disabled_Emails_Var_Samp_Fields = {
  __typename?: 'disabled_emails_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Disabled_Emails_Variance_Fields = {
  __typename?: 'disabled_emails_variance_fields';
  id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "event_organization" */
export type Event_Organization = {
  __typename?: 'event_organization';
  /** An object relationship */
  company: Maybe<Companies>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  event: Maybe<Events>;
  event_id: Scalars['Int'];
  id: Scalars['Int'];
  sponsor_type: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "event_organization" */
export type Event_Organization_Aggregate = {
  __typename?: 'event_organization_aggregate';
  aggregate: Maybe<Event_Organization_Aggregate_Fields>;
  nodes: Array<Event_Organization>;
};

export type Event_Organization_Aggregate_Bool_Exp = {
  count: InputMaybe<Event_Organization_Aggregate_Bool_Exp_Count>;
};

export type Event_Organization_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Event_Organization_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Event_Organization_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "event_organization" */
export type Event_Organization_Aggregate_Fields = {
  __typename?: 'event_organization_aggregate_fields';
  avg: Maybe<Event_Organization_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Event_Organization_Max_Fields>;
  min: Maybe<Event_Organization_Min_Fields>;
  stddev: Maybe<Event_Organization_Stddev_Fields>;
  stddev_pop: Maybe<Event_Organization_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Event_Organization_Stddev_Samp_Fields>;
  sum: Maybe<Event_Organization_Sum_Fields>;
  var_pop: Maybe<Event_Organization_Var_Pop_Fields>;
  var_samp: Maybe<Event_Organization_Var_Samp_Fields>;
  variance: Maybe<Event_Organization_Variance_Fields>;
};


/** aggregate fields of "event_organization" */
export type Event_Organization_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Event_Organization_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_organization" */
export type Event_Organization_Aggregate_Order_By = {
  avg: InputMaybe<Event_Organization_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Event_Organization_Max_Order_By>;
  min: InputMaybe<Event_Organization_Min_Order_By>;
  stddev: InputMaybe<Event_Organization_Stddev_Order_By>;
  stddev_pop: InputMaybe<Event_Organization_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Event_Organization_Stddev_Samp_Order_By>;
  sum: InputMaybe<Event_Organization_Sum_Order_By>;
  var_pop: InputMaybe<Event_Organization_Var_Pop_Order_By>;
  var_samp: InputMaybe<Event_Organization_Var_Samp_Order_By>;
  variance: InputMaybe<Event_Organization_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "event_organization" */
export type Event_Organization_Arr_Rel_Insert_Input = {
  data: Array<Event_Organization_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Event_Organization_On_Conflict>;
};

/** aggregate avg on columns */
export type Event_Organization_Avg_Fields = {
  __typename?: 'event_organization_avg_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_organization" */
export type Event_Organization_Avg_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "event_organization". All fields are combined with a logical 'AND'. */
export type Event_Organization_Bool_Exp = {
  _and: InputMaybe<Array<Event_Organization_Bool_Exp>>;
  _not: InputMaybe<Event_Organization_Bool_Exp>;
  _or: InputMaybe<Array<Event_Organization_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  event: InputMaybe<Events_Bool_Exp>;
  event_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  sponsor_type: InputMaybe<String_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "event_organization" */
export enum Event_Organization_Constraint {
  /** unique or primary key constraint on columns "id" */
  EventOrganizationPkey = 'event_organization_pkey'
}

/** input type for incrementing numeric columns in table "event_organization" */
export type Event_Organization_Inc_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_organization" */
export type Event_Organization_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event: InputMaybe<Events_Obj_Rel_Insert_Input>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  sponsor_type: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Event_Organization_Max_Fields = {
  __typename?: 'event_organization_max_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  sponsor_type: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "event_organization" */
export type Event_Organization_Max_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  sponsor_type: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Event_Organization_Min_Fields = {
  __typename?: 'event_organization_min_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  sponsor_type: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "event_organization" */
export type Event_Organization_Min_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  sponsor_type: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "event_organization" */
export type Event_Organization_Mutation_Response = {
  __typename?: 'event_organization_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Event_Organization>;
};

/** on_conflict condition type for table "event_organization" */
export type Event_Organization_On_Conflict = {
  constraint: Event_Organization_Constraint;
  update_columns: Array<Event_Organization_Update_Column>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};

/** Ordering options when selecting data from "event_organization". */
export type Event_Organization_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  event: InputMaybe<Events_Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  sponsor_type: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: event_organization */
export type Event_Organization_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "event_organization" */
export enum Event_Organization_Select_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'event_id',
  /** column name */
  Id = 'id',
  /** column name */
  SponsorType = 'sponsor_type',
  /** column name */
  Type = 'type',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

/** input type for updating data in table "event_organization" */
export type Event_Organization_Set_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  sponsor_type: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Event_Organization_Stddev_Fields = {
  __typename?: 'event_organization_stddev_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_organization" */
export type Event_Organization_Stddev_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Event_Organization_Stddev_Pop_Fields = {
  __typename?: 'event_organization_stddev_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "event_organization" */
export type Event_Organization_Stddev_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Event_Organization_Stddev_Samp_Fields = {
  __typename?: 'event_organization_stddev_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "event_organization" */
export type Event_Organization_Stddev_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "event_organization" */
export type Event_Organization_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Event_Organization_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Event_Organization_Stream_Cursor_Value_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  sponsor_type: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Event_Organization_Sum_Fields = {
  __typename?: 'event_organization_sum_fields';
  company_id: Maybe<Scalars['Int']>;
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_organization" */
export type Event_Organization_Sum_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** update columns of table "event_organization" */
export enum Event_Organization_Update_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'event_id',
  /** column name */
  Id = 'id',
  /** column name */
  SponsorType = 'sponsor_type',
  /** column name */
  Type = 'type',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

export type Event_Organization_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Event_Organization_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Event_Organization_Set_Input>;
  /** filter the rows which have to be updated */
  where: Event_Organization_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Event_Organization_Var_Pop_Fields = {
  __typename?: 'event_organization_var_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "event_organization" */
export type Event_Organization_Var_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Event_Organization_Var_Samp_Fields = {
  __typename?: 'event_organization_var_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "event_organization" */
export type Event_Organization_Var_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Event_Organization_Variance_Fields = {
  __typename?: 'event_organization_variance_fields';
  company_id: Maybe<Scalars['Float']>;
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_organization" */
export type Event_Organization_Variance_Order_By = {
  company_id: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** columns and relationships of "event_person" */
export type Event_Person = {
  __typename?: 'event_person';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  event: Maybe<Events>;
  event_id: Scalars['Int'];
  id: Scalars['Int'];
  /** An object relationship */
  person: Maybe<People>;
  person_id: Scalars['Int'];
  type: Scalars['String'];
};

/** aggregated selection of "event_person" */
export type Event_Person_Aggregate = {
  __typename?: 'event_person_aggregate';
  aggregate: Maybe<Event_Person_Aggregate_Fields>;
  nodes: Array<Event_Person>;
};

export type Event_Person_Aggregate_Bool_Exp = {
  count: InputMaybe<Event_Person_Aggregate_Bool_Exp_Count>;
};

export type Event_Person_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Event_Person_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Event_Person_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "event_person" */
export type Event_Person_Aggregate_Fields = {
  __typename?: 'event_person_aggregate_fields';
  avg: Maybe<Event_Person_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Event_Person_Max_Fields>;
  min: Maybe<Event_Person_Min_Fields>;
  stddev: Maybe<Event_Person_Stddev_Fields>;
  stddev_pop: Maybe<Event_Person_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Event_Person_Stddev_Samp_Fields>;
  sum: Maybe<Event_Person_Sum_Fields>;
  var_pop: Maybe<Event_Person_Var_Pop_Fields>;
  var_samp: Maybe<Event_Person_Var_Samp_Fields>;
  variance: Maybe<Event_Person_Variance_Fields>;
};


/** aggregate fields of "event_person" */
export type Event_Person_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Event_Person_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "event_person" */
export type Event_Person_Aggregate_Order_By = {
  avg: InputMaybe<Event_Person_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Event_Person_Max_Order_By>;
  min: InputMaybe<Event_Person_Min_Order_By>;
  stddev: InputMaybe<Event_Person_Stddev_Order_By>;
  stddev_pop: InputMaybe<Event_Person_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Event_Person_Stddev_Samp_Order_By>;
  sum: InputMaybe<Event_Person_Sum_Order_By>;
  var_pop: InputMaybe<Event_Person_Var_Pop_Order_By>;
  var_samp: InputMaybe<Event_Person_Var_Samp_Order_By>;
  variance: InputMaybe<Event_Person_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "event_person" */
export type Event_Person_Arr_Rel_Insert_Input = {
  data: Array<Event_Person_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Event_Person_On_Conflict>;
};

/** aggregate avg on columns */
export type Event_Person_Avg_Fields = {
  __typename?: 'event_person_avg_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "event_person" */
export type Event_Person_Avg_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "event_person". All fields are combined with a logical 'AND'. */
export type Event_Person_Bool_Exp = {
  _and: InputMaybe<Array<Event_Person_Bool_Exp>>;
  _not: InputMaybe<Event_Person_Bool_Exp>;
  _or: InputMaybe<Array<Event_Person_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  event: InputMaybe<Events_Bool_Exp>;
  event_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "event_person" */
export enum Event_Person_Constraint {
  /** unique or primary key constraint on columns "id" */
  EventPersonPkey = 'event_person_pkey'
}

/** input type for incrementing numeric columns in table "event_person" */
export type Event_Person_Inc_Input = {
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "event_person" */
export type Event_Person_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  event: InputMaybe<Events_Obj_Rel_Insert_Input>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Event_Person_Max_Fields = {
  __typename?: 'event_person_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "event_person" */
export type Event_Person_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Event_Person_Min_Fields = {
  __typename?: 'event_person_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "event_person" */
export type Event_Person_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "event_person" */
export type Event_Person_Mutation_Response = {
  __typename?: 'event_person_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Event_Person>;
};

/** on_conflict condition type for table "event_person" */
export type Event_Person_On_Conflict = {
  constraint: Event_Person_Constraint;
  update_columns: Array<Event_Person_Update_Column>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};

/** Ordering options when selecting data from "event_person". */
export type Event_Person_Order_By = {
  created_at: InputMaybe<Order_By>;
  event: InputMaybe<Events_Order_By>;
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** primary key columns input for table: event_person */
export type Event_Person_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "event_person" */
export enum Event_Person_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'event_id',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "event_person" */
export type Event_Person_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Event_Person_Stddev_Fields = {
  __typename?: 'event_person_stddev_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "event_person" */
export type Event_Person_Stddev_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Event_Person_Stddev_Pop_Fields = {
  __typename?: 'event_person_stddev_pop_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "event_person" */
export type Event_Person_Stddev_Pop_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Event_Person_Stddev_Samp_Fields = {
  __typename?: 'event_person_stddev_samp_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "event_person" */
export type Event_Person_Stddev_Samp_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "event_person" */
export type Event_Person_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Event_Person_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Event_Person_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Event_Person_Sum_Fields = {
  __typename?: 'event_person_sum_fields';
  event_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "event_person" */
export type Event_Person_Sum_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** update columns of table "event_person" */
export enum Event_Person_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'event_id',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Type = 'type'
}

export type Event_Person_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Event_Person_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Event_Person_Set_Input>;
  /** filter the rows which have to be updated */
  where: Event_Person_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Event_Person_Var_Pop_Fields = {
  __typename?: 'event_person_var_pop_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "event_person" */
export type Event_Person_Var_Pop_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Event_Person_Var_Samp_Fields = {
  __typename?: 'event_person_var_samp_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "event_person" */
export type Event_Person_Var_Samp_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Event_Person_Variance_Fields = {
  __typename?: 'event_person_variance_fields';
  event_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "event_person" */
export type Event_Person_Variance_Order_By = {
  event_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** columns and relationships of "events" */
export type Events = {
  __typename?: 'events';
  attachments: Scalars['jsonb'];
  banner: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  discord: Maybe<Scalars['String']>;
  end_date: Maybe<Scalars['date']>;
  end_time: Maybe<Scalars['time']>;
  /** An array relationship */
  event_organization: Array<Event_Organization>;
  /** An aggregate relationship */
  event_organization_aggregate: Event_Organization_Aggregate;
  /** An array relationship */
  event_person: Array<Event_Person>;
  /** An aggregate relationship */
  event_person_aggregate: Event_Person_Aggregate;
  facebook: Maybe<Scalars['String']>;
  geopoint: Maybe<Scalars['geography']>;
  id: Scalars['Int'];
  instagram: Maybe<Scalars['String']>;
  is_featured: Maybe<Scalars['Boolean']>;
  library: Maybe<Scalars['jsonb']>;
  link: Maybe<Scalars['String']>;
  location_json: Maybe<Scalars['jsonb']>;
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  /** An object relationship */
  parent_event: Maybe<Events>;
  parent_event_id: Maybe<Scalars['Int']>;
  price: Maybe<Scalars['numeric']>;
  size: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  start_date: Maybe<Scalars['date']>;
  start_time: Maybe<Scalars['time']>;
  status: Scalars['String'];
  telegram: Maybe<Scalars['String']>;
  timezone: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  types: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
  venue_name: Maybe<Scalars['String']>;
};


/** columns and relationships of "events" */
export type EventsAttachmentsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "events" */
export type EventsBannerArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "events" */
export type EventsEvent_OrganizationArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


/** columns and relationships of "events" */
export type EventsEvent_Organization_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


/** columns and relationships of "events" */
export type EventsEvent_PersonArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


/** columns and relationships of "events" */
export type EventsEvent_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


/** columns and relationships of "events" */
export type EventsLibraryArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "events" */
export type EventsLocation_JsonArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "events" */
export type EventsTypesArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "events" */
export type Events_Aggregate = {
  __typename?: 'events_aggregate';
  aggregate: Maybe<Events_Aggregate_Fields>;
  nodes: Array<Events>;
};

/** aggregate fields of "events" */
export type Events_Aggregate_Fields = {
  __typename?: 'events_aggregate_fields';
  avg: Maybe<Events_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Events_Max_Fields>;
  min: Maybe<Events_Min_Fields>;
  stddev: Maybe<Events_Stddev_Fields>;
  stddev_pop: Maybe<Events_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Events_Stddev_Samp_Fields>;
  sum: Maybe<Events_Sum_Fields>;
  var_pop: Maybe<Events_Var_Pop_Fields>;
  var_samp: Maybe<Events_Var_Samp_Fields>;
  variance: Maybe<Events_Variance_Fields>;
};


/** aggregate fields of "events" */
export type Events_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Events_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Events_Append_Input = {
  attachments: InputMaybe<Scalars['jsonb']>;
  banner: InputMaybe<Scalars['jsonb']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  types: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Events_Avg_Fields = {
  __typename?: 'events_avg_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type Events_Bool_Exp = {
  _and: InputMaybe<Array<Events_Bool_Exp>>;
  _not: InputMaybe<Events_Bool_Exp>;
  _or: InputMaybe<Array<Events_Bool_Exp>>;
  attachments: InputMaybe<Jsonb_Comparison_Exp>;
  banner: InputMaybe<Jsonb_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  discord: InputMaybe<String_Comparison_Exp>;
  end_date: InputMaybe<Date_Comparison_Exp>;
  end_time: InputMaybe<Time_Comparison_Exp>;
  event_organization: InputMaybe<Event_Organization_Bool_Exp>;
  event_organization_aggregate: InputMaybe<Event_Organization_Aggregate_Bool_Exp>;
  event_person: InputMaybe<Event_Person_Bool_Exp>;
  event_person_aggregate: InputMaybe<Event_Person_Aggregate_Bool_Exp>;
  facebook: InputMaybe<String_Comparison_Exp>;
  geopoint: InputMaybe<Geography_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  instagram: InputMaybe<String_Comparison_Exp>;
  is_featured: InputMaybe<Boolean_Comparison_Exp>;
  library: InputMaybe<Jsonb_Comparison_Exp>;
  link: InputMaybe<String_Comparison_Exp>;
  location_json: InputMaybe<Jsonb_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  notes: InputMaybe<String_Comparison_Exp>;
  num_of_views: InputMaybe<Int_Comparison_Exp>;
  overview: InputMaybe<String_Comparison_Exp>;
  parent_event: InputMaybe<Events_Bool_Exp>;
  parent_event_id: InputMaybe<Int_Comparison_Exp>;
  price: InputMaybe<Numeric_Comparison_Exp>;
  size: InputMaybe<String_Comparison_Exp>;
  slug: InputMaybe<String_Comparison_Exp>;
  start_date: InputMaybe<Date_Comparison_Exp>;
  start_time: InputMaybe<Time_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  telegram: InputMaybe<String_Comparison_Exp>;
  timezone: InputMaybe<String_Comparison_Exp>;
  twitter: InputMaybe<String_Comparison_Exp>;
  types: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  venue_name: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "events" */
export enum Events_Constraint {
  /** unique or primary key constraint on columns "id" */
  EventsPkey = 'events_pkey',
  /** unique or primary key constraint on columns "slug" */
  EventsSlugKey = 'events_slug_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Events_Delete_At_Path_Input = {
  attachments: InputMaybe<Array<Scalars['String']>>;
  banner: InputMaybe<Array<Scalars['String']>>;
  library: InputMaybe<Array<Scalars['String']>>;
  location_json: InputMaybe<Array<Scalars['String']>>;
  types: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Events_Delete_Elem_Input = {
  attachments: InputMaybe<Scalars['Int']>;
  banner: InputMaybe<Scalars['Int']>;
  library: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['Int']>;
  types: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Events_Delete_Key_Input = {
  attachments: InputMaybe<Scalars['String']>;
  banner: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['String']>;
  types: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "events" */
export type Events_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  parent_event_id: InputMaybe<Scalars['Int']>;
  price: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "events" */
export type Events_Insert_Input = {
  attachments: InputMaybe<Scalars['jsonb']>;
  banner: InputMaybe<Scalars['jsonb']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  discord: InputMaybe<Scalars['String']>;
  end_date: InputMaybe<Scalars['date']>;
  end_time: InputMaybe<Scalars['time']>;
  event_organization: InputMaybe<Event_Organization_Arr_Rel_Insert_Input>;
  event_person: InputMaybe<Event_Person_Arr_Rel_Insert_Input>;
  facebook: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  is_featured: InputMaybe<Scalars['Boolean']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  parent_event: InputMaybe<Events_Obj_Rel_Insert_Input>;
  parent_event_id: InputMaybe<Scalars['Int']>;
  price: InputMaybe<Scalars['numeric']>;
  size: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  start_time: InputMaybe<Scalars['time']>;
  status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  timezone: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  types: InputMaybe<Scalars['jsonb']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  venue_name: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Events_Max_Fields = {
  __typename?: 'events_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  discord: Maybe<Scalars['String']>;
  end_date: Maybe<Scalars['date']>;
  facebook: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  instagram: Maybe<Scalars['String']>;
  link: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  parent_event_id: Maybe<Scalars['Int']>;
  price: Maybe<Scalars['numeric']>;
  size: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  timezone: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  venue_name: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Events_Min_Fields = {
  __typename?: 'events_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  discord: Maybe<Scalars['String']>;
  end_date: Maybe<Scalars['date']>;
  facebook: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  instagram: Maybe<Scalars['String']>;
  link: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  notes: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  parent_event_id: Maybe<Scalars['Int']>;
  price: Maybe<Scalars['numeric']>;
  size: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  timezone: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  venue_name: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "events" */
export type Events_Mutation_Response = {
  __typename?: 'events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Events>;
};

/** input type for inserting object relation for remote table "events" */
export type Events_Obj_Rel_Insert_Input = {
  data: Events_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Events_On_Conflict>;
};

/** on_conflict condition type for table "events" */
export type Events_On_Conflict = {
  constraint: Events_Constraint;
  update_columns: Array<Events_Update_Column>;
  where: InputMaybe<Events_Bool_Exp>;
};

/** Ordering options when selecting data from "events". */
export type Events_Order_By = {
  attachments: InputMaybe<Order_By>;
  banner: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  discord: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  end_time: InputMaybe<Order_By>;
  event_organization_aggregate: InputMaybe<Event_Organization_Aggregate_Order_By>;
  event_person_aggregate: InputMaybe<Event_Person_Aggregate_Order_By>;
  facebook: InputMaybe<Order_By>;
  geopoint: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  instagram: InputMaybe<Order_By>;
  is_featured: InputMaybe<Order_By>;
  library: InputMaybe<Order_By>;
  link: InputMaybe<Order_By>;
  location_json: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  notes: InputMaybe<Order_By>;
  num_of_views: InputMaybe<Order_By>;
  overview: InputMaybe<Order_By>;
  parent_event: InputMaybe<Events_Order_By>;
  parent_event_id: InputMaybe<Order_By>;
  price: InputMaybe<Order_By>;
  size: InputMaybe<Order_By>;
  slug: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  start_time: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  telegram: InputMaybe<Order_By>;
  timezone: InputMaybe<Order_By>;
  twitter: InputMaybe<Order_By>;
  types: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  venue_name: InputMaybe<Order_By>;
};

/** primary key columns input for table: events */
export type Events_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Events_Prepend_Input = {
  attachments: InputMaybe<Scalars['jsonb']>;
  banner: InputMaybe<Scalars['jsonb']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  types: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "events" */
export enum Events_Select_Column {
  /** column name */
  Attachments = 'attachments',
  /** column name */
  Banner = 'banner',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Discord = 'discord',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  Facebook = 'facebook',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  Instagram = 'instagram',
  /** column name */
  IsFeatured = 'is_featured',
  /** column name */
  Library = 'library',
  /** column name */
  Link = 'link',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  ParentEventId = 'parent_event_id',
  /** column name */
  Price = 'price',
  /** column name */
  Size = 'size',
  /** column name */
  Slug = 'slug',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  StartTime = 'start_time',
  /** column name */
  Status = 'status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  Types = 'types',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VenueName = 'venue_name'
}

/** input type for updating data in table "events" */
export type Events_Set_Input = {
  attachments: InputMaybe<Scalars['jsonb']>;
  banner: InputMaybe<Scalars['jsonb']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  discord: InputMaybe<Scalars['String']>;
  end_date: InputMaybe<Scalars['date']>;
  end_time: InputMaybe<Scalars['time']>;
  facebook: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  is_featured: InputMaybe<Scalars['Boolean']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  parent_event_id: InputMaybe<Scalars['Int']>;
  price: InputMaybe<Scalars['numeric']>;
  size: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  start_time: InputMaybe<Scalars['time']>;
  status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  timezone: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  types: InputMaybe<Scalars['jsonb']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  venue_name: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Events_Stddev_Fields = {
  __typename?: 'events_stddev_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Events_Stddev_Pop_Fields = {
  __typename?: 'events_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Events_Stddev_Samp_Fields = {
  __typename?: 'events_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "events" */
export type Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Events_Stream_Cursor_Value_Input = {
  attachments: InputMaybe<Scalars['jsonb']>;
  banner: InputMaybe<Scalars['jsonb']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  discord: InputMaybe<Scalars['String']>;
  end_date: InputMaybe<Scalars['date']>;
  end_time: InputMaybe<Scalars['time']>;
  facebook: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  instagram: InputMaybe<Scalars['String']>;
  is_featured: InputMaybe<Scalars['Boolean']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Scalars['String']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  parent_event_id: InputMaybe<Scalars['Int']>;
  price: InputMaybe<Scalars['numeric']>;
  size: InputMaybe<Scalars['String']>;
  slug: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  start_time: InputMaybe<Scalars['time']>;
  status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  timezone: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  types: InputMaybe<Scalars['jsonb']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  venue_name: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Events_Sum_Fields = {
  __typename?: 'events_sum_fields';
  id: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
  parent_event_id: Maybe<Scalars['Int']>;
  price: Maybe<Scalars['numeric']>;
};

/** update columns of table "events" */
export enum Events_Update_Column {
  /** column name */
  Attachments = 'attachments',
  /** column name */
  Banner = 'banner',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Discord = 'discord',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  Facebook = 'facebook',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  Instagram = 'instagram',
  /** column name */
  IsFeatured = 'is_featured',
  /** column name */
  Library = 'library',
  /** column name */
  Link = 'link',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  ParentEventId = 'parent_event_id',
  /** column name */
  Price = 'price',
  /** column name */
  Size = 'size',
  /** column name */
  Slug = 'slug',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  StartTime = 'start_time',
  /** column name */
  Status = 'status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  Types = 'types',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VenueName = 'venue_name'
}

export type Events_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Events_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Events_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Events_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Events_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Events_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Events_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Events_Set_Input>;
  /** filter the rows which have to be updated */
  where: Events_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Events_Var_Pop_Fields = {
  __typename?: 'events_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Events_Var_Samp_Fields = {
  __typename?: 'events_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Events_Variance_Fields = {
  __typename?: 'events_variance_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  parent_event_id: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq: InputMaybe<Scalars['float8']>;
  _gt: InputMaybe<Scalars['float8']>;
  _gte: InputMaybe<Scalars['float8']>;
  _in: InputMaybe<Array<Scalars['float8']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['float8']>;
  _lte: InputMaybe<Scalars['float8']>;
  _neq: InputMaybe<Scalars['float8']>;
  _nin: InputMaybe<Array<Scalars['float8']>>;
};

/** columns and relationships of "follows" */
export type Follows = {
  __typename?: 'follows';
  created_at: Scalars['timestamptz'];
  created_by_user_id: Scalars['Int'];
  /** An object relationship */
  follow_member: Maybe<List_Members>;
  id: Scalars['Int'];
  /** An object relationship */
  list: Maybe<Lists>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Scalars['Int'];
  resource_type: Scalars['String'];
};

/** aggregated selection of "follows" */
export type Follows_Aggregate = {
  __typename?: 'follows_aggregate';
  aggregate: Maybe<Follows_Aggregate_Fields>;
  nodes: Array<Follows>;
};

/** aggregate fields of "follows" */
export type Follows_Aggregate_Fields = {
  __typename?: 'follows_aggregate_fields';
  avg: Maybe<Follows_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Follows_Max_Fields>;
  min: Maybe<Follows_Min_Fields>;
  stddev: Maybe<Follows_Stddev_Fields>;
  stddev_pop: Maybe<Follows_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Follows_Stddev_Samp_Fields>;
  sum: Maybe<Follows_Sum_Fields>;
  var_pop: Maybe<Follows_Var_Pop_Fields>;
  var_samp: Maybe<Follows_Var_Samp_Fields>;
  variance: Maybe<Follows_Variance_Fields>;
};


/** aggregate fields of "follows" */
export type Follows_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Follows_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Follows_Avg_Fields = {
  __typename?: 'follows_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "follows". All fields are combined with a logical 'AND'. */
export type Follows_Bool_Exp = {
  _and: InputMaybe<Array<Follows_Bool_Exp>>;
  _not: InputMaybe<Follows_Bool_Exp>;
  _or: InputMaybe<Array<Follows_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  follow_member: InputMaybe<List_Members_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list: InputMaybe<Lists_Bool_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
};

/** columns and relationships of "follows_companies" */
export type Follows_Companies = {
  __typename?: 'follows_companies';
  /** An object relationship */
  company: Maybe<Companies>;
  created_by_user_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  follow_member: Maybe<List_Members>;
  id: Maybe<Scalars['Int']>;
  /** An object relationship */
  list: Maybe<Lists>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** aggregated selection of "follows_companies" */
export type Follows_Companies_Aggregate = {
  __typename?: 'follows_companies_aggregate';
  aggregate: Maybe<Follows_Companies_Aggregate_Fields>;
  nodes: Array<Follows_Companies>;
};

export type Follows_Companies_Aggregate_Bool_Exp = {
  count: InputMaybe<Follows_Companies_Aggregate_Bool_Exp_Count>;
};

export type Follows_Companies_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Follows_Companies_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Follows_Companies_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "follows_companies" */
export type Follows_Companies_Aggregate_Fields = {
  __typename?: 'follows_companies_aggregate_fields';
  avg: Maybe<Follows_Companies_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Follows_Companies_Max_Fields>;
  min: Maybe<Follows_Companies_Min_Fields>;
  stddev: Maybe<Follows_Companies_Stddev_Fields>;
  stddev_pop: Maybe<Follows_Companies_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Follows_Companies_Stddev_Samp_Fields>;
  sum: Maybe<Follows_Companies_Sum_Fields>;
  var_pop: Maybe<Follows_Companies_Var_Pop_Fields>;
  var_samp: Maybe<Follows_Companies_Var_Samp_Fields>;
  variance: Maybe<Follows_Companies_Variance_Fields>;
};


/** aggregate fields of "follows_companies" */
export type Follows_Companies_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Follows_Companies_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "follows_companies" */
export type Follows_Companies_Aggregate_Order_By = {
  avg: InputMaybe<Follows_Companies_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Follows_Companies_Max_Order_By>;
  min: InputMaybe<Follows_Companies_Min_Order_By>;
  stddev: InputMaybe<Follows_Companies_Stddev_Order_By>;
  stddev_pop: InputMaybe<Follows_Companies_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Follows_Companies_Stddev_Samp_Order_By>;
  sum: InputMaybe<Follows_Companies_Sum_Order_By>;
  var_pop: InputMaybe<Follows_Companies_Var_Pop_Order_By>;
  var_samp: InputMaybe<Follows_Companies_Var_Samp_Order_By>;
  variance: InputMaybe<Follows_Companies_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "follows_companies" */
export type Follows_Companies_Arr_Rel_Insert_Input = {
  data: Array<Follows_Companies_Insert_Input>;
};

/** aggregate avg on columns */
export type Follows_Companies_Avg_Fields = {
  __typename?: 'follows_companies_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "follows_companies" */
export type Follows_Companies_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "follows_companies". All fields are combined with a logical 'AND'. */
export type Follows_Companies_Bool_Exp = {
  _and: InputMaybe<Array<Follows_Companies_Bool_Exp>>;
  _not: InputMaybe<Follows_Companies_Bool_Exp>;
  _or: InputMaybe<Array<Follows_Companies_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  follow_member: InputMaybe<List_Members_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list: InputMaybe<Lists_Bool_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "follows_companies" */
export type Follows_Companies_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "follows_companies" */
export type Follows_Companies_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  follow_member: InputMaybe<List_Members_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  list: InputMaybe<Lists_Obj_Rel_Insert_Input>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Follows_Companies_Max_Fields = {
  __typename?: 'follows_companies_max_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "follows_companies" */
export type Follows_Companies_Max_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Follows_Companies_Min_Fields = {
  __typename?: 'follows_companies_min_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "follows_companies" */
export type Follows_Companies_Min_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "follows_companies" */
export type Follows_Companies_Mutation_Response = {
  __typename?: 'follows_companies_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Follows_Companies>;
};

/** Ordering options when selecting data from "follows_companies". */
export type Follows_Companies_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  follow_member: InputMaybe<List_Members_Order_By>;
  id: InputMaybe<Order_By>;
  list: InputMaybe<Lists_Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** select columns of table "follows_companies" */
export enum Follows_Companies_Select_Column {
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type'
}

/** input type for updating data in table "follows_companies" */
export type Follows_Companies_Set_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Follows_Companies_Stddev_Fields = {
  __typename?: 'follows_companies_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "follows_companies" */
export type Follows_Companies_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Follows_Companies_Stddev_Pop_Fields = {
  __typename?: 'follows_companies_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "follows_companies" */
export type Follows_Companies_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Follows_Companies_Stddev_Samp_Fields = {
  __typename?: 'follows_companies_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "follows_companies" */
export type Follows_Companies_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "follows_companies" */
export type Follows_Companies_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Follows_Companies_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Follows_Companies_Stream_Cursor_Value_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Follows_Companies_Sum_Fields = {
  __typename?: 'follows_companies_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "follows_companies" */
export type Follows_Companies_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

export type Follows_Companies_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Follows_Companies_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Follows_Companies_Set_Input>;
  /** filter the rows which have to be updated */
  where: Follows_Companies_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Follows_Companies_Var_Pop_Fields = {
  __typename?: 'follows_companies_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "follows_companies" */
export type Follows_Companies_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Follows_Companies_Var_Samp_Fields = {
  __typename?: 'follows_companies_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "follows_companies" */
export type Follows_Companies_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Follows_Companies_Variance_Fields = {
  __typename?: 'follows_companies_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "follows_companies" */
export type Follows_Companies_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** unique or primary key constraints on table "follows" */
export enum Follows_Constraint {
  /** unique or primary key constraint on columns "id" */
  FollowsPkey = 'follows_pkey',
  /** unique or primary key constraint on columns "resource_id", "list_id", "resource_type" */
  FollowsResourceTypeResourceIdListIdKey = 'follows_resource_type_resource_id_list_id_key'
}

/** input type for incrementing numeric columns in table "follows" */
export type Follows_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "follows" */
export type Follows_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  follow_member: InputMaybe<List_Members_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  list: InputMaybe<Lists_Obj_Rel_Insert_Input>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Follows_Max_Fields = {
  __typename?: 'follows_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Follows_Min_Fields = {
  __typename?: 'follows_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "follows" */
export type Follows_Mutation_Response = {
  __typename?: 'follows_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Follows>;
};

/** on_conflict condition type for table "follows" */
export type Follows_On_Conflict = {
  constraint: Follows_Constraint;
  update_columns: Array<Follows_Update_Column>;
  where: InputMaybe<Follows_Bool_Exp>;
};

/** Ordering options when selecting data from "follows". */
export type Follows_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  follow_member: InputMaybe<List_Members_Order_By>;
  id: InputMaybe<Order_By>;
  list: InputMaybe<Lists_Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** columns and relationships of "follows_people" */
export type Follows_People = {
  __typename?: 'follows_people';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  person: Maybe<People>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** aggregated selection of "follows_people" */
export type Follows_People_Aggregate = {
  __typename?: 'follows_people_aggregate';
  aggregate: Maybe<Follows_People_Aggregate_Fields>;
  nodes: Array<Follows_People>;
};

export type Follows_People_Aggregate_Bool_Exp = {
  count: InputMaybe<Follows_People_Aggregate_Bool_Exp_Count>;
};

export type Follows_People_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Follows_People_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Follows_People_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "follows_people" */
export type Follows_People_Aggregate_Fields = {
  __typename?: 'follows_people_aggregate_fields';
  avg: Maybe<Follows_People_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Follows_People_Max_Fields>;
  min: Maybe<Follows_People_Min_Fields>;
  stddev: Maybe<Follows_People_Stddev_Fields>;
  stddev_pop: Maybe<Follows_People_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Follows_People_Stddev_Samp_Fields>;
  sum: Maybe<Follows_People_Sum_Fields>;
  var_pop: Maybe<Follows_People_Var_Pop_Fields>;
  var_samp: Maybe<Follows_People_Var_Samp_Fields>;
  variance: Maybe<Follows_People_Variance_Fields>;
};


/** aggregate fields of "follows_people" */
export type Follows_People_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Follows_People_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "follows_people" */
export type Follows_People_Aggregate_Order_By = {
  avg: InputMaybe<Follows_People_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Follows_People_Max_Order_By>;
  min: InputMaybe<Follows_People_Min_Order_By>;
  stddev: InputMaybe<Follows_People_Stddev_Order_By>;
  stddev_pop: InputMaybe<Follows_People_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Follows_People_Stddev_Samp_Order_By>;
  sum: InputMaybe<Follows_People_Sum_Order_By>;
  var_pop: InputMaybe<Follows_People_Var_Pop_Order_By>;
  var_samp: InputMaybe<Follows_People_Var_Samp_Order_By>;
  variance: InputMaybe<Follows_People_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "follows_people" */
export type Follows_People_Arr_Rel_Insert_Input = {
  data: Array<Follows_People_Insert_Input>;
};

/** aggregate avg on columns */
export type Follows_People_Avg_Fields = {
  __typename?: 'follows_people_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "follows_people" */
export type Follows_People_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "follows_people". All fields are combined with a logical 'AND'. */
export type Follows_People_Bool_Exp = {
  _and: InputMaybe<Array<Follows_People_Bool_Exp>>;
  _not: InputMaybe<Follows_People_Bool_Exp>;
  _or: InputMaybe<Array<Follows_People_Bool_Exp>>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "follows_people" */
export type Follows_People_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "follows_people" */
export type Follows_People_Insert_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Follows_People_Max_Fields = {
  __typename?: 'follows_people_max_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "follows_people" */
export type Follows_People_Max_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Follows_People_Min_Fields = {
  __typename?: 'follows_people_min_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "follows_people" */
export type Follows_People_Min_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "follows_people" */
export type Follows_People_Mutation_Response = {
  __typename?: 'follows_people_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Follows_People>;
};

/** Ordering options when selecting data from "follows_people". */
export type Follows_People_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  person: InputMaybe<People_Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** select columns of table "follows_people" */
export enum Follows_People_Select_Column {
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type'
}

/** input type for updating data in table "follows_people" */
export type Follows_People_Set_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Follows_People_Stddev_Fields = {
  __typename?: 'follows_people_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "follows_people" */
export type Follows_People_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Follows_People_Stddev_Pop_Fields = {
  __typename?: 'follows_people_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "follows_people" */
export type Follows_People_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Follows_People_Stddev_Samp_Fields = {
  __typename?: 'follows_people_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "follows_people" */
export type Follows_People_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "follows_people" */
export type Follows_People_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Follows_People_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Follows_People_Stream_Cursor_Value_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Follows_People_Sum_Fields = {
  __typename?: 'follows_people_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "follows_people" */
export type Follows_People_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

export type Follows_People_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Follows_People_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Follows_People_Set_Input>;
  /** filter the rows which have to be updated */
  where: Follows_People_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Follows_People_Var_Pop_Fields = {
  __typename?: 'follows_people_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "follows_people" */
export type Follows_People_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Follows_People_Var_Samp_Fields = {
  __typename?: 'follows_people_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "follows_people" */
export type Follows_People_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Follows_People_Variance_Fields = {
  __typename?: 'follows_people_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "follows_people" */
export type Follows_People_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: follows */
export type Follows_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "follows" */
export enum Follows_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type'
}

/** input type for updating data in table "follows" */
export type Follows_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Follows_Stddev_Fields = {
  __typename?: 'follows_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Follows_Stddev_Pop_Fields = {
  __typename?: 'follows_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Follows_Stddev_Samp_Fields = {
  __typename?: 'follows_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "follows" */
export type Follows_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Follows_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Follows_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Follows_Sum_Fields = {
  __typename?: 'follows_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** update columns of table "follows" */
export enum Follows_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type'
}

export type Follows_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Follows_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Follows_Set_Input>;
  /** filter the rows which have to be updated */
  where: Follows_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Follows_Var_Pop_Fields = {
  __typename?: 'follows_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Follows_Var_Samp_Fields = {
  __typename?: 'follows_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Follows_Variance_Fields = {
  __typename?: 'follows_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "follows_vc_firms" */
export type Follows_Vc_Firms = {
  __typename?: 'follows_vc_firms';
  created_by_user_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  follow_member: Maybe<List_Members>;
  id: Maybe<Scalars['Int']>;
  /** An object relationship */
  list: Maybe<Lists>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
};

/** aggregated selection of "follows_vc_firms" */
export type Follows_Vc_Firms_Aggregate = {
  __typename?: 'follows_vc_firms_aggregate';
  aggregate: Maybe<Follows_Vc_Firms_Aggregate_Fields>;
  nodes: Array<Follows_Vc_Firms>;
};

export type Follows_Vc_Firms_Aggregate_Bool_Exp = {
  count: InputMaybe<Follows_Vc_Firms_Aggregate_Bool_Exp_Count>;
};

export type Follows_Vc_Firms_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "follows_vc_firms" */
export type Follows_Vc_Firms_Aggregate_Fields = {
  __typename?: 'follows_vc_firms_aggregate_fields';
  avg: Maybe<Follows_Vc_Firms_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Follows_Vc_Firms_Max_Fields>;
  min: Maybe<Follows_Vc_Firms_Min_Fields>;
  stddev: Maybe<Follows_Vc_Firms_Stddev_Fields>;
  stddev_pop: Maybe<Follows_Vc_Firms_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Follows_Vc_Firms_Stddev_Samp_Fields>;
  sum: Maybe<Follows_Vc_Firms_Sum_Fields>;
  var_pop: Maybe<Follows_Vc_Firms_Var_Pop_Fields>;
  var_samp: Maybe<Follows_Vc_Firms_Var_Samp_Fields>;
  variance: Maybe<Follows_Vc_Firms_Variance_Fields>;
};


/** aggregate fields of "follows_vc_firms" */
export type Follows_Vc_Firms_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "follows_vc_firms" */
export type Follows_Vc_Firms_Aggregate_Order_By = {
  avg: InputMaybe<Follows_Vc_Firms_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Follows_Vc_Firms_Max_Order_By>;
  min: InputMaybe<Follows_Vc_Firms_Min_Order_By>;
  stddev: InputMaybe<Follows_Vc_Firms_Stddev_Order_By>;
  stddev_pop: InputMaybe<Follows_Vc_Firms_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Follows_Vc_Firms_Stddev_Samp_Order_By>;
  sum: InputMaybe<Follows_Vc_Firms_Sum_Order_By>;
  var_pop: InputMaybe<Follows_Vc_Firms_Var_Pop_Order_By>;
  var_samp: InputMaybe<Follows_Vc_Firms_Var_Samp_Order_By>;
  variance: InputMaybe<Follows_Vc_Firms_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "follows_vc_firms" */
export type Follows_Vc_Firms_Arr_Rel_Insert_Input = {
  data: Array<Follows_Vc_Firms_Insert_Input>;
};

/** aggregate avg on columns */
export type Follows_Vc_Firms_Avg_Fields = {
  __typename?: 'follows_vc_firms_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "follows_vc_firms". All fields are combined with a logical 'AND'. */
export type Follows_Vc_Firms_Bool_Exp = {
  _and: InputMaybe<Array<Follows_Vc_Firms_Bool_Exp>>;
  _not: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
  _or: InputMaybe<Array<Follows_Vc_Firms_Bool_Exp>>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  follow_member: InputMaybe<List_Members_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list: InputMaybe<Lists_Bool_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "follows_vc_firms" */
export type Follows_Vc_Firms_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "follows_vc_firms" */
export type Follows_Vc_Firms_Insert_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  follow_member: InputMaybe<List_Members_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  list: InputMaybe<Lists_Obj_Rel_Insert_Input>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Follows_Vc_Firms_Max_Fields = {
  __typename?: 'follows_vc_firms_max_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Max_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Follows_Vc_Firms_Min_Fields = {
  __typename?: 'follows_vc_firms_min_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Min_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "follows_vc_firms" */
export type Follows_Vc_Firms_Mutation_Response = {
  __typename?: 'follows_vc_firms_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Follows_Vc_Firms>;
};

/** Ordering options when selecting data from "follows_vc_firms". */
export type Follows_Vc_Firms_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  follow_member: InputMaybe<List_Members_Order_By>;
  id: InputMaybe<Order_By>;
  list: InputMaybe<Lists_Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
};

/** select columns of table "follows_vc_firms" */
export enum Follows_Vc_Firms_Select_Column {
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type'
}

/** input type for updating data in table "follows_vc_firms" */
export type Follows_Vc_Firms_Set_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Follows_Vc_Firms_Stddev_Fields = {
  __typename?: 'follows_vc_firms_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Follows_Vc_Firms_Stddev_Pop_Fields = {
  __typename?: 'follows_vc_firms_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Follows_Vc_Firms_Stddev_Samp_Fields = {
  __typename?: 'follows_vc_firms_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "follows_vc_firms" */
export type Follows_Vc_Firms_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Follows_Vc_Firms_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Follows_Vc_Firms_Stream_Cursor_Value_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Follows_Vc_Firms_Sum_Fields = {
  __typename?: 'follows_vc_firms_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

export type Follows_Vc_Firms_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Follows_Vc_Firms_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Follows_Vc_Firms_Set_Input>;
  /** filter the rows which have to be updated */
  where: Follows_Vc_Firms_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Follows_Vc_Firms_Var_Pop_Fields = {
  __typename?: 'follows_vc_firms_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Follows_Vc_Firms_Var_Samp_Fields = {
  __typename?: 'follows_vc_firms_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Follows_Vc_Firms_Variance_Fields = {
  __typename?: 'follows_vc_firms_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "follows_vc_firms" */
export type Follows_Vc_Firms_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
};

export type Geography_Cast_Exp = {
  geometry: InputMaybe<Geometry_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type Geography_Comparison_Exp = {
  _cast: InputMaybe<Geography_Cast_Exp>;
  _eq: InputMaybe<Scalars['geography']>;
  _gt: InputMaybe<Scalars['geography']>;
  _gte: InputMaybe<Scalars['geography']>;
  _in: InputMaybe<Array<Scalars['geography']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['geography']>;
  _lte: InputMaybe<Scalars['geography']>;
  _neq: InputMaybe<Scalars['geography']>;
  _nin: InputMaybe<Array<Scalars['geography']>>;
  /** is the column within a given distance from the given geography value */
  _st_d_within: InputMaybe<St_D_Within_Geography_Input>;
  /** does the column spatially intersect the given geography value */
  _st_intersects: InputMaybe<Scalars['geography']>;
};

export type Geometry_Cast_Exp = {
  geography: InputMaybe<Geography_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type Geometry_Comparison_Exp = {
  _cast: InputMaybe<Geometry_Cast_Exp>;
  _eq: InputMaybe<Scalars['geometry']>;
  _gt: InputMaybe<Scalars['geometry']>;
  _gte: InputMaybe<Scalars['geometry']>;
  _in: InputMaybe<Array<Scalars['geometry']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['geometry']>;
  _lte: InputMaybe<Scalars['geometry']>;
  _neq: InputMaybe<Scalars['geometry']>;
  _nin: InputMaybe<Array<Scalars['geometry']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st_3d_d_within: InputMaybe<St_D_Within_Input>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st_3d_intersects: InputMaybe<Scalars['geometry']>;
  /** does the column contain the given geometry value */
  _st_contains: InputMaybe<Scalars['geometry']>;
  /** does the column cross the given geometry value */
  _st_crosses: InputMaybe<Scalars['geometry']>;
  /** is the column within a given distance from the given geometry value */
  _st_d_within: InputMaybe<St_D_Within_Input>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _st_equals: InputMaybe<Scalars['geometry']>;
  /** does the column spatially intersect the given geometry value */
  _st_intersects: InputMaybe<Scalars['geometry']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _st_overlaps: InputMaybe<Scalars['geometry']>;
  /** does the column have atleast one point in common with the given geometry value */
  _st_touches: InputMaybe<Scalars['geometry']>;
  /** is the column contained in the given geometry value */
  _st_within: InputMaybe<Scalars['geometry']>;
};

/** columns and relationships of "investment_rounds" */
export type Investment_Rounds = {
  __typename?: 'investment_rounds';
  amount: Maybe<Scalars['numeric']>;
  /** An object relationship */
  company: Maybe<Companies>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  currency: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An array relationship */
  investments: Array<Investments>;
  /** An aggregate relationship */
  investments_aggregate: Investments_Aggregate;
  round: Maybe<Scalars['String']>;
  round_date: Maybe<Scalars['date']>;
  status: Scalars['String'];
  valuation: Maybe<Scalars['numeric']>;
};


/** columns and relationships of "investment_rounds" */
export type Investment_RoundsInvestmentsArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


/** columns and relationships of "investment_rounds" */
export type Investment_RoundsInvestments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};

/** aggregated selection of "investment_rounds" */
export type Investment_Rounds_Aggregate = {
  __typename?: 'investment_rounds_aggregate';
  aggregate: Maybe<Investment_Rounds_Aggregate_Fields>;
  nodes: Array<Investment_Rounds>;
};

export type Investment_Rounds_Aggregate_Bool_Exp = {
  count: InputMaybe<Investment_Rounds_Aggregate_Bool_Exp_Count>;
};

export type Investment_Rounds_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Investment_Rounds_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "investment_rounds" */
export type Investment_Rounds_Aggregate_Fields = {
  __typename?: 'investment_rounds_aggregate_fields';
  avg: Maybe<Investment_Rounds_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Investment_Rounds_Max_Fields>;
  min: Maybe<Investment_Rounds_Min_Fields>;
  stddev: Maybe<Investment_Rounds_Stddev_Fields>;
  stddev_pop: Maybe<Investment_Rounds_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Investment_Rounds_Stddev_Samp_Fields>;
  sum: Maybe<Investment_Rounds_Sum_Fields>;
  var_pop: Maybe<Investment_Rounds_Var_Pop_Fields>;
  var_samp: Maybe<Investment_Rounds_Var_Samp_Fields>;
  variance: Maybe<Investment_Rounds_Variance_Fields>;
};


/** aggregate fields of "investment_rounds" */
export type Investment_Rounds_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "investment_rounds" */
export type Investment_Rounds_Aggregate_Order_By = {
  avg: InputMaybe<Investment_Rounds_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Investment_Rounds_Max_Order_By>;
  min: InputMaybe<Investment_Rounds_Min_Order_By>;
  stddev: InputMaybe<Investment_Rounds_Stddev_Order_By>;
  stddev_pop: InputMaybe<Investment_Rounds_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Investment_Rounds_Stddev_Samp_Order_By>;
  sum: InputMaybe<Investment_Rounds_Sum_Order_By>;
  var_pop: InputMaybe<Investment_Rounds_Var_Pop_Order_By>;
  var_samp: InputMaybe<Investment_Rounds_Var_Samp_Order_By>;
  variance: InputMaybe<Investment_Rounds_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "investment_rounds" */
export type Investment_Rounds_Arr_Rel_Insert_Input = {
  data: Array<Investment_Rounds_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Investment_Rounds_On_Conflict>;
};

/** aggregate avg on columns */
export type Investment_Rounds_Avg_Fields = {
  __typename?: 'investment_rounds_avg_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "investment_rounds" */
export type Investment_Rounds_Avg_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "investment_rounds". All fields are combined with a logical 'AND'. */
export type Investment_Rounds_Bool_Exp = {
  _and: InputMaybe<Array<Investment_Rounds_Bool_Exp>>;
  _not: InputMaybe<Investment_Rounds_Bool_Exp>;
  _or: InputMaybe<Array<Investment_Rounds_Bool_Exp>>;
  amount: InputMaybe<Numeric_Comparison_Exp>;
  company: InputMaybe<Companies_Bool_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  currency: InputMaybe<String_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  investments: InputMaybe<Investments_Bool_Exp>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Bool_Exp>;
  round: InputMaybe<String_Comparison_Exp>;
  round_date: InputMaybe<Date_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  valuation: InputMaybe<Numeric_Comparison_Exp>;
};

/** unique or primary key constraints on table "investment_rounds" */
export enum Investment_Rounds_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  InvestmentRoundsExternalIdKey = 'investment_rounds_external_id_key',
  /** unique or primary key constraint on columns "id" */
  InvestmentRoundsPkey = 'investment_rounds_pkey'
}

/** input type for incrementing numeric columns in table "investment_rounds" */
export type Investment_Rounds_Inc_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  company_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  valuation: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "investment_rounds" */
export type Investment_Rounds_Insert_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  currency: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investments: InputMaybe<Investments_Arr_Rel_Insert_Input>;
  round: InputMaybe<Scalars['String']>;
  round_date: InputMaybe<Scalars['date']>;
  status: InputMaybe<Scalars['String']>;
  valuation: InputMaybe<Scalars['numeric']>;
};

/** aggregate max on columns */
export type Investment_Rounds_Max_Fields = {
  __typename?: 'investment_rounds_max_fields';
  amount: Maybe<Scalars['numeric']>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  currency: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  round: Maybe<Scalars['String']>;
  round_date: Maybe<Scalars['date']>;
  status: Maybe<Scalars['String']>;
  valuation: Maybe<Scalars['numeric']>;
};

/** order by max() on columns of table "investment_rounds" */
export type Investment_Rounds_Max_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  round: InputMaybe<Order_By>;
  round_date: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Investment_Rounds_Min_Fields = {
  __typename?: 'investment_rounds_min_fields';
  amount: Maybe<Scalars['numeric']>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  currency: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  round: Maybe<Scalars['String']>;
  round_date: Maybe<Scalars['date']>;
  status: Maybe<Scalars['String']>;
  valuation: Maybe<Scalars['numeric']>;
};

/** order by min() on columns of table "investment_rounds" */
export type Investment_Rounds_Min_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  round: InputMaybe<Order_By>;
  round_date: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** response of any mutation on the table "investment_rounds" */
export type Investment_Rounds_Mutation_Response = {
  __typename?: 'investment_rounds_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Investment_Rounds>;
};

/** input type for inserting object relation for remote table "investment_rounds" */
export type Investment_Rounds_Obj_Rel_Insert_Input = {
  data: Investment_Rounds_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Investment_Rounds_On_Conflict>;
};

/** on_conflict condition type for table "investment_rounds" */
export type Investment_Rounds_On_Conflict = {
  constraint: Investment_Rounds_Constraint;
  update_columns: Array<Investment_Rounds_Update_Column>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};

/** Ordering options when selecting data from "investment_rounds". */
export type Investment_Rounds_Order_By = {
  amount: InputMaybe<Order_By>;
  company: InputMaybe<Companies_Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Order_By>;
  round: InputMaybe<Order_By>;
  round_date: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** primary key columns input for table: investment_rounds */
export type Investment_Rounds_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "investment_rounds" */
export enum Investment_Rounds_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Currency = 'currency',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  Round = 'round',
  /** column name */
  RoundDate = 'round_date',
  /** column name */
  Status = 'status',
  /** column name */
  Valuation = 'valuation'
}

/** input type for updating data in table "investment_rounds" */
export type Investment_Rounds_Set_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  currency: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  round: InputMaybe<Scalars['String']>;
  round_date: InputMaybe<Scalars['date']>;
  status: InputMaybe<Scalars['String']>;
  valuation: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type Investment_Rounds_Stddev_Fields = {
  __typename?: 'investment_rounds_stddev_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "investment_rounds" */
export type Investment_Rounds_Stddev_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Investment_Rounds_Stddev_Pop_Fields = {
  __typename?: 'investment_rounds_stddev_pop_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "investment_rounds" */
export type Investment_Rounds_Stddev_Pop_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Investment_Rounds_Stddev_Samp_Fields = {
  __typename?: 'investment_rounds_stddev_samp_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "investment_rounds" */
export type Investment_Rounds_Stddev_Samp_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "investment_rounds" */
export type Investment_Rounds_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Investment_Rounds_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Investment_Rounds_Stream_Cursor_Value_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  currency: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  round: InputMaybe<Scalars['String']>;
  round_date: InputMaybe<Scalars['date']>;
  status: InputMaybe<Scalars['String']>;
  valuation: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type Investment_Rounds_Sum_Fields = {
  __typename?: 'investment_rounds_sum_fields';
  amount: Maybe<Scalars['numeric']>;
  company_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  valuation: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "investment_rounds" */
export type Investment_Rounds_Sum_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** update columns of table "investment_rounds" */
export enum Investment_Rounds_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Currency = 'currency',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  Round = 'round',
  /** column name */
  RoundDate = 'round_date',
  /** column name */
  Status = 'status',
  /** column name */
  Valuation = 'valuation'
}

export type Investment_Rounds_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Investment_Rounds_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Investment_Rounds_Set_Input>;
  /** filter the rows which have to be updated */
  where: Investment_Rounds_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Investment_Rounds_Var_Pop_Fields = {
  __typename?: 'investment_rounds_var_pop_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "investment_rounds" */
export type Investment_Rounds_Var_Pop_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Investment_Rounds_Var_Samp_Fields = {
  __typename?: 'investment_rounds_var_samp_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "investment_rounds" */
export type Investment_Rounds_Var_Samp_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Investment_Rounds_Variance_Fields = {
  __typename?: 'investment_rounds_variance_fields';
  amount: Maybe<Scalars['Float']>;
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  valuation: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "investment_rounds" */
export type Investment_Rounds_Variance_Order_By = {
  amount: InputMaybe<Order_By>;
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  valuation: InputMaybe<Order_By>;
};

/** columns and relationships of "investments" */
export type Investments = {
  __typename?: 'investments';
  amount: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  external_id: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object relationship */
  investment_round: Maybe<Investment_Rounds>;
  /** An object relationship */
  person: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  round_id: Maybe<Scalars['Int']>;
  status: Scalars['String'];
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "investments" */
export type Investments_Aggregate = {
  __typename?: 'investments_aggregate';
  aggregate: Maybe<Investments_Aggregate_Fields>;
  nodes: Array<Investments>;
};

export type Investments_Aggregate_Bool_Exp = {
  count: InputMaybe<Investments_Aggregate_Bool_Exp_Count>;
};

export type Investments_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Investments_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Investments_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "investments" */
export type Investments_Aggregate_Fields = {
  __typename?: 'investments_aggregate_fields';
  avg: Maybe<Investments_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Investments_Max_Fields>;
  min: Maybe<Investments_Min_Fields>;
  stddev: Maybe<Investments_Stddev_Fields>;
  stddev_pop: Maybe<Investments_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Investments_Stddev_Samp_Fields>;
  sum: Maybe<Investments_Sum_Fields>;
  var_pop: Maybe<Investments_Var_Pop_Fields>;
  var_samp: Maybe<Investments_Var_Samp_Fields>;
  variance: Maybe<Investments_Variance_Fields>;
};


/** aggregate fields of "investments" */
export type Investments_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Investments_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "investments" */
export type Investments_Aggregate_Order_By = {
  avg: InputMaybe<Investments_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Investments_Max_Order_By>;
  min: InputMaybe<Investments_Min_Order_By>;
  stddev: InputMaybe<Investments_Stddev_Order_By>;
  stddev_pop: InputMaybe<Investments_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Investments_Stddev_Samp_Order_By>;
  sum: InputMaybe<Investments_Sum_Order_By>;
  var_pop: InputMaybe<Investments_Var_Pop_Order_By>;
  var_samp: InputMaybe<Investments_Var_Samp_Order_By>;
  variance: InputMaybe<Investments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "investments" */
export type Investments_Arr_Rel_Insert_Input = {
  data: Array<Investments_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Investments_On_Conflict>;
};

/** aggregate avg on columns */
export type Investments_Avg_Fields = {
  __typename?: 'investments_avg_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "investments" */
export type Investments_Avg_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "investments". All fields are combined with a logical 'AND'. */
export type Investments_Bool_Exp = {
  _and: InputMaybe<Array<Investments_Bool_Exp>>;
  _not: InputMaybe<Investments_Bool_Exp>;
  _or: InputMaybe<Array<Investments_Bool_Exp>>;
  amount: InputMaybe<Numeric_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  investment_round: InputMaybe<Investment_Rounds_Bool_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  round_id: InputMaybe<Int_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "investments" */
export enum Investments_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  InvestmentsExternalIdKey = 'investments_external_id_key',
  /** unique or primary key constraint on columns "id" */
  InvestmentsPkey = 'investments_pkey'
}

/** input type for incrementing numeric columns in table "investments" */
export type Investments_Inc_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  round_id: InputMaybe<Scalars['Int']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "investments" */
export type Investments_Insert_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investment_round: InputMaybe<Investment_Rounds_Obj_Rel_Insert_Input>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  round_id: InputMaybe<Scalars['Int']>;
  status: InputMaybe<Scalars['String']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Investments_Max_Fields = {
  __typename?: 'investments_max_fields';
  amount: Maybe<Scalars['numeric']>;
  created_at: Maybe<Scalars['timestamptz']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  round_id: Maybe<Scalars['Int']>;
  status: Maybe<Scalars['String']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "investments" */
export type Investments_Max_Order_By = {
  amount: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Investments_Min_Fields = {
  __typename?: 'investments_min_fields';
  amount: Maybe<Scalars['numeric']>;
  created_at: Maybe<Scalars['timestamptz']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  round_id: Maybe<Scalars['Int']>;
  status: Maybe<Scalars['String']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "investments" */
export type Investments_Min_Order_By = {
  amount: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "investments" */
export type Investments_Mutation_Response = {
  __typename?: 'investments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Investments>;
};

/** on_conflict condition type for table "investments" */
export type Investments_On_Conflict = {
  constraint: Investments_Constraint;
  update_columns: Array<Investments_Update_Column>;
  where: InputMaybe<Investments_Bool_Exp>;
};

/** Ordering options when selecting data from "investments". */
export type Investments_Order_By = {
  amount: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  investment_round: InputMaybe<Investment_Rounds_Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: investments */
export type Investments_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "investments" */
export enum Investments_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  RoundId = 'round_id',
  /** column name */
  Status = 'status',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

/** input type for updating data in table "investments" */
export type Investments_Set_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  round_id: InputMaybe<Scalars['Int']>;
  status: InputMaybe<Scalars['String']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Investments_Stddev_Fields = {
  __typename?: 'investments_stddev_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "investments" */
export type Investments_Stddev_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Investments_Stddev_Pop_Fields = {
  __typename?: 'investments_stddev_pop_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "investments" */
export type Investments_Stddev_Pop_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Investments_Stddev_Samp_Fields = {
  __typename?: 'investments_stddev_samp_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "investments" */
export type Investments_Stddev_Samp_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "investments" */
export type Investments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Investments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Investments_Stream_Cursor_Value_Input = {
  amount: InputMaybe<Scalars['numeric']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  external_id: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  round_id: InputMaybe<Scalars['Int']>;
  status: InputMaybe<Scalars['String']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Investments_Sum_Fields = {
  __typename?: 'investments_sum_fields';
  amount: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  round_id: Maybe<Scalars['Int']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "investments" */
export type Investments_Sum_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** update columns of table "investments" */
export enum Investments_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  RoundId = 'round_id',
  /** column name */
  Status = 'status',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

export type Investments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Investments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Investments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Investments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Investments_Var_Pop_Fields = {
  __typename?: 'investments_var_pop_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "investments" */
export type Investments_Var_Pop_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Investments_Var_Samp_Fields = {
  __typename?: 'investments_var_samp_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "investments" */
export type Investments_Var_Samp_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Investments_Variance_Fields = {
  __typename?: 'investments_variance_fields';
  amount: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  round_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "investments" */
export type Investments_Variance_Order_By = {
  amount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  round_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** columns and relationships of "investors" */
export type Investors = {
  __typename?: 'investors';
  created_at: Scalars['timestamptz'];
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Scalars['Int'];
  external_id: Maybe<Scalars['String']>;
  founder: Maybe<Scalars['Boolean']>;
  function: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object relationship */
  person: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "investors" */
export type Investors_Aggregate = {
  __typename?: 'investors_aggregate';
  aggregate: Maybe<Investors_Aggregate_Fields>;
  nodes: Array<Investors>;
};

export type Investors_Aggregate_Bool_Exp = {
  bool_and: InputMaybe<Investors_Aggregate_Bool_Exp_Bool_And>;
  bool_or: InputMaybe<Investors_Aggregate_Bool_Exp_Bool_Or>;
  count: InputMaybe<Investors_Aggregate_Bool_Exp_Count>;
};

export type Investors_Aggregate_Bool_Exp_Bool_And = {
  arguments: Investors_Select_Column_Investors_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Investors_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investors_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Investors_Select_Column_Investors_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Investors_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investors_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Investors_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Investors_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "investors" */
export type Investors_Aggregate_Fields = {
  __typename?: 'investors_aggregate_fields';
  avg: Maybe<Investors_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Investors_Max_Fields>;
  min: Maybe<Investors_Min_Fields>;
  stddev: Maybe<Investors_Stddev_Fields>;
  stddev_pop: Maybe<Investors_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Investors_Stddev_Samp_Fields>;
  sum: Maybe<Investors_Sum_Fields>;
  var_pop: Maybe<Investors_Var_Pop_Fields>;
  var_samp: Maybe<Investors_Var_Samp_Fields>;
  variance: Maybe<Investors_Variance_Fields>;
};


/** aggregate fields of "investors" */
export type Investors_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Investors_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "investors" */
export type Investors_Aggregate_Order_By = {
  avg: InputMaybe<Investors_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Investors_Max_Order_By>;
  min: InputMaybe<Investors_Min_Order_By>;
  stddev: InputMaybe<Investors_Stddev_Order_By>;
  stddev_pop: InputMaybe<Investors_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Investors_Stddev_Samp_Order_By>;
  sum: InputMaybe<Investors_Sum_Order_By>;
  var_pop: InputMaybe<Investors_Var_Pop_Order_By>;
  var_samp: InputMaybe<Investors_Var_Samp_Order_By>;
  variance: InputMaybe<Investors_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "investors" */
export type Investors_Arr_Rel_Insert_Input = {
  data: Array<Investors_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Investors_On_Conflict>;
};

/** aggregate avg on columns */
export type Investors_Avg_Fields = {
  __typename?: 'investors_avg_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "investors" */
export type Investors_Avg_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "investors". All fields are combined with a logical 'AND'. */
export type Investors_Bool_Exp = {
  _and: InputMaybe<Array<Investors_Bool_Exp>>;
  _not: InputMaybe<Investors_Bool_Exp>;
  _or: InputMaybe<Array<Investors_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email_address: InputMaybe<String_Comparison_Exp>;
  email_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  end_date: InputMaybe<Date_Comparison_Exp>;
  enrichment_priority: InputMaybe<Int_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  founder: InputMaybe<Boolean_Comparison_Exp>;
  function: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  seniority: InputMaybe<String_Comparison_Exp>;
  start_date: InputMaybe<Date_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "investors" */
export enum Investors_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  InvestorsExternalIdKey = 'investors_external_id_key',
  /** unique or primary key constraint on columns "id" */
  InvestorsPkey = 'investors_pkey',
  /** unique or primary key constraint on columns "vc_firm_id", "person_id" */
  InvestorsVcFirmIdPersonIdKey = 'investors_vc_firm_id_person_id_key'
}

/** input type for incrementing numeric columns in table "investors" */
export type Investors_Inc_Input = {
  enrichment_priority: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "investors" */
export type Investors_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Investors_Max_Fields = {
  __typename?: 'investors_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  function: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "investors" */
export type Investors_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Investors_Min_Fields = {
  __typename?: 'investors_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  function: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "investors" */
export type Investors_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "investors" */
export type Investors_Mutation_Response = {
  __typename?: 'investors_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Investors>;
};

/** on_conflict condition type for table "investors" */
export type Investors_On_Conflict = {
  constraint: Investors_Constraint;
  update_columns: Array<Investors_Update_Column>;
  where: InputMaybe<Investors_Bool_Exp>;
};

/** Ordering options when selecting data from "investors". */
export type Investors_Order_By = {
  created_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  founder: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: investors */
export type Investors_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "investors" */
export enum Investors_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailAddress = 'email_address',
  /** column name */
  EmailEnrichedAt = 'email_enriched_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Founder = 'founder',
  /** column name */
  Function = 'function',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Seniority = 'seniority',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

/** select "investors_aggregate_bool_exp_bool_and_arguments_columns" columns of table "investors" */
export enum Investors_Select_Column_Investors_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Founder = 'founder'
}

/** select "investors_aggregate_bool_exp_bool_or_arguments_columns" columns of table "investors" */
export enum Investors_Select_Column_Investors_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Founder = 'founder'
}

/** input type for updating data in table "investors" */
export type Investors_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Investors_Stddev_Fields = {
  __typename?: 'investors_stddev_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "investors" */
export type Investors_Stddev_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Investors_Stddev_Pop_Fields = {
  __typename?: 'investors_stddev_pop_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "investors" */
export type Investors_Stddev_Pop_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Investors_Stddev_Samp_Fields = {
  __typename?: 'investors_stddev_samp_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "investors" */
export type Investors_Stddev_Samp_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "investors" */
export type Investors_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Investors_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Investors_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Investors_Sum_Fields = {
  __typename?: 'investors_sum_fields';
  enrichment_priority: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "investors" */
export type Investors_Sum_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** update columns of table "investors" */
export enum Investors_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailAddress = 'email_address',
  /** column name */
  EmailEnrichedAt = 'email_enriched_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Founder = 'founder',
  /** column name */
  Function = 'function',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Seniority = 'seniority',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

export type Investors_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Investors_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Investors_Set_Input>;
  /** filter the rows which have to be updated */
  where: Investors_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Investors_Var_Pop_Fields = {
  __typename?: 'investors_var_pop_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "investors" */
export type Investors_Var_Pop_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Investors_Var_Samp_Fields = {
  __typename?: 'investors_var_samp_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "investors" */
export type Investors_Var_Samp_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Investors_Variance_Fields = {
  __typename?: 'investors_variance_fields';
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "investors" */
export type Investors_Variance_Order_By = {
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** columns and relationships of "invited_people" */
export type Invited_People = {
  __typename?: 'invited_people';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  inviter_user_id: Scalars['Int'];
  person_id: Scalars['Int'];
};

/** aggregated selection of "invited_people" */
export type Invited_People_Aggregate = {
  __typename?: 'invited_people_aggregate';
  aggregate: Maybe<Invited_People_Aggregate_Fields>;
  nodes: Array<Invited_People>;
};

/** aggregate fields of "invited_people" */
export type Invited_People_Aggregate_Fields = {
  __typename?: 'invited_people_aggregate_fields';
  avg: Maybe<Invited_People_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Invited_People_Max_Fields>;
  min: Maybe<Invited_People_Min_Fields>;
  stddev: Maybe<Invited_People_Stddev_Fields>;
  stddev_pop: Maybe<Invited_People_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Invited_People_Stddev_Samp_Fields>;
  sum: Maybe<Invited_People_Sum_Fields>;
  var_pop: Maybe<Invited_People_Var_Pop_Fields>;
  var_samp: Maybe<Invited_People_Var_Samp_Fields>;
  variance: Maybe<Invited_People_Variance_Fields>;
};


/** aggregate fields of "invited_people" */
export type Invited_People_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Invited_People_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Invited_People_Avg_Fields = {
  __typename?: 'invited_people_avg_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "invited_people". All fields are combined with a logical 'AND'. */
export type Invited_People_Bool_Exp = {
  _and: InputMaybe<Array<Invited_People_Bool_Exp>>;
  _not: InputMaybe<Invited_People_Bool_Exp>;
  _or: InputMaybe<Array<Invited_People_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  inviter_user_id: InputMaybe<Int_Comparison_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "invited_people" */
export enum Invited_People_Constraint {
  /** unique or primary key constraint on columns "id" */
  InvitedPeoplePkey = 'invited_people_pkey'
}

/** input type for incrementing numeric columns in table "invited_people" */
export type Invited_People_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  inviter_user_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "invited_people" */
export type Invited_People_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  inviter_user_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Invited_People_Max_Fields = {
  __typename?: 'invited_people_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  inviter_user_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Invited_People_Min_Fields = {
  __typename?: 'invited_people_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  inviter_user_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "invited_people" */
export type Invited_People_Mutation_Response = {
  __typename?: 'invited_people_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Invited_People>;
};

/** on_conflict condition type for table "invited_people" */
export type Invited_People_On_Conflict = {
  constraint: Invited_People_Constraint;
  update_columns: Array<Invited_People_Update_Column>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};

/** Ordering options when selecting data from "invited_people". */
export type Invited_People_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  inviter_user_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: invited_people */
export type Invited_People_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "invited_people" */
export enum Invited_People_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InviterUserId = 'inviter_user_id',
  /** column name */
  PersonId = 'person_id'
}

/** input type for updating data in table "invited_people" */
export type Invited_People_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  inviter_user_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Invited_People_Stddev_Fields = {
  __typename?: 'invited_people_stddev_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Invited_People_Stddev_Pop_Fields = {
  __typename?: 'invited_people_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Invited_People_Stddev_Samp_Fields = {
  __typename?: 'invited_people_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "invited_people" */
export type Invited_People_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Invited_People_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Invited_People_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  inviter_user_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Invited_People_Sum_Fields = {
  __typename?: 'invited_people_sum_fields';
  id: Maybe<Scalars['Int']>;
  inviter_user_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** update columns of table "invited_people" */
export enum Invited_People_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InviterUserId = 'inviter_user_id',
  /** column name */
  PersonId = 'person_id'
}

export type Invited_People_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Invited_People_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Invited_People_Set_Input>;
  /** filter the rows which have to be updated */
  where: Invited_People_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Invited_People_Var_Pop_Fields = {
  __typename?: 'invited_people_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Invited_People_Var_Samp_Fields = {
  __typename?: 'invited_people_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Invited_People_Variance_Fields = {
  __typename?: 'invited_people_variance_fields';
  id: Maybe<Scalars['Float']>;
  inviter_user_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

export type Jsonb_Cast_Exp = {
  String: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains: InputMaybe<Scalars['jsonb']>;
  _eq: InputMaybe<Scalars['jsonb']>;
  _gt: InputMaybe<Scalars['jsonb']>;
  _gte: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any: InputMaybe<Array<Scalars['String']>>;
  _in: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['jsonb']>;
  _lte: InputMaybe<Scalars['jsonb']>;
  _neq: InputMaybe<Scalars['jsonb']>;
  _nin: InputMaybe<Array<Scalars['jsonb']>>;
};

/** columns and relationships of "leads" */
export type Leads = {
  __typename?: 'leads';
  campaign_id: Maybe<Scalars['String']>;
  company_name: Maybe<Scalars['String']>;
  /** An object relationship */
  converted_user_id: Maybe<Users>;
  converted_userid: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  email: Scalars['String'];
  email_domain: Maybe<Scalars['String']>;
  first_name: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  instantly_id: Maybe<Scalars['String']>;
  last_name: Maybe<Scalars['String']>;
  linkedin_url: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  website: Maybe<Scalars['String']>;
};

/** aggregated selection of "leads" */
export type Leads_Aggregate = {
  __typename?: 'leads_aggregate';
  aggregate: Maybe<Leads_Aggregate_Fields>;
  nodes: Array<Leads>;
};

/** aggregate fields of "leads" */
export type Leads_Aggregate_Fields = {
  __typename?: 'leads_aggregate_fields';
  avg: Maybe<Leads_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Leads_Max_Fields>;
  min: Maybe<Leads_Min_Fields>;
  stddev: Maybe<Leads_Stddev_Fields>;
  stddev_pop: Maybe<Leads_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Leads_Stddev_Samp_Fields>;
  sum: Maybe<Leads_Sum_Fields>;
  var_pop: Maybe<Leads_Var_Pop_Fields>;
  var_samp: Maybe<Leads_Var_Samp_Fields>;
  variance: Maybe<Leads_Variance_Fields>;
};


/** aggregate fields of "leads" */
export type Leads_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Leads_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Leads_Avg_Fields = {
  __typename?: 'leads_avg_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "leads". All fields are combined with a logical 'AND'. */
export type Leads_Bool_Exp = {
  _and: InputMaybe<Array<Leads_Bool_Exp>>;
  _not: InputMaybe<Leads_Bool_Exp>;
  _or: InputMaybe<Array<Leads_Bool_Exp>>;
  campaign_id: InputMaybe<String_Comparison_Exp>;
  company_name: InputMaybe<String_Comparison_Exp>;
  converted_user_id: InputMaybe<Users_Bool_Exp>;
  converted_userid: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  email_domain: InputMaybe<String_Comparison_Exp>;
  first_name: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  instantly_id: InputMaybe<String_Comparison_Exp>;
  last_name: InputMaybe<String_Comparison_Exp>;
  linkedin_url: InputMaybe<String_Comparison_Exp>;
  phone: InputMaybe<String_Comparison_Exp>;
  source: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  website: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "leads" */
export enum Leads_Constraint {
  /** unique or primary key constraint on columns "email" */
  LeadsEmailKey = 'leads_email_key',
  /** unique or primary key constraint on columns "id" */
  LeadsPkey = 'leads_pkey'
}

/** input type for incrementing numeric columns in table "leads" */
export type Leads_Inc_Input = {
  converted_userid: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "leads" */
export type Leads_Insert_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  company_name: InputMaybe<Scalars['String']>;
  converted_user_id: InputMaybe<Users_Obj_Rel_Insert_Input>;
  converted_userid: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  email_domain: InputMaybe<Scalars['String']>;
  first_name: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  instantly_id: InputMaybe<Scalars['String']>;
  last_name: InputMaybe<Scalars['String']>;
  linkedin_url: InputMaybe<Scalars['String']>;
  phone: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  website: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Leads_Max_Fields = {
  __typename?: 'leads_max_fields';
  campaign_id: Maybe<Scalars['String']>;
  company_name: Maybe<Scalars['String']>;
  converted_userid: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  email: Maybe<Scalars['String']>;
  email_domain: Maybe<Scalars['String']>;
  first_name: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  instantly_id: Maybe<Scalars['String']>;
  last_name: Maybe<Scalars['String']>;
  linkedin_url: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  website: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Leads_Min_Fields = {
  __typename?: 'leads_min_fields';
  campaign_id: Maybe<Scalars['String']>;
  company_name: Maybe<Scalars['String']>;
  converted_userid: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  email: Maybe<Scalars['String']>;
  email_domain: Maybe<Scalars['String']>;
  first_name: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  instantly_id: Maybe<Scalars['String']>;
  last_name: Maybe<Scalars['String']>;
  linkedin_url: Maybe<Scalars['String']>;
  phone: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  website: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "leads" */
export type Leads_Mutation_Response = {
  __typename?: 'leads_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Leads>;
};

/** on_conflict condition type for table "leads" */
export type Leads_On_Conflict = {
  constraint: Leads_Constraint;
  update_columns: Array<Leads_Update_Column>;
  where: InputMaybe<Leads_Bool_Exp>;
};

/** Ordering options when selecting data from "leads". */
export type Leads_Order_By = {
  campaign_id: InputMaybe<Order_By>;
  company_name: InputMaybe<Order_By>;
  converted_user_id: InputMaybe<Users_Order_By>;
  converted_userid: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  email_domain: InputMaybe<Order_By>;
  first_name: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  instantly_id: InputMaybe<Order_By>;
  last_name: InputMaybe<Order_By>;
  linkedin_url: InputMaybe<Order_By>;
  phone: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  website: InputMaybe<Order_By>;
};

/** primary key columns input for table: leads */
export type Leads_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** columns and relationships of "leads_segmentation" */
export type Leads_Segmentation = {
  __typename?: 'leads_segmentation';
  campaign_id: Scalars['String'];
  created_at: Scalars['date'];
  description: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  name: Maybe<Scalars['String']>;
  sql: Maybe<Scalars['String']>;
  status: Scalars['String'];
  updated_at: Scalars['date'];
};

/** aggregated selection of "leads_segmentation" */
export type Leads_Segmentation_Aggregate = {
  __typename?: 'leads_segmentation_aggregate';
  aggregate: Maybe<Leads_Segmentation_Aggregate_Fields>;
  nodes: Array<Leads_Segmentation>;
};

/** aggregate fields of "leads_segmentation" */
export type Leads_Segmentation_Aggregate_Fields = {
  __typename?: 'leads_segmentation_aggregate_fields';
  avg: Maybe<Leads_Segmentation_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Leads_Segmentation_Max_Fields>;
  min: Maybe<Leads_Segmentation_Min_Fields>;
  stddev: Maybe<Leads_Segmentation_Stddev_Fields>;
  stddev_pop: Maybe<Leads_Segmentation_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Leads_Segmentation_Stddev_Samp_Fields>;
  sum: Maybe<Leads_Segmentation_Sum_Fields>;
  var_pop: Maybe<Leads_Segmentation_Var_Pop_Fields>;
  var_samp: Maybe<Leads_Segmentation_Var_Samp_Fields>;
  variance: Maybe<Leads_Segmentation_Variance_Fields>;
};


/** aggregate fields of "leads_segmentation" */
export type Leads_Segmentation_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Leads_Segmentation_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Leads_Segmentation_Avg_Fields = {
  __typename?: 'leads_segmentation_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "leads_segmentation". All fields are combined with a logical 'AND'. */
export type Leads_Segmentation_Bool_Exp = {
  _and: InputMaybe<Array<Leads_Segmentation_Bool_Exp>>;
  _not: InputMaybe<Leads_Segmentation_Bool_Exp>;
  _or: InputMaybe<Array<Leads_Segmentation_Bool_Exp>>;
  campaign_id: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Date_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  sql: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Date_Comparison_Exp>;
};

/** unique or primary key constraints on table "leads_segmentation" */
export enum Leads_Segmentation_Constraint {
  /** unique or primary key constraint on columns "name" */
  LeadsSegmentationNameKey = 'leads_segmentation_name_key',
  /** unique or primary key constraint on columns "id" */
  LeadsSegmentationPkey = 'leads_segmentation_pkey'
}

/** input type for incrementing numeric columns in table "leads_segmentation" */
export type Leads_Segmentation_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "leads_segmentation" */
export type Leads_Segmentation_Insert_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['date']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  sql: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate max on columns */
export type Leads_Segmentation_Max_Fields = {
  __typename?: 'leads_segmentation_max_fields';
  campaign_id: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['date']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  sql: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['date']>;
};

/** aggregate min on columns */
export type Leads_Segmentation_Min_Fields = {
  __typename?: 'leads_segmentation_min_fields';
  campaign_id: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['date']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  sql: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['date']>;
};

/** response of any mutation on the table "leads_segmentation" */
export type Leads_Segmentation_Mutation_Response = {
  __typename?: 'leads_segmentation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Leads_Segmentation>;
};

/** on_conflict condition type for table "leads_segmentation" */
export type Leads_Segmentation_On_Conflict = {
  constraint: Leads_Segmentation_Constraint;
  update_columns: Array<Leads_Segmentation_Update_Column>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};

/** Ordering options when selecting data from "leads_segmentation". */
export type Leads_Segmentation_Order_By = {
  campaign_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  sql: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: leads_segmentation */
export type Leads_Segmentation_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "leads_segmentation" */
export enum Leads_Segmentation_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Sql = 'sql',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "leads_segmentation" */
export type Leads_Segmentation_Set_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['date']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  sql: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate stddev on columns */
export type Leads_Segmentation_Stddev_Fields = {
  __typename?: 'leads_segmentation_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Leads_Segmentation_Stddev_Pop_Fields = {
  __typename?: 'leads_segmentation_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Leads_Segmentation_Stddev_Samp_Fields = {
  __typename?: 'leads_segmentation_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "leads_segmentation" */
export type Leads_Segmentation_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Leads_Segmentation_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Leads_Segmentation_Stream_Cursor_Value_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['date']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  sql: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate sum on columns */
export type Leads_Segmentation_Sum_Fields = {
  __typename?: 'leads_segmentation_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "leads_segmentation" */
export enum Leads_Segmentation_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Sql = 'sql',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Leads_Segmentation_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Leads_Segmentation_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Leads_Segmentation_Set_Input>;
  /** filter the rows which have to be updated */
  where: Leads_Segmentation_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Leads_Segmentation_Var_Pop_Fields = {
  __typename?: 'leads_segmentation_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Leads_Segmentation_Var_Samp_Fields = {
  __typename?: 'leads_segmentation_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Leads_Segmentation_Variance_Fields = {
  __typename?: 'leads_segmentation_variance_fields';
  id: Maybe<Scalars['Float']>;
};

/** select columns of table "leads" */
export enum Leads_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CompanyName = 'company_name',
  /** column name */
  ConvertedUserid = 'converted_userid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  InstantlyId = 'instantly_id',
  /** column name */
  LastName = 'last_name',
  /** column name */
  LinkedinUrl = 'linkedin_url',
  /** column name */
  Phone = 'phone',
  /** column name */
  Source = 'source',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** input type for updating data in table "leads" */
export type Leads_Set_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  company_name: InputMaybe<Scalars['String']>;
  converted_userid: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  email_domain: InputMaybe<Scalars['String']>;
  first_name: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  instantly_id: InputMaybe<Scalars['String']>;
  last_name: InputMaybe<Scalars['String']>;
  linkedin_url: InputMaybe<Scalars['String']>;
  phone: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  website: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Leads_Stddev_Fields = {
  __typename?: 'leads_stddev_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Leads_Stddev_Pop_Fields = {
  __typename?: 'leads_stddev_pop_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Leads_Stddev_Samp_Fields = {
  __typename?: 'leads_stddev_samp_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "leads" */
export type Leads_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Leads_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Leads_Stream_Cursor_Value_Input = {
  campaign_id: InputMaybe<Scalars['String']>;
  company_name: InputMaybe<Scalars['String']>;
  converted_userid: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  email: InputMaybe<Scalars['String']>;
  email_domain: InputMaybe<Scalars['String']>;
  first_name: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  instantly_id: InputMaybe<Scalars['String']>;
  last_name: InputMaybe<Scalars['String']>;
  linkedin_url: InputMaybe<Scalars['String']>;
  phone: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  website: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Leads_Sum_Fields = {
  __typename?: 'leads_sum_fields';
  converted_userid: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "leads" */
export enum Leads_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CompanyName = 'company_name',
  /** column name */
  ConvertedUserid = 'converted_userid',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  InstantlyId = 'instantly_id',
  /** column name */
  LastName = 'last_name',
  /** column name */
  LinkedinUrl = 'linkedin_url',
  /** column name */
  Phone = 'phone',
  /** column name */
  Source = 'source',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

export type Leads_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Leads_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Leads_Set_Input>;
  /** filter the rows which have to be updated */
  where: Leads_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Leads_Var_Pop_Fields = {
  __typename?: 'leads_var_pop_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Leads_Var_Samp_Fields = {
  __typename?: 'leads_var_samp_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Leads_Variance_Fields = {
  __typename?: 'leads_variance_fields';
  converted_userid: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "likes" */
export type Likes = {
  __typename?: 'likes';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  created_by_user: Maybe<Users_Public>;
  created_by_user_id: Scalars['Int'];
  id: Scalars['Int'];
  /** An object relationship */
  note: Maybe<Notes>;
  note_id: Scalars['Int'];
};

/** aggregated selection of "likes" */
export type Likes_Aggregate = {
  __typename?: 'likes_aggregate';
  aggregate: Maybe<Likes_Aggregate_Fields>;
  nodes: Array<Likes>;
};

export type Likes_Aggregate_Bool_Exp = {
  count: InputMaybe<Likes_Aggregate_Bool_Exp_Count>;
};

export type Likes_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Likes_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Likes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "likes" */
export type Likes_Aggregate_Fields = {
  __typename?: 'likes_aggregate_fields';
  avg: Maybe<Likes_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Likes_Max_Fields>;
  min: Maybe<Likes_Min_Fields>;
  stddev: Maybe<Likes_Stddev_Fields>;
  stddev_pop: Maybe<Likes_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Likes_Stddev_Samp_Fields>;
  sum: Maybe<Likes_Sum_Fields>;
  var_pop: Maybe<Likes_Var_Pop_Fields>;
  var_samp: Maybe<Likes_Var_Samp_Fields>;
  variance: Maybe<Likes_Variance_Fields>;
};


/** aggregate fields of "likes" */
export type Likes_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Likes_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "likes" */
export type Likes_Aggregate_Order_By = {
  avg: InputMaybe<Likes_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Likes_Max_Order_By>;
  min: InputMaybe<Likes_Min_Order_By>;
  stddev: InputMaybe<Likes_Stddev_Order_By>;
  stddev_pop: InputMaybe<Likes_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Likes_Stddev_Samp_Order_By>;
  sum: InputMaybe<Likes_Sum_Order_By>;
  var_pop: InputMaybe<Likes_Var_Pop_Order_By>;
  var_samp: InputMaybe<Likes_Var_Samp_Order_By>;
  variance: InputMaybe<Likes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "likes" */
export type Likes_Arr_Rel_Insert_Input = {
  data: Array<Likes_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Likes_On_Conflict>;
};

/** aggregate avg on columns */
export type Likes_Avg_Fields = {
  __typename?: 'likes_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "likes" */
export type Likes_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "likes". All fields are combined with a logical 'AND'. */
export type Likes_Bool_Exp = {
  _and: InputMaybe<Array<Likes_Bool_Exp>>;
  _not: InputMaybe<Likes_Bool_Exp>;
  _or: InputMaybe<Array<Likes_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by_user: InputMaybe<Users_Public_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  note: InputMaybe<Notes_Bool_Exp>;
  note_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "likes" */
export enum Likes_Constraint {
  /** unique or primary key constraint on columns "id" */
  LikesPkey = 'likes_pkey'
}

/** input type for incrementing numeric columns in table "likes" */
export type Likes_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "likes" */
export type Likes_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note: InputMaybe<Notes_Obj_Rel_Insert_Input>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Likes_Max_Fields = {
  __typename?: 'likes_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "likes" */
export type Likes_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Likes_Min_Fields = {
  __typename?: 'likes_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "likes" */
export type Likes_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "likes" */
export type Likes_Mutation_Response = {
  __typename?: 'likes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Likes>;
};

/** on_conflict condition type for table "likes" */
export type Likes_On_Conflict = {
  constraint: Likes_Constraint;
  update_columns: Array<Likes_Update_Column>;
  where: InputMaybe<Likes_Bool_Exp>;
};

/** Ordering options when selecting data from "likes". */
export type Likes_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user: InputMaybe<Users_Public_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note: InputMaybe<Notes_Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: likes */
export type Likes_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "likes" */
export enum Likes_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  NoteId = 'note_id'
}

/** input type for updating data in table "likes" */
export type Likes_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Likes_Stddev_Fields = {
  __typename?: 'likes_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "likes" */
export type Likes_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Likes_Stddev_Pop_Fields = {
  __typename?: 'likes_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "likes" */
export type Likes_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Likes_Stddev_Samp_Fields = {
  __typename?: 'likes_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "likes" */
export type Likes_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "likes" */
export type Likes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Likes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Likes_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Likes_Sum_Fields = {
  __typename?: 'likes_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "likes" */
export type Likes_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** update columns of table "likes" */
export enum Likes_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Id = 'id',
  /** column name */
  NoteId = 'note_id'
}

export type Likes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Likes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Likes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Likes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Likes_Var_Pop_Fields = {
  __typename?: 'likes_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "likes" */
export type Likes_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Likes_Var_Samp_Fields = {
  __typename?: 'likes_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "likes" */
export type Likes_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Likes_Variance_Fields = {
  __typename?: 'likes_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  note_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "likes" */
export type Likes_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note_id: InputMaybe<Order_By>;
};

/** columns and relationships of "list_members" */
export type List_Members = {
  __typename?: 'list_members';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  list: Lists;
  list_id: Scalars['Int'];
  member_type: Scalars['String'];
  /** An object relationship */
  user: Maybe<Users_Public>;
  user_id: Scalars['Int'];
};

/** aggregated selection of "list_members" */
export type List_Members_Aggregate = {
  __typename?: 'list_members_aggregate';
  aggregate: Maybe<List_Members_Aggregate_Fields>;
  nodes: Array<List_Members>;
};

export type List_Members_Aggregate_Bool_Exp = {
  count: InputMaybe<List_Members_Aggregate_Bool_Exp_Count>;
};

export type List_Members_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<List_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<List_Members_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "list_members" */
export type List_Members_Aggregate_Fields = {
  __typename?: 'list_members_aggregate_fields';
  avg: Maybe<List_Members_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<List_Members_Max_Fields>;
  min: Maybe<List_Members_Min_Fields>;
  stddev: Maybe<List_Members_Stddev_Fields>;
  stddev_pop: Maybe<List_Members_Stddev_Pop_Fields>;
  stddev_samp: Maybe<List_Members_Stddev_Samp_Fields>;
  sum: Maybe<List_Members_Sum_Fields>;
  var_pop: Maybe<List_Members_Var_Pop_Fields>;
  var_samp: Maybe<List_Members_Var_Samp_Fields>;
  variance: Maybe<List_Members_Variance_Fields>;
};


/** aggregate fields of "list_members" */
export type List_Members_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<List_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "list_members" */
export type List_Members_Aggregate_Order_By = {
  avg: InputMaybe<List_Members_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<List_Members_Max_Order_By>;
  min: InputMaybe<List_Members_Min_Order_By>;
  stddev: InputMaybe<List_Members_Stddev_Order_By>;
  stddev_pop: InputMaybe<List_Members_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<List_Members_Stddev_Samp_Order_By>;
  sum: InputMaybe<List_Members_Sum_Order_By>;
  var_pop: InputMaybe<List_Members_Var_Pop_Order_By>;
  var_samp: InputMaybe<List_Members_Var_Samp_Order_By>;
  variance: InputMaybe<List_Members_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "list_members" */
export type List_Members_Arr_Rel_Insert_Input = {
  data: Array<List_Members_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<List_Members_On_Conflict>;
};

/** aggregate avg on columns */
export type List_Members_Avg_Fields = {
  __typename?: 'list_members_avg_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "list_members" */
export type List_Members_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "list_members". All fields are combined with a logical 'AND'. */
export type List_Members_Bool_Exp = {
  _and: InputMaybe<Array<List_Members_Bool_Exp>>;
  _not: InputMaybe<List_Members_Bool_Exp>;
  _or: InputMaybe<Array<List_Members_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list: InputMaybe<Lists_Bool_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  member_type: InputMaybe<String_Comparison_Exp>;
  user: InputMaybe<Users_Public_Bool_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "list_members" */
export enum List_Members_Constraint {
  /** unique or primary key constraint on columns "user_id", "list_id" */
  ListMembersListIdUserIdKey = 'list_members_list_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  ListMembersPkey = 'list_members_pkey'
}

/** input type for incrementing numeric columns in table "list_members" */
export type List_Members_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "list_members" */
export type List_Members_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list: InputMaybe<Lists_Obj_Rel_Insert_Input>;
  list_id: InputMaybe<Scalars['Int']>;
  member_type: InputMaybe<Scalars['String']>;
  user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type List_Members_Max_Fields = {
  __typename?: 'list_members_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  member_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "list_members" */
export type List_Members_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  member_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type List_Members_Min_Fields = {
  __typename?: 'list_members_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  member_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "list_members" */
export type List_Members_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  member_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "list_members" */
export type List_Members_Mutation_Response = {
  __typename?: 'list_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<List_Members>;
};

/** input type for inserting object relation for remote table "list_members" */
export type List_Members_Obj_Rel_Insert_Input = {
  data: List_Members_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<List_Members_On_Conflict>;
};

/** on_conflict condition type for table "list_members" */
export type List_Members_On_Conflict = {
  constraint: List_Members_Constraint;
  update_columns: Array<List_Members_Update_Column>;
  where: InputMaybe<List_Members_Bool_Exp>;
};

/** Ordering options when selecting data from "list_members". */
export type List_Members_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list: InputMaybe<Lists_Order_By>;
  list_id: InputMaybe<Order_By>;
  member_type: InputMaybe<Order_By>;
  user: InputMaybe<Users_Public_Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: list_members */
export type List_Members_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "list_members" */
export enum List_Members_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  MemberType = 'member_type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "list_members" */
export type List_Members_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  member_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type List_Members_Stddev_Fields = {
  __typename?: 'list_members_stddev_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "list_members" */
export type List_Members_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type List_Members_Stddev_Pop_Fields = {
  __typename?: 'list_members_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "list_members" */
export type List_Members_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type List_Members_Stddev_Samp_Fields = {
  __typename?: 'list_members_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "list_members" */
export type List_Members_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "list_members" */
export type List_Members_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: List_Members_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type List_Members_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  member_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type List_Members_Sum_Fields = {
  __typename?: 'list_members_sum_fields';
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "list_members" */
export type List_Members_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** update columns of table "list_members" */
export enum List_Members_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  MemberType = 'member_type',
  /** column name */
  UserId = 'user_id'
}

export type List_Members_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<List_Members_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<List_Members_Set_Input>;
  /** filter the rows which have to be updated */
  where: List_Members_Bool_Exp;
};

/** aggregate var_pop on columns */
export type List_Members_Var_Pop_Fields = {
  __typename?: 'list_members_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "list_members" */
export type List_Members_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type List_Members_Var_Samp_Fields = {
  __typename?: 'list_members_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "list_members" */
export type List_Members_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type List_Members_Variance_Fields = {
  __typename?: 'list_members_variance_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "list_members" */
export type List_Members_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** columns and relationships of "list_user_groups" */
export type List_User_Groups = {
  __typename?: 'list_user_groups';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  list: Maybe<Lists>;
  list_id: Scalars['Int'];
  /** An object relationship */
  user_group: Maybe<User_Groups>;
  user_group_id: Scalars['Int'];
};

/** aggregated selection of "list_user_groups" */
export type List_User_Groups_Aggregate = {
  __typename?: 'list_user_groups_aggregate';
  aggregate: Maybe<List_User_Groups_Aggregate_Fields>;
  nodes: Array<List_User_Groups>;
};

export type List_User_Groups_Aggregate_Bool_Exp = {
  count: InputMaybe<List_User_Groups_Aggregate_Bool_Exp_Count>;
};

export type List_User_Groups_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<List_User_Groups_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<List_User_Groups_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "list_user_groups" */
export type List_User_Groups_Aggregate_Fields = {
  __typename?: 'list_user_groups_aggregate_fields';
  avg: Maybe<List_User_Groups_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<List_User_Groups_Max_Fields>;
  min: Maybe<List_User_Groups_Min_Fields>;
  stddev: Maybe<List_User_Groups_Stddev_Fields>;
  stddev_pop: Maybe<List_User_Groups_Stddev_Pop_Fields>;
  stddev_samp: Maybe<List_User_Groups_Stddev_Samp_Fields>;
  sum: Maybe<List_User_Groups_Sum_Fields>;
  var_pop: Maybe<List_User_Groups_Var_Pop_Fields>;
  var_samp: Maybe<List_User_Groups_Var_Samp_Fields>;
  variance: Maybe<List_User_Groups_Variance_Fields>;
};


/** aggregate fields of "list_user_groups" */
export type List_User_Groups_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<List_User_Groups_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "list_user_groups" */
export type List_User_Groups_Aggregate_Order_By = {
  avg: InputMaybe<List_User_Groups_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<List_User_Groups_Max_Order_By>;
  min: InputMaybe<List_User_Groups_Min_Order_By>;
  stddev: InputMaybe<List_User_Groups_Stddev_Order_By>;
  stddev_pop: InputMaybe<List_User_Groups_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<List_User_Groups_Stddev_Samp_Order_By>;
  sum: InputMaybe<List_User_Groups_Sum_Order_By>;
  var_pop: InputMaybe<List_User_Groups_Var_Pop_Order_By>;
  var_samp: InputMaybe<List_User_Groups_Var_Samp_Order_By>;
  variance: InputMaybe<List_User_Groups_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "list_user_groups" */
export type List_User_Groups_Arr_Rel_Insert_Input = {
  data: Array<List_User_Groups_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<List_User_Groups_On_Conflict>;
};

/** aggregate avg on columns */
export type List_User_Groups_Avg_Fields = {
  __typename?: 'list_user_groups_avg_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "list_user_groups" */
export type List_User_Groups_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "list_user_groups". All fields are combined with a logical 'AND'. */
export type List_User_Groups_Bool_Exp = {
  _and: InputMaybe<Array<List_User_Groups_Bool_Exp>>;
  _not: InputMaybe<List_User_Groups_Bool_Exp>;
  _or: InputMaybe<Array<List_User_Groups_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list: InputMaybe<Lists_Bool_Exp>;
  list_id: InputMaybe<Int_Comparison_Exp>;
  user_group: InputMaybe<User_Groups_Bool_Exp>;
  user_group_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "list_user_groups" */
export enum List_User_Groups_Constraint {
  /** unique or primary key constraint on columns "id" */
  ListUserGroupsPkey = 'list_user_groups_pkey'
}

/** input type for incrementing numeric columns in table "list_user_groups" */
export type List_User_Groups_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "list_user_groups" */
export type List_User_Groups_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list: InputMaybe<Lists_Obj_Rel_Insert_Input>;
  list_id: InputMaybe<Scalars['Int']>;
  user_group: InputMaybe<User_Groups_Obj_Rel_Insert_Input>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type List_User_Groups_Max_Fields = {
  __typename?: 'list_user_groups_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "list_user_groups" */
export type List_User_Groups_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type List_User_Groups_Min_Fields = {
  __typename?: 'list_user_groups_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "list_user_groups" */
export type List_User_Groups_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "list_user_groups" */
export type List_User_Groups_Mutation_Response = {
  __typename?: 'list_user_groups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<List_User_Groups>;
};

/** on_conflict condition type for table "list_user_groups" */
export type List_User_Groups_On_Conflict = {
  constraint: List_User_Groups_Constraint;
  update_columns: Array<List_User_Groups_Update_Column>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};

/** Ordering options when selecting data from "list_user_groups". */
export type List_User_Groups_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list: InputMaybe<Lists_Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group: InputMaybe<User_Groups_Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: list_user_groups */
export type List_User_Groups_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "list_user_groups" */
export enum List_User_Groups_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  UserGroupId = 'user_group_id'
}

/** input type for updating data in table "list_user_groups" */
export type List_User_Groups_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type List_User_Groups_Stddev_Fields = {
  __typename?: 'list_user_groups_stddev_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "list_user_groups" */
export type List_User_Groups_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type List_User_Groups_Stddev_Pop_Fields = {
  __typename?: 'list_user_groups_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "list_user_groups" */
export type List_User_Groups_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type List_User_Groups_Stddev_Samp_Fields = {
  __typename?: 'list_user_groups_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "list_user_groups" */
export type List_User_Groups_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "list_user_groups" */
export type List_User_Groups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: List_User_Groups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type List_User_Groups_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  list_id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type List_User_Groups_Sum_Fields = {
  __typename?: 'list_user_groups_sum_fields';
  id: Maybe<Scalars['Int']>;
  list_id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "list_user_groups" */
export type List_User_Groups_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** update columns of table "list_user_groups" */
export enum List_User_Groups_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ListId = 'list_id',
  /** column name */
  UserGroupId = 'user_group_id'
}

export type List_User_Groups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<List_User_Groups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<List_User_Groups_Set_Input>;
  /** filter the rows which have to be updated */
  where: List_User_Groups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type List_User_Groups_Var_Pop_Fields = {
  __typename?: 'list_user_groups_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "list_user_groups" */
export type List_User_Groups_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type List_User_Groups_Var_Samp_Fields = {
  __typename?: 'list_user_groups_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "list_user_groups" */
export type List_User_Groups_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type List_User_Groups_Variance_Fields = {
  __typename?: 'list_user_groups_variance_fields';
  id: Maybe<Scalars['Float']>;
  list_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "list_user_groups" */
export type List_User_Groups_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  list_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** columns and relationships of "lists" */
export type Lists = {
  __typename?: 'lists';
  created_at: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  created_by: Maybe<Users_Public>;
  created_by_id: Scalars['Int'];
  description: Maybe<Scalars['String']>;
  /** An array relationship */
  follows_companies: Array<Follows_Companies>;
  /** An aggregate relationship */
  follows_companies_aggregate: Follows_Companies_Aggregate;
  /** An array relationship */
  follows_people: Array<Follows_People>;
  /** An aggregate relationship */
  follows_people_aggregate: Follows_People_Aggregate;
  /** An array relationship */
  follows_vcfirms: Array<Follows_Vc_Firms>;
  /** An aggregate relationship */
  follows_vcfirms_aggregate: Follows_Vc_Firms_Aggregate;
  id: Scalars['Int'];
  /** An array relationship */
  list_members: Array<List_Members>;
  /** An aggregate relationship */
  list_members_aggregate: List_Members_Aggregate;
  name: Scalars['String'];
  public: Maybe<Scalars['Boolean']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  user_groups: Array<List_User_Groups>;
  /** An aggregate relationship */
  user_groups_aggregate: List_User_Groups_Aggregate;
};


/** columns and relationships of "lists" */
export type ListsFollows_CompaniesArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsFollows_Companies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsFollows_PeopleArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsFollows_People_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsFollows_VcfirmsArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsFollows_Vcfirms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsList_MembersArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsList_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsUser_GroupsArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


/** columns and relationships of "lists" */
export type ListsUser_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};

/** aggregated selection of "lists" */
export type Lists_Aggregate = {
  __typename?: 'lists_aggregate';
  aggregate: Maybe<Lists_Aggregate_Fields>;
  nodes: Array<Lists>;
};

/** aggregate fields of "lists" */
export type Lists_Aggregate_Fields = {
  __typename?: 'lists_aggregate_fields';
  avg: Maybe<Lists_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Lists_Max_Fields>;
  min: Maybe<Lists_Min_Fields>;
  stddev: Maybe<Lists_Stddev_Fields>;
  stddev_pop: Maybe<Lists_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Lists_Stddev_Samp_Fields>;
  sum: Maybe<Lists_Sum_Fields>;
  var_pop: Maybe<Lists_Var_Pop_Fields>;
  var_samp: Maybe<Lists_Var_Samp_Fields>;
  variance: Maybe<Lists_Variance_Fields>;
};


/** aggregate fields of "lists" */
export type Lists_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Lists_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Lists_Avg_Fields = {
  __typename?: 'lists_avg_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "lists". All fields are combined with a logical 'AND'. */
export type Lists_Bool_Exp = {
  _and: InputMaybe<Array<Lists_Bool_Exp>>;
  _not: InputMaybe<Lists_Bool_Exp>;
  _or: InputMaybe<Array<Lists_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by: InputMaybe<Users_Public_Bool_Exp>;
  created_by_id: InputMaybe<Int_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  follows_companies: InputMaybe<Follows_Companies_Bool_Exp>;
  follows_companies_aggregate: InputMaybe<Follows_Companies_Aggregate_Bool_Exp>;
  follows_people: InputMaybe<Follows_People_Bool_Exp>;
  follows_people_aggregate: InputMaybe<Follows_People_Aggregate_Bool_Exp>;
  follows_vcfirms: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
  follows_vcfirms_aggregate: InputMaybe<Follows_Vc_Firms_Aggregate_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list_members: InputMaybe<List_Members_Bool_Exp>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Bool_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  public: InputMaybe<Boolean_Comparison_Exp>;
  total_no_of_resources: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  user_groups: InputMaybe<List_User_Groups_Bool_Exp>;
  user_groups_aggregate: InputMaybe<List_User_Groups_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "lists" */
export enum Lists_Constraint {
  /** unique or primary key constraint on columns "name", "created_by_id" */
  ListsCreatedByIdNameKey = 'lists_created_by_id_name_key',
  /** unique or primary key constraint on columns "id" */
  ListsPkey = 'lists_pkey'
}

/** input type for incrementing numeric columns in table "lists" */
export type Lists_Inc_Input = {
  created_by_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "lists" */
export type Lists_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  created_by_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  follows_companies: InputMaybe<Follows_Companies_Arr_Rel_Insert_Input>;
  follows_people: InputMaybe<Follows_People_Arr_Rel_Insert_Input>;
  follows_vcfirms: InputMaybe<Follows_Vc_Firms_Arr_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  list_members: InputMaybe<List_Members_Arr_Rel_Insert_Input>;
  name: InputMaybe<Scalars['String']>;
  public: InputMaybe<Scalars['Boolean']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_groups: InputMaybe<List_User_Groups_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Lists_Max_Fields = {
  __typename?: 'lists_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_id: Maybe<Scalars['Int']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Lists_Min_Fields = {
  __typename?: 'lists_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_id: Maybe<Scalars['Int']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "lists" */
export type Lists_Mutation_Response = {
  __typename?: 'lists_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Lists>;
};

/** input type for inserting object relation for remote table "lists" */
export type Lists_Obj_Rel_Insert_Input = {
  data: Lists_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Lists_On_Conflict>;
};

/** on_conflict condition type for table "lists" */
export type Lists_On_Conflict = {
  constraint: Lists_Constraint;
  update_columns: Array<Lists_Update_Column>;
  where: InputMaybe<Lists_Bool_Exp>;
};

/** Ordering options when selecting data from "lists". */
export type Lists_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Users_Public_Order_By>;
  created_by_id: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  follows_companies_aggregate: InputMaybe<Follows_Companies_Aggregate_Order_By>;
  follows_people_aggregate: InputMaybe<Follows_People_Aggregate_Order_By>;
  follows_vcfirms_aggregate: InputMaybe<Follows_Vc_Firms_Aggregate_Order_By>;
  id: InputMaybe<Order_By>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Order_By>;
  name: InputMaybe<Order_By>;
  public: InputMaybe<Order_By>;
  total_no_of_resources: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_groups_aggregate: InputMaybe<List_User_Groups_Aggregate_Order_By>;
};

/** primary key columns input for table: lists */
export type Lists_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "lists" */
export enum Lists_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedById = 'created_by_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "lists" */
export type Lists_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  public: InputMaybe<Scalars['Boolean']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Lists_Stddev_Fields = {
  __typename?: 'lists_stddev_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** aggregate stddev_pop on columns */
export type Lists_Stddev_Pop_Fields = {
  __typename?: 'lists_stddev_pop_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** aggregate stddev_samp on columns */
export type Lists_Stddev_Samp_Fields = {
  __typename?: 'lists_stddev_samp_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** Streaming cursor of the table "lists" */
export type Lists_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lists_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lists_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  public: InputMaybe<Scalars['Boolean']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Lists_Sum_Fields = {
  __typename?: 'lists_sum_fields';
  created_by_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** update columns of table "lists" */
export enum Lists_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedById = 'created_by_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Lists_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Lists_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Lists_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lists_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Lists_Var_Pop_Fields = {
  __typename?: 'lists_var_pop_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** aggregate var_samp on columns */
export type Lists_Var_Samp_Fields = {
  __typename?: 'lists_var_samp_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** aggregate variance on columns */
export type Lists_Variance_Fields = {
  __typename?: 'lists_variance_fields';
  created_by_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  /** Computed field to get total no. of companies in a list */
  total_no_of_resources: Maybe<Scalars['Int']>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "actions" */
  delete_actions: Maybe<Actions_Mutation_Response>;
  /** delete single row from the table: "actions" */
  delete_actions_by_pk: Maybe<Actions>;
  /** delete data from the table: "allowed_emails" */
  delete_allowed_emails: Maybe<Allowed_Emails_Mutation_Response>;
  /** delete single row from the table: "allowed_emails" */
  delete_allowed_emails_by_pk: Maybe<Allowed_Emails>;
  /** delete data from the table: "application_meta" */
  delete_application_meta: Maybe<Application_Meta_Mutation_Response>;
  /** delete single row from the table: "application_meta" */
  delete_application_meta_by_pk: Maybe<Application_Meta>;
  /** delete data from the table: "billing_org" */
  delete_billing_org: Maybe<Billing_Org_Mutation_Response>;
  /** delete single row from the table: "billing_org" */
  delete_billing_org_by_pk: Maybe<Billing_Org>;
  /** delete data from the table: "blockchains" */
  delete_blockchains: Maybe<Blockchains_Mutation_Response>;
  /** delete single row from the table: "blockchains" */
  delete_blockchains_by_pk: Maybe<Blockchains>;
  /** delete data from the table: "coins" */
  delete_coins: Maybe<Coins_Mutation_Response>;
  /** delete single row from the table: "coins" */
  delete_coins_by_pk: Maybe<Coins>;
  /** delete data from the table: "comments" */
  delete_comments: Maybe<Comments_Mutation_Response>;
  /** delete single row from the table: "comments" */
  delete_comments_by_pk: Maybe<Comments>;
  /** delete data from the table: "companies" */
  delete_companies: Maybe<Companies_Mutation_Response>;
  /** delete single row from the table: "companies" */
  delete_companies_by_pk: Maybe<Companies>;
  /** delete data from the table: "companies_edit_access" */
  delete_companies_edit_access: Maybe<Companies_Edit_Access_Mutation_Response>;
  /** delete data from the table: "data_actions" */
  delete_data_actions: Maybe<Data_Actions_Mutation_Response>;
  /** delete single row from the table: "data_actions" */
  delete_data_actions_by_pk: Maybe<Data_Actions>;
  /** delete data from the table: "data_discard" */
  delete_data_discard: Maybe<Data_Discard_Mutation_Response>;
  /** delete single row from the table: "data_discard" */
  delete_data_discard_by_pk: Maybe<Data_Discard>;
  /** delete data from the table: "data_fields" */
  delete_data_fields: Maybe<Data_Fields_Mutation_Response>;
  /** delete single row from the table: "data_fields" */
  delete_data_fields_by_pk: Maybe<Data_Fields>;
  /** delete data from the table: "data_partners" */
  delete_data_partners: Maybe<Data_Partners_Mutation_Response>;
  /** delete single row from the table: "data_partners" */
  delete_data_partners_by_pk: Maybe<Data_Partners>;
  /** delete data from the table: "data_raw" */
  delete_data_raw: Maybe<Data_Raw_Mutation_Response>;
  /** delete single row from the table: "data_raw" */
  delete_data_raw_by_pk: Maybe<Data_Raw>;
  /** delete data from the table: "data_runs" */
  delete_data_runs: Maybe<Data_Runs_Mutation_Response>;
  /** delete single row from the table: "data_runs" */
  delete_data_runs_by_pk: Maybe<Data_Runs>;
  /** delete data from the table: "disabled_emails" */
  delete_disabled_emails: Maybe<Disabled_Emails_Mutation_Response>;
  /** delete single row from the table: "disabled_emails" */
  delete_disabled_emails_by_pk: Maybe<Disabled_Emails>;
  /** delete data from the table: "event_organization" */
  delete_event_organization: Maybe<Event_Organization_Mutation_Response>;
  /** delete single row from the table: "event_organization" */
  delete_event_organization_by_pk: Maybe<Event_Organization>;
  /** delete data from the table: "event_person" */
  delete_event_person: Maybe<Event_Person_Mutation_Response>;
  /** delete single row from the table: "event_person" */
  delete_event_person_by_pk: Maybe<Event_Person>;
  /** delete data from the table: "events" */
  delete_events: Maybe<Events_Mutation_Response>;
  /** delete single row from the table: "events" */
  delete_events_by_pk: Maybe<Events>;
  /** delete data from the table: "follows" */
  delete_follows: Maybe<Follows_Mutation_Response>;
  /** delete single row from the table: "follows" */
  delete_follows_by_pk: Maybe<Follows>;
  /** delete data from the table: "follows_companies" */
  delete_follows_companies: Maybe<Follows_Companies_Mutation_Response>;
  /** delete data from the table: "follows_people" */
  delete_follows_people: Maybe<Follows_People_Mutation_Response>;
  /** delete data from the table: "follows_vc_firms" */
  delete_follows_vc_firms: Maybe<Follows_Vc_Firms_Mutation_Response>;
  /** delete data from the table: "investment_rounds" */
  delete_investment_rounds: Maybe<Investment_Rounds_Mutation_Response>;
  /** delete single row from the table: "investment_rounds" */
  delete_investment_rounds_by_pk: Maybe<Investment_Rounds>;
  /** delete data from the table: "investments" */
  delete_investments: Maybe<Investments_Mutation_Response>;
  /** delete single row from the table: "investments" */
  delete_investments_by_pk: Maybe<Investments>;
  /** delete data from the table: "investors" */
  delete_investors: Maybe<Investors_Mutation_Response>;
  /** delete single row from the table: "investors" */
  delete_investors_by_pk: Maybe<Investors>;
  /** delete data from the table: "invited_people" */
  delete_invited_people: Maybe<Invited_People_Mutation_Response>;
  /** delete single row from the table: "invited_people" */
  delete_invited_people_by_pk: Maybe<Invited_People>;
  /** delete data from the table: "leads" */
  delete_leads: Maybe<Leads_Mutation_Response>;
  /** delete single row from the table: "leads" */
  delete_leads_by_pk: Maybe<Leads>;
  /** delete data from the table: "leads_segmentation" */
  delete_leads_segmentation: Maybe<Leads_Segmentation_Mutation_Response>;
  /** delete single row from the table: "leads_segmentation" */
  delete_leads_segmentation_by_pk: Maybe<Leads_Segmentation>;
  /** delete data from the table: "likes" */
  delete_likes: Maybe<Likes_Mutation_Response>;
  /** delete single row from the table: "likes" */
  delete_likes_by_pk: Maybe<Likes>;
  /** delete data from the table: "list_members" */
  delete_list_members: Maybe<List_Members_Mutation_Response>;
  /** delete single row from the table: "list_members" */
  delete_list_members_by_pk: Maybe<List_Members>;
  /** delete data from the table: "list_user_groups" */
  delete_list_user_groups: Maybe<List_User_Groups_Mutation_Response>;
  /** delete single row from the table: "list_user_groups" */
  delete_list_user_groups_by_pk: Maybe<List_User_Groups>;
  /** delete data from the table: "lists" */
  delete_lists: Maybe<Lists_Mutation_Response>;
  /** delete single row from the table: "lists" */
  delete_lists_by_pk: Maybe<Lists>;
  /** delete data from the table: "news" */
  delete_news: Maybe<News_Mutation_Response>;
  /** delete single row from the table: "news" */
  delete_news_by_pk: Maybe<News>;
  /** delete data from the table: "news_organizations" */
  delete_news_organizations: Maybe<News_Organizations_Mutation_Response>;
  /** delete single row from the table: "news_organizations" */
  delete_news_organizations_by_pk: Maybe<News_Organizations>;
  /** delete data from the table: "news_person" */
  delete_news_person: Maybe<News_Person_Mutation_Response>;
  /** delete single row from the table: "news_person" */
  delete_news_person_by_pk: Maybe<News_Person>;
  /** delete data from the table: "news_related_organizations" */
  delete_news_related_organizations: Maybe<News_Related_Organizations_Mutation_Response>;
  /** delete single row from the table: "news_related_organizations" */
  delete_news_related_organizations_by_pk: Maybe<News_Related_Organizations>;
  /** delete data from the table: "news_related_person" */
  delete_news_related_person: Maybe<News_Related_Person_Mutation_Response>;
  /** delete single row from the table: "news_related_person" */
  delete_news_related_person_by_pk: Maybe<News_Related_Person>;
  /** delete data from the table: "notes" */
  delete_notes: Maybe<Notes_Mutation_Response>;
  /** delete single row from the table: "notes" */
  delete_notes_by_pk: Maybe<Notes>;
  /** delete data from the table: "notification_actions" */
  delete_notification_actions: Maybe<Notification_Actions_Mutation_Response>;
  /** delete single row from the table: "notification_actions" */
  delete_notification_actions_by_pk: Maybe<Notification_Actions>;
  /** delete data from the table: "notifications" */
  delete_notifications: Maybe<Notifications_Mutation_Response>;
  /** delete single row from the table: "notifications" */
  delete_notifications_by_pk: Maybe<Notifications>;
  /** delete data from the table: "people" */
  delete_people: Maybe<People_Mutation_Response>;
  /** delete single row from the table: "people" */
  delete_people_by_pk: Maybe<People>;
  /** delete data from the table: "people_computed_data" */
  delete_people_computed_data: Maybe<People_Computed_Data_Mutation_Response>;
  /** delete single row from the table: "people_computed_data" */
  delete_people_computed_data_by_pk: Maybe<People_Computed_Data>;
  /** delete data from the table: "reset_passwords" */
  delete_reset_passwords: Maybe<Reset_Passwords_Mutation_Response>;
  /** delete single row from the table: "reset_passwords" */
  delete_reset_passwords_by_pk: Maybe<Reset_Passwords>;
  /** delete data from the table: "resource_edit_access" */
  delete_resource_edit_access: Maybe<Resource_Edit_Access_Mutation_Response>;
  /** delete single row from the table: "resource_edit_access" */
  delete_resource_edit_access_by_pk: Maybe<Resource_Edit_Access>;
  /** delete data from the table: "resource_links" */
  delete_resource_links: Maybe<Resource_Links_Mutation_Response>;
  /** delete single row from the table: "resource_links" */
  delete_resource_links_by_pk: Maybe<Resource_Links>;
  /** delete data from the table: "team_members" */
  delete_team_members: Maybe<Team_Members_Mutation_Response>;
  /** delete single row from the table: "team_members" */
  delete_team_members_by_pk: Maybe<Team_Members>;
  /** delete data from the table: "user_group_invites" */
  delete_user_group_invites: Maybe<User_Group_Invites_Mutation_Response>;
  /** delete single row from the table: "user_group_invites" */
  delete_user_group_invites_by_pk: Maybe<User_Group_Invites>;
  /** delete data from the table: "user_group_members" */
  delete_user_group_members: Maybe<User_Group_Members_Mutation_Response>;
  /** delete single row from the table: "user_group_members" */
  delete_user_group_members_by_pk: Maybe<User_Group_Members>;
  /** delete data from the table: "user_groups" */
  delete_user_groups: Maybe<User_Groups_Mutation_Response>;
  /** delete single row from the table: "user_groups" */
  delete_user_groups_by_pk: Maybe<User_Groups>;
  /** delete data from the table: "user_tokens" */
  delete_user_tokens: Maybe<User_Tokens_Mutation_Response>;
  /** delete single row from the table: "user_tokens" */
  delete_user_tokens_by_pk: Maybe<User_Tokens>;
  /** delete data from the table: "user_transactions" */
  delete_user_transactions: Maybe<User_Transactions_Mutation_Response>;
  /** delete single row from the table: "user_transactions" */
  delete_user_transactions_by_pk: Maybe<User_Transactions>;
  /** delete data from the table: "users" */
  delete_users: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk: Maybe<Users>;
  /** delete data from the table: "users_public" */
  delete_users_public: Maybe<Users_Public_Mutation_Response>;
  /** delete data from the table: "vc_firms" */
  delete_vc_firms: Maybe<Vc_Firms_Mutation_Response>;
  /** delete single row from the table: "vc_firms" */
  delete_vc_firms_by_pk: Maybe<Vc_Firms>;
  /** delete data from the table: "vc_firms_edit_access" */
  delete_vc_firms_edit_access: Maybe<Vc_Firms_Edit_Access_Mutation_Response>;
  /** delete data from the table: "waitlist_emails" */
  delete_waitlist_emails: Maybe<Waitlist_Emails_Mutation_Response>;
  /** delete single row from the table: "waitlist_emails" */
  delete_waitlist_emails_by_pk: Maybe<Waitlist_Emails>;
  /** insert data into the table: "actions" */
  insert_actions: Maybe<Actions_Mutation_Response>;
  /** insert a single row into the table: "actions" */
  insert_actions_one: Maybe<Actions>;
  /** insert data into the table: "allowed_emails" */
  insert_allowed_emails: Maybe<Allowed_Emails_Mutation_Response>;
  /** insert a single row into the table: "allowed_emails" */
  insert_allowed_emails_one: Maybe<Allowed_Emails>;
  /** insert data into the table: "application_meta" */
  insert_application_meta: Maybe<Application_Meta_Mutation_Response>;
  /** insert a single row into the table: "application_meta" */
  insert_application_meta_one: Maybe<Application_Meta>;
  /** insert data into the table: "billing_org" */
  insert_billing_org: Maybe<Billing_Org_Mutation_Response>;
  /** insert a single row into the table: "billing_org" */
  insert_billing_org_one: Maybe<Billing_Org>;
  /** insert data into the table: "blockchains" */
  insert_blockchains: Maybe<Blockchains_Mutation_Response>;
  /** insert a single row into the table: "blockchains" */
  insert_blockchains_one: Maybe<Blockchains>;
  /** insert data into the table: "coins" */
  insert_coins: Maybe<Coins_Mutation_Response>;
  /** insert a single row into the table: "coins" */
  insert_coins_one: Maybe<Coins>;
  /** insert data into the table: "comments" */
  insert_comments: Maybe<Comments_Mutation_Response>;
  /** insert a single row into the table: "comments" */
  insert_comments_one: Maybe<Comments>;
  /** insert data into the table: "companies" */
  insert_companies: Maybe<Companies_Mutation_Response>;
  /** insert data into the table: "companies_edit_access" */
  insert_companies_edit_access: Maybe<Companies_Edit_Access_Mutation_Response>;
  /** insert a single row into the table: "companies_edit_access" */
  insert_companies_edit_access_one: Maybe<Companies_Edit_Access>;
  /** insert a single row into the table: "companies" */
  insert_companies_one: Maybe<Companies>;
  /** insert data into the table: "data_actions" */
  insert_data_actions: Maybe<Data_Actions_Mutation_Response>;
  /** insert a single row into the table: "data_actions" */
  insert_data_actions_one: Maybe<Data_Actions>;
  /** insert data into the table: "data_discard" */
  insert_data_discard: Maybe<Data_Discard_Mutation_Response>;
  /** insert a single row into the table: "data_discard" */
  insert_data_discard_one: Maybe<Data_Discard>;
  /** insert data into the table: "data_fields" */
  insert_data_fields: Maybe<Data_Fields_Mutation_Response>;
  /** insert a single row into the table: "data_fields" */
  insert_data_fields_one: Maybe<Data_Fields>;
  /** insert data into the table: "data_partners" */
  insert_data_partners: Maybe<Data_Partners_Mutation_Response>;
  /** insert a single row into the table: "data_partners" */
  insert_data_partners_one: Maybe<Data_Partners>;
  /** insert data into the table: "data_raw" */
  insert_data_raw: Maybe<Data_Raw_Mutation_Response>;
  /** insert a single row into the table: "data_raw" */
  insert_data_raw_one: Maybe<Data_Raw>;
  /** insert data into the table: "data_runs" */
  insert_data_runs: Maybe<Data_Runs_Mutation_Response>;
  /** insert a single row into the table: "data_runs" */
  insert_data_runs_one: Maybe<Data_Runs>;
  /** insert data into the table: "disabled_emails" */
  insert_disabled_emails: Maybe<Disabled_Emails_Mutation_Response>;
  /** insert a single row into the table: "disabled_emails" */
  insert_disabled_emails_one: Maybe<Disabled_Emails>;
  /** insert data into the table: "event_organization" */
  insert_event_organization: Maybe<Event_Organization_Mutation_Response>;
  /** insert a single row into the table: "event_organization" */
  insert_event_organization_one: Maybe<Event_Organization>;
  /** insert data into the table: "event_person" */
  insert_event_person: Maybe<Event_Person_Mutation_Response>;
  /** insert a single row into the table: "event_person" */
  insert_event_person_one: Maybe<Event_Person>;
  /** insert data into the table: "events" */
  insert_events: Maybe<Events_Mutation_Response>;
  /** insert a single row into the table: "events" */
  insert_events_one: Maybe<Events>;
  /** insert data into the table: "follows" */
  insert_follows: Maybe<Follows_Mutation_Response>;
  /** insert data into the table: "follows_companies" */
  insert_follows_companies: Maybe<Follows_Companies_Mutation_Response>;
  /** insert a single row into the table: "follows_companies" */
  insert_follows_companies_one: Maybe<Follows_Companies>;
  /** insert a single row into the table: "follows" */
  insert_follows_one: Maybe<Follows>;
  /** insert data into the table: "follows_people" */
  insert_follows_people: Maybe<Follows_People_Mutation_Response>;
  /** insert a single row into the table: "follows_people" */
  insert_follows_people_one: Maybe<Follows_People>;
  /** insert data into the table: "follows_vc_firms" */
  insert_follows_vc_firms: Maybe<Follows_Vc_Firms_Mutation_Response>;
  /** insert a single row into the table: "follows_vc_firms" */
  insert_follows_vc_firms_one: Maybe<Follows_Vc_Firms>;
  /** insert data into the table: "investment_rounds" */
  insert_investment_rounds: Maybe<Investment_Rounds_Mutation_Response>;
  /** insert a single row into the table: "investment_rounds" */
  insert_investment_rounds_one: Maybe<Investment_Rounds>;
  /** insert data into the table: "investments" */
  insert_investments: Maybe<Investments_Mutation_Response>;
  /** insert a single row into the table: "investments" */
  insert_investments_one: Maybe<Investments>;
  /** insert data into the table: "investors" */
  insert_investors: Maybe<Investors_Mutation_Response>;
  /** insert a single row into the table: "investors" */
  insert_investors_one: Maybe<Investors>;
  /** insert data into the table: "invited_people" */
  insert_invited_people: Maybe<Invited_People_Mutation_Response>;
  /** insert a single row into the table: "invited_people" */
  insert_invited_people_one: Maybe<Invited_People>;
  /** insert data into the table: "leads" */
  insert_leads: Maybe<Leads_Mutation_Response>;
  /** insert a single row into the table: "leads" */
  insert_leads_one: Maybe<Leads>;
  /** insert data into the table: "leads_segmentation" */
  insert_leads_segmentation: Maybe<Leads_Segmentation_Mutation_Response>;
  /** insert a single row into the table: "leads_segmentation" */
  insert_leads_segmentation_one: Maybe<Leads_Segmentation>;
  /** insert data into the table: "likes" */
  insert_likes: Maybe<Likes_Mutation_Response>;
  /** insert a single row into the table: "likes" */
  insert_likes_one: Maybe<Likes>;
  /** insert data into the table: "list_members" */
  insert_list_members: Maybe<List_Members_Mutation_Response>;
  /** insert a single row into the table: "list_members" */
  insert_list_members_one: Maybe<List_Members>;
  /** insert data into the table: "list_user_groups" */
  insert_list_user_groups: Maybe<List_User_Groups_Mutation_Response>;
  /** insert a single row into the table: "list_user_groups" */
  insert_list_user_groups_one: Maybe<List_User_Groups>;
  /** insert data into the table: "lists" */
  insert_lists: Maybe<Lists_Mutation_Response>;
  /** insert a single row into the table: "lists" */
  insert_lists_one: Maybe<Lists>;
  /** insert data into the table: "news" */
  insert_news: Maybe<News_Mutation_Response>;
  /** insert a single row into the table: "news" */
  insert_news_one: Maybe<News>;
  /** insert data into the table: "news_organizations" */
  insert_news_organizations: Maybe<News_Organizations_Mutation_Response>;
  /** insert a single row into the table: "news_organizations" */
  insert_news_organizations_one: Maybe<News_Organizations>;
  /** insert data into the table: "news_person" */
  insert_news_person: Maybe<News_Person_Mutation_Response>;
  /** insert a single row into the table: "news_person" */
  insert_news_person_one: Maybe<News_Person>;
  /** insert data into the table: "news_related_organizations" */
  insert_news_related_organizations: Maybe<News_Related_Organizations_Mutation_Response>;
  /** insert a single row into the table: "news_related_organizations" */
  insert_news_related_organizations_one: Maybe<News_Related_Organizations>;
  /** insert data into the table: "news_related_person" */
  insert_news_related_person: Maybe<News_Related_Person_Mutation_Response>;
  /** insert a single row into the table: "news_related_person" */
  insert_news_related_person_one: Maybe<News_Related_Person>;
  /** insert data into the table: "notes" */
  insert_notes: Maybe<Notes_Mutation_Response>;
  /** insert a single row into the table: "notes" */
  insert_notes_one: Maybe<Notes>;
  /** insert data into the table: "notification_actions" */
  insert_notification_actions: Maybe<Notification_Actions_Mutation_Response>;
  /** insert a single row into the table: "notification_actions" */
  insert_notification_actions_one: Maybe<Notification_Actions>;
  /** insert data into the table: "notifications" */
  insert_notifications: Maybe<Notifications_Mutation_Response>;
  /** insert a single row into the table: "notifications" */
  insert_notifications_one: Maybe<Notifications>;
  /** insert data into the table: "people" */
  insert_people: Maybe<People_Mutation_Response>;
  /** insert data into the table: "people_computed_data" */
  insert_people_computed_data: Maybe<People_Computed_Data_Mutation_Response>;
  /** insert a single row into the table: "people_computed_data" */
  insert_people_computed_data_one: Maybe<People_Computed_Data>;
  /** insert a single row into the table: "people" */
  insert_people_one: Maybe<People>;
  /** insert data into the table: "reset_passwords" */
  insert_reset_passwords: Maybe<Reset_Passwords_Mutation_Response>;
  /** insert a single row into the table: "reset_passwords" */
  insert_reset_passwords_one: Maybe<Reset_Passwords>;
  /** insert data into the table: "resource_edit_access" */
  insert_resource_edit_access: Maybe<Resource_Edit_Access_Mutation_Response>;
  /** insert a single row into the table: "resource_edit_access" */
  insert_resource_edit_access_one: Maybe<Resource_Edit_Access>;
  /** insert data into the table: "resource_links" */
  insert_resource_links: Maybe<Resource_Links_Mutation_Response>;
  /** insert a single row into the table: "resource_links" */
  insert_resource_links_one: Maybe<Resource_Links>;
  /** insert data into the table: "team_members" */
  insert_team_members: Maybe<Team_Members_Mutation_Response>;
  /** insert a single row into the table: "team_members" */
  insert_team_members_one: Maybe<Team_Members>;
  /** insert data into the table: "user_group_invites" */
  insert_user_group_invites: Maybe<User_Group_Invites_Mutation_Response>;
  /** insert a single row into the table: "user_group_invites" */
  insert_user_group_invites_one: Maybe<User_Group_Invites>;
  /** insert data into the table: "user_group_members" */
  insert_user_group_members: Maybe<User_Group_Members_Mutation_Response>;
  /** insert a single row into the table: "user_group_members" */
  insert_user_group_members_one: Maybe<User_Group_Members>;
  /** insert data into the table: "user_groups" */
  insert_user_groups: Maybe<User_Groups_Mutation_Response>;
  /** insert a single row into the table: "user_groups" */
  insert_user_groups_one: Maybe<User_Groups>;
  /** insert data into the table: "user_tokens" */
  insert_user_tokens: Maybe<User_Tokens_Mutation_Response>;
  /** insert a single row into the table: "user_tokens" */
  insert_user_tokens_one: Maybe<User_Tokens>;
  /** insert data into the table: "user_transactions" */
  insert_user_transactions: Maybe<User_Transactions_Mutation_Response>;
  /** insert a single row into the table: "user_transactions" */
  insert_user_transactions_one: Maybe<User_Transactions>;
  /** insert data into the table: "users" */
  insert_users: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one: Maybe<Users>;
  /** insert data into the table: "users_public" */
  insert_users_public: Maybe<Users_Public_Mutation_Response>;
  /** insert a single row into the table: "users_public" */
  insert_users_public_one: Maybe<Users_Public>;
  /** insert data into the table: "vc_firms" */
  insert_vc_firms: Maybe<Vc_Firms_Mutation_Response>;
  /** insert data into the table: "vc_firms_edit_access" */
  insert_vc_firms_edit_access: Maybe<Vc_Firms_Edit_Access_Mutation_Response>;
  /** insert a single row into the table: "vc_firms_edit_access" */
  insert_vc_firms_edit_access_one: Maybe<Vc_Firms_Edit_Access>;
  /** insert a single row into the table: "vc_firms" */
  insert_vc_firms_one: Maybe<Vc_Firms>;
  /** insert data into the table: "waitlist_emails" */
  insert_waitlist_emails: Maybe<Waitlist_Emails_Mutation_Response>;
  /** insert a single row into the table: "waitlist_emails" */
  insert_waitlist_emails_one: Maybe<Waitlist_Emails>;
  /** update data of the table: "actions" */
  update_actions: Maybe<Actions_Mutation_Response>;
  /** update single row of the table: "actions" */
  update_actions_by_pk: Maybe<Actions>;
  /** update multiples rows of table: "actions" */
  update_actions_many: Maybe<Array<Maybe<Actions_Mutation_Response>>>;
  /** update data of the table: "allowed_emails" */
  update_allowed_emails: Maybe<Allowed_Emails_Mutation_Response>;
  /** update single row of the table: "allowed_emails" */
  update_allowed_emails_by_pk: Maybe<Allowed_Emails>;
  /** update multiples rows of table: "allowed_emails" */
  update_allowed_emails_many: Maybe<Array<Maybe<Allowed_Emails_Mutation_Response>>>;
  /** update data of the table: "application_meta" */
  update_application_meta: Maybe<Application_Meta_Mutation_Response>;
  /** update single row of the table: "application_meta" */
  update_application_meta_by_pk: Maybe<Application_Meta>;
  /** update multiples rows of table: "application_meta" */
  update_application_meta_many: Maybe<Array<Maybe<Application_Meta_Mutation_Response>>>;
  /** update data of the table: "billing_org" */
  update_billing_org: Maybe<Billing_Org_Mutation_Response>;
  /** update single row of the table: "billing_org" */
  update_billing_org_by_pk: Maybe<Billing_Org>;
  /** update multiples rows of table: "billing_org" */
  update_billing_org_many: Maybe<Array<Maybe<Billing_Org_Mutation_Response>>>;
  /** update data of the table: "blockchains" */
  update_blockchains: Maybe<Blockchains_Mutation_Response>;
  /** update single row of the table: "blockchains" */
  update_blockchains_by_pk: Maybe<Blockchains>;
  /** update multiples rows of table: "blockchains" */
  update_blockchains_many: Maybe<Array<Maybe<Blockchains_Mutation_Response>>>;
  /** update data of the table: "coins" */
  update_coins: Maybe<Coins_Mutation_Response>;
  /** update single row of the table: "coins" */
  update_coins_by_pk: Maybe<Coins>;
  /** update multiples rows of table: "coins" */
  update_coins_many: Maybe<Array<Maybe<Coins_Mutation_Response>>>;
  /** update data of the table: "comments" */
  update_comments: Maybe<Comments_Mutation_Response>;
  /** update single row of the table: "comments" */
  update_comments_by_pk: Maybe<Comments>;
  /** update multiples rows of table: "comments" */
  update_comments_many: Maybe<Array<Maybe<Comments_Mutation_Response>>>;
  /** update data of the table: "companies" */
  update_companies: Maybe<Companies_Mutation_Response>;
  /** update single row of the table: "companies" */
  update_companies_by_pk: Maybe<Companies>;
  /** update data of the table: "companies_edit_access" */
  update_companies_edit_access: Maybe<Companies_Edit_Access_Mutation_Response>;
  /** update multiples rows of table: "companies_edit_access" */
  update_companies_edit_access_many: Maybe<Array<Maybe<Companies_Edit_Access_Mutation_Response>>>;
  /** update multiples rows of table: "companies" */
  update_companies_many: Maybe<Array<Maybe<Companies_Mutation_Response>>>;
  /** update data of the table: "data_actions" */
  update_data_actions: Maybe<Data_Actions_Mutation_Response>;
  /** update single row of the table: "data_actions" */
  update_data_actions_by_pk: Maybe<Data_Actions>;
  /** update multiples rows of table: "data_actions" */
  update_data_actions_many: Maybe<Array<Maybe<Data_Actions_Mutation_Response>>>;
  /** update data of the table: "data_discard" */
  update_data_discard: Maybe<Data_Discard_Mutation_Response>;
  /** update single row of the table: "data_discard" */
  update_data_discard_by_pk: Maybe<Data_Discard>;
  /** update multiples rows of table: "data_discard" */
  update_data_discard_many: Maybe<Array<Maybe<Data_Discard_Mutation_Response>>>;
  /** update data of the table: "data_fields" */
  update_data_fields: Maybe<Data_Fields_Mutation_Response>;
  /** update single row of the table: "data_fields" */
  update_data_fields_by_pk: Maybe<Data_Fields>;
  /** update multiples rows of table: "data_fields" */
  update_data_fields_many: Maybe<Array<Maybe<Data_Fields_Mutation_Response>>>;
  /** update data of the table: "data_partners" */
  update_data_partners: Maybe<Data_Partners_Mutation_Response>;
  /** update single row of the table: "data_partners" */
  update_data_partners_by_pk: Maybe<Data_Partners>;
  /** update multiples rows of table: "data_partners" */
  update_data_partners_many: Maybe<Array<Maybe<Data_Partners_Mutation_Response>>>;
  /** update data of the table: "data_raw" */
  update_data_raw: Maybe<Data_Raw_Mutation_Response>;
  /** update single row of the table: "data_raw" */
  update_data_raw_by_pk: Maybe<Data_Raw>;
  /** update multiples rows of table: "data_raw" */
  update_data_raw_many: Maybe<Array<Maybe<Data_Raw_Mutation_Response>>>;
  /** update data of the table: "data_runs" */
  update_data_runs: Maybe<Data_Runs_Mutation_Response>;
  /** update single row of the table: "data_runs" */
  update_data_runs_by_pk: Maybe<Data_Runs>;
  /** update multiples rows of table: "data_runs" */
  update_data_runs_many: Maybe<Array<Maybe<Data_Runs_Mutation_Response>>>;
  /** update data of the table: "disabled_emails" */
  update_disabled_emails: Maybe<Disabled_Emails_Mutation_Response>;
  /** update single row of the table: "disabled_emails" */
  update_disabled_emails_by_pk: Maybe<Disabled_Emails>;
  /** update multiples rows of table: "disabled_emails" */
  update_disabled_emails_many: Maybe<Array<Maybe<Disabled_Emails_Mutation_Response>>>;
  /** update data of the table: "event_organization" */
  update_event_organization: Maybe<Event_Organization_Mutation_Response>;
  /** update single row of the table: "event_organization" */
  update_event_organization_by_pk: Maybe<Event_Organization>;
  /** update multiples rows of table: "event_organization" */
  update_event_organization_many: Maybe<Array<Maybe<Event_Organization_Mutation_Response>>>;
  /** update data of the table: "event_person" */
  update_event_person: Maybe<Event_Person_Mutation_Response>;
  /** update single row of the table: "event_person" */
  update_event_person_by_pk: Maybe<Event_Person>;
  /** update multiples rows of table: "event_person" */
  update_event_person_many: Maybe<Array<Maybe<Event_Person_Mutation_Response>>>;
  /** update data of the table: "events" */
  update_events: Maybe<Events_Mutation_Response>;
  /** update single row of the table: "events" */
  update_events_by_pk: Maybe<Events>;
  /** update multiples rows of table: "events" */
  update_events_many: Maybe<Array<Maybe<Events_Mutation_Response>>>;
  /** update data of the table: "follows" */
  update_follows: Maybe<Follows_Mutation_Response>;
  /** update single row of the table: "follows" */
  update_follows_by_pk: Maybe<Follows>;
  /** update data of the table: "follows_companies" */
  update_follows_companies: Maybe<Follows_Companies_Mutation_Response>;
  /** update multiples rows of table: "follows_companies" */
  update_follows_companies_many: Maybe<Array<Maybe<Follows_Companies_Mutation_Response>>>;
  /** update multiples rows of table: "follows" */
  update_follows_many: Maybe<Array<Maybe<Follows_Mutation_Response>>>;
  /** update data of the table: "follows_people" */
  update_follows_people: Maybe<Follows_People_Mutation_Response>;
  /** update multiples rows of table: "follows_people" */
  update_follows_people_many: Maybe<Array<Maybe<Follows_People_Mutation_Response>>>;
  /** update data of the table: "follows_vc_firms" */
  update_follows_vc_firms: Maybe<Follows_Vc_Firms_Mutation_Response>;
  /** update multiples rows of table: "follows_vc_firms" */
  update_follows_vc_firms_many: Maybe<Array<Maybe<Follows_Vc_Firms_Mutation_Response>>>;
  /** update data of the table: "investment_rounds" */
  update_investment_rounds: Maybe<Investment_Rounds_Mutation_Response>;
  /** update single row of the table: "investment_rounds" */
  update_investment_rounds_by_pk: Maybe<Investment_Rounds>;
  /** update multiples rows of table: "investment_rounds" */
  update_investment_rounds_many: Maybe<Array<Maybe<Investment_Rounds_Mutation_Response>>>;
  /** update data of the table: "investments" */
  update_investments: Maybe<Investments_Mutation_Response>;
  /** update single row of the table: "investments" */
  update_investments_by_pk: Maybe<Investments>;
  /** update multiples rows of table: "investments" */
  update_investments_many: Maybe<Array<Maybe<Investments_Mutation_Response>>>;
  /** update data of the table: "investors" */
  update_investors: Maybe<Investors_Mutation_Response>;
  /** update single row of the table: "investors" */
  update_investors_by_pk: Maybe<Investors>;
  /** update multiples rows of table: "investors" */
  update_investors_many: Maybe<Array<Maybe<Investors_Mutation_Response>>>;
  /** update data of the table: "invited_people" */
  update_invited_people: Maybe<Invited_People_Mutation_Response>;
  /** update single row of the table: "invited_people" */
  update_invited_people_by_pk: Maybe<Invited_People>;
  /** update multiples rows of table: "invited_people" */
  update_invited_people_many: Maybe<Array<Maybe<Invited_People_Mutation_Response>>>;
  /** update data of the table: "leads" */
  update_leads: Maybe<Leads_Mutation_Response>;
  /** update single row of the table: "leads" */
  update_leads_by_pk: Maybe<Leads>;
  /** update multiples rows of table: "leads" */
  update_leads_many: Maybe<Array<Maybe<Leads_Mutation_Response>>>;
  /** update data of the table: "leads_segmentation" */
  update_leads_segmentation: Maybe<Leads_Segmentation_Mutation_Response>;
  /** update single row of the table: "leads_segmentation" */
  update_leads_segmentation_by_pk: Maybe<Leads_Segmentation>;
  /** update multiples rows of table: "leads_segmentation" */
  update_leads_segmentation_many: Maybe<Array<Maybe<Leads_Segmentation_Mutation_Response>>>;
  /** update data of the table: "likes" */
  update_likes: Maybe<Likes_Mutation_Response>;
  /** update single row of the table: "likes" */
  update_likes_by_pk: Maybe<Likes>;
  /** update multiples rows of table: "likes" */
  update_likes_many: Maybe<Array<Maybe<Likes_Mutation_Response>>>;
  /** update data of the table: "list_members" */
  update_list_members: Maybe<List_Members_Mutation_Response>;
  /** update single row of the table: "list_members" */
  update_list_members_by_pk: Maybe<List_Members>;
  /** update multiples rows of table: "list_members" */
  update_list_members_many: Maybe<Array<Maybe<List_Members_Mutation_Response>>>;
  /** update data of the table: "list_user_groups" */
  update_list_user_groups: Maybe<List_User_Groups_Mutation_Response>;
  /** update single row of the table: "list_user_groups" */
  update_list_user_groups_by_pk: Maybe<List_User_Groups>;
  /** update multiples rows of table: "list_user_groups" */
  update_list_user_groups_many: Maybe<Array<Maybe<List_User_Groups_Mutation_Response>>>;
  /** update data of the table: "lists" */
  update_lists: Maybe<Lists_Mutation_Response>;
  /** update single row of the table: "lists" */
  update_lists_by_pk: Maybe<Lists>;
  /** update multiples rows of table: "lists" */
  update_lists_many: Maybe<Array<Maybe<Lists_Mutation_Response>>>;
  /** update data of the table: "news" */
  update_news: Maybe<News_Mutation_Response>;
  /** update single row of the table: "news" */
  update_news_by_pk: Maybe<News>;
  /** update multiples rows of table: "news" */
  update_news_many: Maybe<Array<Maybe<News_Mutation_Response>>>;
  /** update data of the table: "news_organizations" */
  update_news_organizations: Maybe<News_Organizations_Mutation_Response>;
  /** update single row of the table: "news_organizations" */
  update_news_organizations_by_pk: Maybe<News_Organizations>;
  /** update multiples rows of table: "news_organizations" */
  update_news_organizations_many: Maybe<Array<Maybe<News_Organizations_Mutation_Response>>>;
  /** update data of the table: "news_person" */
  update_news_person: Maybe<News_Person_Mutation_Response>;
  /** update single row of the table: "news_person" */
  update_news_person_by_pk: Maybe<News_Person>;
  /** update multiples rows of table: "news_person" */
  update_news_person_many: Maybe<Array<Maybe<News_Person_Mutation_Response>>>;
  /** update data of the table: "news_related_organizations" */
  update_news_related_organizations: Maybe<News_Related_Organizations_Mutation_Response>;
  /** update single row of the table: "news_related_organizations" */
  update_news_related_organizations_by_pk: Maybe<News_Related_Organizations>;
  /** update multiples rows of table: "news_related_organizations" */
  update_news_related_organizations_many: Maybe<Array<Maybe<News_Related_Organizations_Mutation_Response>>>;
  /** update data of the table: "news_related_person" */
  update_news_related_person: Maybe<News_Related_Person_Mutation_Response>;
  /** update single row of the table: "news_related_person" */
  update_news_related_person_by_pk: Maybe<News_Related_Person>;
  /** update multiples rows of table: "news_related_person" */
  update_news_related_person_many: Maybe<Array<Maybe<News_Related_Person_Mutation_Response>>>;
  /** update data of the table: "notes" */
  update_notes: Maybe<Notes_Mutation_Response>;
  /** update single row of the table: "notes" */
  update_notes_by_pk: Maybe<Notes>;
  /** update multiples rows of table: "notes" */
  update_notes_many: Maybe<Array<Maybe<Notes_Mutation_Response>>>;
  /** update data of the table: "notification_actions" */
  update_notification_actions: Maybe<Notification_Actions_Mutation_Response>;
  /** update single row of the table: "notification_actions" */
  update_notification_actions_by_pk: Maybe<Notification_Actions>;
  /** update multiples rows of table: "notification_actions" */
  update_notification_actions_many: Maybe<Array<Maybe<Notification_Actions_Mutation_Response>>>;
  /** update data of the table: "notifications" */
  update_notifications: Maybe<Notifications_Mutation_Response>;
  /** update single row of the table: "notifications" */
  update_notifications_by_pk: Maybe<Notifications>;
  /** update multiples rows of table: "notifications" */
  update_notifications_many: Maybe<Array<Maybe<Notifications_Mutation_Response>>>;
  /** update data of the table: "people" */
  update_people: Maybe<People_Mutation_Response>;
  /** update single row of the table: "people" */
  update_people_by_pk: Maybe<People>;
  /** update data of the table: "people_computed_data" */
  update_people_computed_data: Maybe<People_Computed_Data_Mutation_Response>;
  /** update single row of the table: "people_computed_data" */
  update_people_computed_data_by_pk: Maybe<People_Computed_Data>;
  /** update multiples rows of table: "people_computed_data" */
  update_people_computed_data_many: Maybe<Array<Maybe<People_Computed_Data_Mutation_Response>>>;
  /** update multiples rows of table: "people" */
  update_people_many: Maybe<Array<Maybe<People_Mutation_Response>>>;
  /** update data of the table: "reset_passwords" */
  update_reset_passwords: Maybe<Reset_Passwords_Mutation_Response>;
  /** update single row of the table: "reset_passwords" */
  update_reset_passwords_by_pk: Maybe<Reset_Passwords>;
  /** update multiples rows of table: "reset_passwords" */
  update_reset_passwords_many: Maybe<Array<Maybe<Reset_Passwords_Mutation_Response>>>;
  /** update data of the table: "resource_edit_access" */
  update_resource_edit_access: Maybe<Resource_Edit_Access_Mutation_Response>;
  /** update single row of the table: "resource_edit_access" */
  update_resource_edit_access_by_pk: Maybe<Resource_Edit_Access>;
  /** update multiples rows of table: "resource_edit_access" */
  update_resource_edit_access_many: Maybe<Array<Maybe<Resource_Edit_Access_Mutation_Response>>>;
  /** update data of the table: "resource_links" */
  update_resource_links: Maybe<Resource_Links_Mutation_Response>;
  /** update single row of the table: "resource_links" */
  update_resource_links_by_pk: Maybe<Resource_Links>;
  /** update multiples rows of table: "resource_links" */
  update_resource_links_many: Maybe<Array<Maybe<Resource_Links_Mutation_Response>>>;
  /** update data of the table: "team_members" */
  update_team_members: Maybe<Team_Members_Mutation_Response>;
  /** update single row of the table: "team_members" */
  update_team_members_by_pk: Maybe<Team_Members>;
  /** update multiples rows of table: "team_members" */
  update_team_members_many: Maybe<Array<Maybe<Team_Members_Mutation_Response>>>;
  /** update data of the table: "user_group_invites" */
  update_user_group_invites: Maybe<User_Group_Invites_Mutation_Response>;
  /** update single row of the table: "user_group_invites" */
  update_user_group_invites_by_pk: Maybe<User_Group_Invites>;
  /** update multiples rows of table: "user_group_invites" */
  update_user_group_invites_many: Maybe<Array<Maybe<User_Group_Invites_Mutation_Response>>>;
  /** update data of the table: "user_group_members" */
  update_user_group_members: Maybe<User_Group_Members_Mutation_Response>;
  /** update single row of the table: "user_group_members" */
  update_user_group_members_by_pk: Maybe<User_Group_Members>;
  /** update multiples rows of table: "user_group_members" */
  update_user_group_members_many: Maybe<Array<Maybe<User_Group_Members_Mutation_Response>>>;
  /** update data of the table: "user_groups" */
  update_user_groups: Maybe<User_Groups_Mutation_Response>;
  /** update single row of the table: "user_groups" */
  update_user_groups_by_pk: Maybe<User_Groups>;
  /** update multiples rows of table: "user_groups" */
  update_user_groups_many: Maybe<Array<Maybe<User_Groups_Mutation_Response>>>;
  /** update data of the table: "user_tokens" */
  update_user_tokens: Maybe<User_Tokens_Mutation_Response>;
  /** update single row of the table: "user_tokens" */
  update_user_tokens_by_pk: Maybe<User_Tokens>;
  /** update multiples rows of table: "user_tokens" */
  update_user_tokens_many: Maybe<Array<Maybe<User_Tokens_Mutation_Response>>>;
  /** update data of the table: "user_transactions" */
  update_user_transactions: Maybe<User_Transactions_Mutation_Response>;
  /** update single row of the table: "user_transactions" */
  update_user_transactions_by_pk: Maybe<User_Transactions>;
  /** update multiples rows of table: "user_transactions" */
  update_user_transactions_many: Maybe<Array<Maybe<User_Transactions_Mutation_Response>>>;
  /** update data of the table: "users" */
  update_users: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  /** update data of the table: "users_public" */
  update_users_public: Maybe<Users_Public_Mutation_Response>;
  /** update multiples rows of table: "users_public" */
  update_users_public_many: Maybe<Array<Maybe<Users_Public_Mutation_Response>>>;
  /** update data of the table: "vc_firms" */
  update_vc_firms: Maybe<Vc_Firms_Mutation_Response>;
  /** update single row of the table: "vc_firms" */
  update_vc_firms_by_pk: Maybe<Vc_Firms>;
  /** update data of the table: "vc_firms_edit_access" */
  update_vc_firms_edit_access: Maybe<Vc_Firms_Edit_Access_Mutation_Response>;
  /** update multiples rows of table: "vc_firms_edit_access" */
  update_vc_firms_edit_access_many: Maybe<Array<Maybe<Vc_Firms_Edit_Access_Mutation_Response>>>;
  /** update multiples rows of table: "vc_firms" */
  update_vc_firms_many: Maybe<Array<Maybe<Vc_Firms_Mutation_Response>>>;
  /** update data of the table: "waitlist_emails" */
  update_waitlist_emails: Maybe<Waitlist_Emails_Mutation_Response>;
  /** update single row of the table: "waitlist_emails" */
  update_waitlist_emails_by_pk: Maybe<Waitlist_Emails>;
  /** update multiples rows of table: "waitlist_emails" */
  update_waitlist_emails_many: Maybe<Array<Maybe<Waitlist_Emails_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootDelete_ActionsArgs = {
  where: Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Actions_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Allowed_EmailsArgs = {
  where: Allowed_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Allowed_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Application_MetaArgs = {
  where: Application_Meta_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Application_Meta_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Billing_OrgArgs = {
  where: Billing_Org_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Billing_Org_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_BlockchainsArgs = {
  where: Blockchains_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Blockchains_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_CoinsArgs = {
  where: Coins_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Coins_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_CommentsArgs = {
  where: Comments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Comments_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_CompaniesArgs = {
  where: Companies_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Companies_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Companies_Edit_AccessArgs = {
  where: Companies_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_ActionsArgs = {
  where: Data_Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Actions_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Data_DiscardArgs = {
  where: Data_Discard_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Discard_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Data_FieldsArgs = {
  where: Data_Fields_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Fields_By_PkArgs = {
  path: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Data_PartnersArgs = {
  where: Data_Partners_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Partners_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Data_RawArgs = {
  where: Data_Raw_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Raw_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Data_RunsArgs = {
  where: Data_Runs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Data_Runs_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Disabled_EmailsArgs = {
  where: Disabled_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Disabled_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Event_OrganizationArgs = {
  where: Event_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Event_Organization_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Event_PersonArgs = {
  where: Event_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Event_Person_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_EventsArgs = {
  where: Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Events_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_FollowsArgs = {
  where: Follows_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Follows_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Follows_CompaniesArgs = {
  where: Follows_Companies_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Follows_PeopleArgs = {
  where: Follows_People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Follows_Vc_FirmsArgs = {
  where: Follows_Vc_Firms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investment_RoundsArgs = {
  where: Investment_Rounds_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investment_Rounds_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_InvestmentsArgs = {
  where: Investments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investments_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_InvestorsArgs = {
  where: Investors_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investors_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Invited_PeopleArgs = {
  where: Invited_People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Invited_People_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_LeadsArgs = {
  where: Leads_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Leads_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Leads_SegmentationArgs = {
  where: Leads_Segmentation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Leads_Segmentation_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_LikesArgs = {
  where: Likes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Likes_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_List_MembersArgs = {
  where: List_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_List_Members_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_List_User_GroupsArgs = {
  where: List_User_Groups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_List_User_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_ListsArgs = {
  where: Lists_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Lists_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_NewsArgs = {
  where: News_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_News_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_News_OrganizationsArgs = {
  where: News_Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_News_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_News_PersonArgs = {
  where: News_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_News_Person_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_News_Related_OrganizationsArgs = {
  where: News_Related_Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_News_Related_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_News_Related_PersonArgs = {
  where: News_Related_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_News_Related_Person_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_NotesArgs = {
  where: Notes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Notes_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Notification_ActionsArgs = {
  where: Notification_Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Notification_Actions_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_NotificationsArgs = {
  where: Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Notifications_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_PeopleArgs = {
  where: People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_People_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_People_Computed_DataArgs = {
  where: People_Computed_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_People_Computed_Data_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Reset_PasswordsArgs = {
  where: Reset_Passwords_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Reset_Passwords_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Resource_Edit_AccessArgs = {
  where: Resource_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Resource_Edit_Access_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Resource_LinksArgs = {
  where: Resource_Links_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Resource_Links_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Team_MembersArgs = {
  where: Team_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Team_Members_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_Group_InvitesArgs = {
  where: User_Group_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Group_Invites_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_Group_MembersArgs = {
  where: User_Group_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Group_Members_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_GroupsArgs = {
  where: User_Groups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_TokensArgs = {
  where: User_Tokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Tokens_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_User_TransactionsArgs = {
  where: User_Transactions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Transactions_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Users_PublicArgs = {
  where: Users_Public_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vc_FirmsArgs = {
  where: Vc_Firms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vc_Firms_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Vc_Firms_Edit_AccessArgs = {
  where: Vc_Firms_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Waitlist_EmailsArgs = {
  where: Waitlist_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Waitlist_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootInsert_ActionsArgs = {
  objects: Array<Actions_Insert_Input>;
  on_conflict: InputMaybe<Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Actions_OneArgs = {
  object: Actions_Insert_Input;
  on_conflict: InputMaybe<Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Allowed_EmailsArgs = {
  objects: Array<Allowed_Emails_Insert_Input>;
  on_conflict: InputMaybe<Allowed_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Allowed_Emails_OneArgs = {
  object: Allowed_Emails_Insert_Input;
  on_conflict: InputMaybe<Allowed_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Application_MetaArgs = {
  objects: Array<Application_Meta_Insert_Input>;
  on_conflict: InputMaybe<Application_Meta_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Application_Meta_OneArgs = {
  object: Application_Meta_Insert_Input;
  on_conflict: InputMaybe<Application_Meta_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Billing_OrgArgs = {
  objects: Array<Billing_Org_Insert_Input>;
  on_conflict: InputMaybe<Billing_Org_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Billing_Org_OneArgs = {
  object: Billing_Org_Insert_Input;
  on_conflict: InputMaybe<Billing_Org_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BlockchainsArgs = {
  objects: Array<Blockchains_Insert_Input>;
  on_conflict: InputMaybe<Blockchains_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Blockchains_OneArgs = {
  object: Blockchains_Insert_Input;
  on_conflict: InputMaybe<Blockchains_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CoinsArgs = {
  objects: Array<Coins_Insert_Input>;
  on_conflict: InputMaybe<Coins_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Coins_OneArgs = {
  object: Coins_Insert_Input;
  on_conflict: InputMaybe<Coins_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CommentsArgs = {
  objects: Array<Comments_Insert_Input>;
  on_conflict: InputMaybe<Comments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Comments_OneArgs = {
  object: Comments_Insert_Input;
  on_conflict: InputMaybe<Comments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CompaniesArgs = {
  objects: Array<Companies_Insert_Input>;
  on_conflict: InputMaybe<Companies_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Companies_Edit_AccessArgs = {
  objects: Array<Companies_Edit_Access_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Companies_Edit_Access_OneArgs = {
  object: Companies_Edit_Access_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Companies_OneArgs = {
  object: Companies_Insert_Input;
  on_conflict: InputMaybe<Companies_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_ActionsArgs = {
  objects: Array<Data_Actions_Insert_Input>;
  on_conflict: InputMaybe<Data_Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Actions_OneArgs = {
  object: Data_Actions_Insert_Input;
  on_conflict: InputMaybe<Data_Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_DiscardArgs = {
  objects: Array<Data_Discard_Insert_Input>;
  on_conflict: InputMaybe<Data_Discard_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Discard_OneArgs = {
  object: Data_Discard_Insert_Input;
  on_conflict: InputMaybe<Data_Discard_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_FieldsArgs = {
  objects: Array<Data_Fields_Insert_Input>;
  on_conflict: InputMaybe<Data_Fields_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Fields_OneArgs = {
  object: Data_Fields_Insert_Input;
  on_conflict: InputMaybe<Data_Fields_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_PartnersArgs = {
  objects: Array<Data_Partners_Insert_Input>;
  on_conflict: InputMaybe<Data_Partners_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Partners_OneArgs = {
  object: Data_Partners_Insert_Input;
  on_conflict: InputMaybe<Data_Partners_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_RawArgs = {
  objects: Array<Data_Raw_Insert_Input>;
  on_conflict: InputMaybe<Data_Raw_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Raw_OneArgs = {
  object: Data_Raw_Insert_Input;
  on_conflict: InputMaybe<Data_Raw_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_RunsArgs = {
  objects: Array<Data_Runs_Insert_Input>;
  on_conflict: InputMaybe<Data_Runs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Data_Runs_OneArgs = {
  object: Data_Runs_Insert_Input;
  on_conflict: InputMaybe<Data_Runs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Disabled_EmailsArgs = {
  objects: Array<Disabled_Emails_Insert_Input>;
  on_conflict: InputMaybe<Disabled_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Disabled_Emails_OneArgs = {
  object: Disabled_Emails_Insert_Input;
  on_conflict: InputMaybe<Disabled_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_OrganizationArgs = {
  objects: Array<Event_Organization_Insert_Input>;
  on_conflict: InputMaybe<Event_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_Organization_OneArgs = {
  object: Event_Organization_Insert_Input;
  on_conflict: InputMaybe<Event_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_PersonArgs = {
  objects: Array<Event_Person_Insert_Input>;
  on_conflict: InputMaybe<Event_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_Person_OneArgs = {
  object: Event_Person_Insert_Input;
  on_conflict: InputMaybe<Event_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventsArgs = {
  objects: Array<Events_Insert_Input>;
  on_conflict: InputMaybe<Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Events_OneArgs = {
  object: Events_Insert_Input;
  on_conflict: InputMaybe<Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FollowsArgs = {
  objects: Array<Follows_Insert_Input>;
  on_conflict: InputMaybe<Follows_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Follows_CompaniesArgs = {
  objects: Array<Follows_Companies_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Follows_Companies_OneArgs = {
  object: Follows_Companies_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Follows_OneArgs = {
  object: Follows_Insert_Input;
  on_conflict: InputMaybe<Follows_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Follows_PeopleArgs = {
  objects: Array<Follows_People_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Follows_People_OneArgs = {
  object: Follows_People_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Follows_Vc_FirmsArgs = {
  objects: Array<Follows_Vc_Firms_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Follows_Vc_Firms_OneArgs = {
  object: Follows_Vc_Firms_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Investment_RoundsArgs = {
  objects: Array<Investment_Rounds_Insert_Input>;
  on_conflict: InputMaybe<Investment_Rounds_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investment_Rounds_OneArgs = {
  object: Investment_Rounds_Insert_Input;
  on_conflict: InputMaybe<Investment_Rounds_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InvestmentsArgs = {
  objects: Array<Investments_Insert_Input>;
  on_conflict: InputMaybe<Investments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investments_OneArgs = {
  object: Investments_Insert_Input;
  on_conflict: InputMaybe<Investments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InvestorsArgs = {
  objects: Array<Investors_Insert_Input>;
  on_conflict: InputMaybe<Investors_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investors_OneArgs = {
  object: Investors_Insert_Input;
  on_conflict: InputMaybe<Investors_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Invited_PeopleArgs = {
  objects: Array<Invited_People_Insert_Input>;
  on_conflict: InputMaybe<Invited_People_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Invited_People_OneArgs = {
  object: Invited_People_Insert_Input;
  on_conflict: InputMaybe<Invited_People_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LeadsArgs = {
  objects: Array<Leads_Insert_Input>;
  on_conflict: InputMaybe<Leads_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Leads_OneArgs = {
  object: Leads_Insert_Input;
  on_conflict: InputMaybe<Leads_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Leads_SegmentationArgs = {
  objects: Array<Leads_Segmentation_Insert_Input>;
  on_conflict: InputMaybe<Leads_Segmentation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Leads_Segmentation_OneArgs = {
  object: Leads_Segmentation_Insert_Input;
  on_conflict: InputMaybe<Leads_Segmentation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LikesArgs = {
  objects: Array<Likes_Insert_Input>;
  on_conflict: InputMaybe<Likes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Likes_OneArgs = {
  object: Likes_Insert_Input;
  on_conflict: InputMaybe<Likes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_List_MembersArgs = {
  objects: Array<List_Members_Insert_Input>;
  on_conflict: InputMaybe<List_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_List_Members_OneArgs = {
  object: List_Members_Insert_Input;
  on_conflict: InputMaybe<List_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_List_User_GroupsArgs = {
  objects: Array<List_User_Groups_Insert_Input>;
  on_conflict: InputMaybe<List_User_Groups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_List_User_Groups_OneArgs = {
  object: List_User_Groups_Insert_Input;
  on_conflict: InputMaybe<List_User_Groups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ListsArgs = {
  objects: Array<Lists_Insert_Input>;
  on_conflict: InputMaybe<Lists_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Lists_OneArgs = {
  object: Lists_Insert_Input;
  on_conflict: InputMaybe<Lists_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NewsArgs = {
  objects: Array<News_Insert_Input>;
  on_conflict: InputMaybe<News_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_OneArgs = {
  object: News_Insert_Input;
  on_conflict: InputMaybe<News_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_OrganizationsArgs = {
  objects: Array<News_Organizations_Insert_Input>;
  on_conflict: InputMaybe<News_Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Organizations_OneArgs = {
  object: News_Organizations_Insert_Input;
  on_conflict: InputMaybe<News_Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_PersonArgs = {
  objects: Array<News_Person_Insert_Input>;
  on_conflict: InputMaybe<News_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Person_OneArgs = {
  object: News_Person_Insert_Input;
  on_conflict: InputMaybe<News_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Related_OrganizationsArgs = {
  objects: Array<News_Related_Organizations_Insert_Input>;
  on_conflict: InputMaybe<News_Related_Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Related_Organizations_OneArgs = {
  object: News_Related_Organizations_Insert_Input;
  on_conflict: InputMaybe<News_Related_Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Related_PersonArgs = {
  objects: Array<News_Related_Person_Insert_Input>;
  on_conflict: InputMaybe<News_Related_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_News_Related_Person_OneArgs = {
  object: News_Related_Person_Insert_Input;
  on_conflict: InputMaybe<News_Related_Person_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NotesArgs = {
  objects: Array<Notes_Insert_Input>;
  on_conflict: InputMaybe<Notes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notes_OneArgs = {
  object: Notes_Insert_Input;
  on_conflict: InputMaybe<Notes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notification_ActionsArgs = {
  objects: Array<Notification_Actions_Insert_Input>;
  on_conflict: InputMaybe<Notification_Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notification_Actions_OneArgs = {
  object: Notification_Actions_Insert_Input;
  on_conflict: InputMaybe<Notification_Actions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NotificationsArgs = {
  objects: Array<Notifications_Insert_Input>;
  on_conflict: InputMaybe<Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notifications_OneArgs = {
  object: Notifications_Insert_Input;
  on_conflict: InputMaybe<Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PeopleArgs = {
  objects: Array<People_Insert_Input>;
  on_conflict: InputMaybe<People_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_People_Computed_DataArgs = {
  objects: Array<People_Computed_Data_Insert_Input>;
  on_conflict: InputMaybe<People_Computed_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_People_Computed_Data_OneArgs = {
  object: People_Computed_Data_Insert_Input;
  on_conflict: InputMaybe<People_Computed_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_People_OneArgs = {
  object: People_Insert_Input;
  on_conflict: InputMaybe<People_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Reset_PasswordsArgs = {
  objects: Array<Reset_Passwords_Insert_Input>;
  on_conflict: InputMaybe<Reset_Passwords_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Reset_Passwords_OneArgs = {
  object: Reset_Passwords_Insert_Input;
  on_conflict: InputMaybe<Reset_Passwords_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Resource_Edit_AccessArgs = {
  objects: Array<Resource_Edit_Access_Insert_Input>;
  on_conflict: InputMaybe<Resource_Edit_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Resource_Edit_Access_OneArgs = {
  object: Resource_Edit_Access_Insert_Input;
  on_conflict: InputMaybe<Resource_Edit_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Resource_LinksArgs = {
  objects: Array<Resource_Links_Insert_Input>;
  on_conflict: InputMaybe<Resource_Links_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Resource_Links_OneArgs = {
  object: Resource_Links_Insert_Input;
  on_conflict: InputMaybe<Resource_Links_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Team_MembersArgs = {
  objects: Array<Team_Members_Insert_Input>;
  on_conflict: InputMaybe<Team_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Team_Members_OneArgs = {
  object: Team_Members_Insert_Input;
  on_conflict: InputMaybe<Team_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Group_InvitesArgs = {
  objects: Array<User_Group_Invites_Insert_Input>;
  on_conflict: InputMaybe<User_Group_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Group_Invites_OneArgs = {
  object: User_Group_Invites_Insert_Input;
  on_conflict: InputMaybe<User_Group_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Group_MembersArgs = {
  objects: Array<User_Group_Members_Insert_Input>;
  on_conflict: InputMaybe<User_Group_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Group_Members_OneArgs = {
  object: User_Group_Members_Insert_Input;
  on_conflict: InputMaybe<User_Group_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_GroupsArgs = {
  objects: Array<User_Groups_Insert_Input>;
  on_conflict: InputMaybe<User_Groups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Groups_OneArgs = {
  object: User_Groups_Insert_Input;
  on_conflict: InputMaybe<User_Groups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_TokensArgs = {
  objects: Array<User_Tokens_Insert_Input>;
  on_conflict: InputMaybe<User_Tokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Tokens_OneArgs = {
  object: User_Tokens_Insert_Input;
  on_conflict: InputMaybe<User_Tokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_TransactionsArgs = {
  objects: Array<User_Transactions_Insert_Input>;
  on_conflict: InputMaybe<User_Transactions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Transactions_OneArgs = {
  object: User_Transactions_Insert_Input;
  on_conflict: InputMaybe<User_Transactions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_PublicArgs = {
  objects: Array<Users_Public_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Users_Public_OneArgs = {
  object: Users_Public_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Vc_FirmsArgs = {
  objects: Array<Vc_Firms_Insert_Input>;
  on_conflict: InputMaybe<Vc_Firms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vc_Firms_Edit_AccessArgs = {
  objects: Array<Vc_Firms_Edit_Access_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Vc_Firms_Edit_Access_OneArgs = {
  object: Vc_Firms_Edit_Access_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Vc_Firms_OneArgs = {
  object: Vc_Firms_Insert_Input;
  on_conflict: InputMaybe<Vc_Firms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Waitlist_EmailsArgs = {
  objects: Array<Waitlist_Emails_Insert_Input>;
  on_conflict: InputMaybe<Waitlist_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Waitlist_Emails_OneArgs = {
  object: Waitlist_Emails_Insert_Input;
  on_conflict: InputMaybe<Waitlist_Emails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdate_ActionsArgs = {
  _append: InputMaybe<Actions_Append_Input>;
  _delete_at_path: InputMaybe<Actions_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Actions_Delete_Elem_Input>;
  _delete_key: InputMaybe<Actions_Delete_Key_Input>;
  _inc: InputMaybe<Actions_Inc_Input>;
  _prepend: InputMaybe<Actions_Prepend_Input>;
  _set: InputMaybe<Actions_Set_Input>;
  where: Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Actions_By_PkArgs = {
  _append: InputMaybe<Actions_Append_Input>;
  _delete_at_path: InputMaybe<Actions_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Actions_Delete_Elem_Input>;
  _delete_key: InputMaybe<Actions_Delete_Key_Input>;
  _inc: InputMaybe<Actions_Inc_Input>;
  _prepend: InputMaybe<Actions_Prepend_Input>;
  _set: InputMaybe<Actions_Set_Input>;
  pk_columns: Actions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Actions_ManyArgs = {
  updates: Array<Actions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Allowed_EmailsArgs = {
  _inc: InputMaybe<Allowed_Emails_Inc_Input>;
  _set: InputMaybe<Allowed_Emails_Set_Input>;
  where: Allowed_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Allowed_Emails_By_PkArgs = {
  _inc: InputMaybe<Allowed_Emails_Inc_Input>;
  _set: InputMaybe<Allowed_Emails_Set_Input>;
  pk_columns: Allowed_Emails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Allowed_Emails_ManyArgs = {
  updates: Array<Allowed_Emails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Application_MetaArgs = {
  _inc: InputMaybe<Application_Meta_Inc_Input>;
  _set: InputMaybe<Application_Meta_Set_Input>;
  where: Application_Meta_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Application_Meta_By_PkArgs = {
  _inc: InputMaybe<Application_Meta_Inc_Input>;
  _set: InputMaybe<Application_Meta_Set_Input>;
  pk_columns: Application_Meta_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Application_Meta_ManyArgs = {
  updates: Array<Application_Meta_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_OrgArgs = {
  _inc: InputMaybe<Billing_Org_Inc_Input>;
  _set: InputMaybe<Billing_Org_Set_Input>;
  where: Billing_Org_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Org_By_PkArgs = {
  _inc: InputMaybe<Billing_Org_Inc_Input>;
  _set: InputMaybe<Billing_Org_Set_Input>;
  pk_columns: Billing_Org_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Org_ManyArgs = {
  updates: Array<Billing_Org_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BlockchainsArgs = {
  _inc: InputMaybe<Blockchains_Inc_Input>;
  _set: InputMaybe<Blockchains_Set_Input>;
  where: Blockchains_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Blockchains_By_PkArgs = {
  _inc: InputMaybe<Blockchains_Inc_Input>;
  _set: InputMaybe<Blockchains_Set_Input>;
  pk_columns: Blockchains_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Blockchains_ManyArgs = {
  updates: Array<Blockchains_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CoinsArgs = {
  _inc: InputMaybe<Coins_Inc_Input>;
  _set: InputMaybe<Coins_Set_Input>;
  where: Coins_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Coins_By_PkArgs = {
  _inc: InputMaybe<Coins_Inc_Input>;
  _set: InputMaybe<Coins_Set_Input>;
  pk_columns: Coins_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Coins_ManyArgs = {
  updates: Array<Coins_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CommentsArgs = {
  _inc: InputMaybe<Comments_Inc_Input>;
  _set: InputMaybe<Comments_Set_Input>;
  where: Comments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Comments_By_PkArgs = {
  _inc: InputMaybe<Comments_Inc_Input>;
  _set: InputMaybe<Comments_Set_Input>;
  pk_columns: Comments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Comments_ManyArgs = {
  updates: Array<Comments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CompaniesArgs = {
  _append: InputMaybe<Companies_Append_Input>;
  _delete_at_path: InputMaybe<Companies_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Companies_Delete_Elem_Input>;
  _delete_key: InputMaybe<Companies_Delete_Key_Input>;
  _inc: InputMaybe<Companies_Inc_Input>;
  _prepend: InputMaybe<Companies_Prepend_Input>;
  _set: InputMaybe<Companies_Set_Input>;
  where: Companies_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Companies_By_PkArgs = {
  _append: InputMaybe<Companies_Append_Input>;
  _delete_at_path: InputMaybe<Companies_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Companies_Delete_Elem_Input>;
  _delete_key: InputMaybe<Companies_Delete_Key_Input>;
  _inc: InputMaybe<Companies_Inc_Input>;
  _prepend: InputMaybe<Companies_Prepend_Input>;
  _set: InputMaybe<Companies_Set_Input>;
  pk_columns: Companies_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Companies_Edit_AccessArgs = {
  _inc: InputMaybe<Companies_Edit_Access_Inc_Input>;
  _set: InputMaybe<Companies_Edit_Access_Set_Input>;
  where: Companies_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Companies_Edit_Access_ManyArgs = {
  updates: Array<Companies_Edit_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Companies_ManyArgs = {
  updates: Array<Companies_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_ActionsArgs = {
  _inc: InputMaybe<Data_Actions_Inc_Input>;
  _set: InputMaybe<Data_Actions_Set_Input>;
  where: Data_Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Actions_By_PkArgs = {
  _inc: InputMaybe<Data_Actions_Inc_Input>;
  _set: InputMaybe<Data_Actions_Set_Input>;
  pk_columns: Data_Actions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Actions_ManyArgs = {
  updates: Array<Data_Actions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_DiscardArgs = {
  _append: InputMaybe<Data_Discard_Append_Input>;
  _delete_at_path: InputMaybe<Data_Discard_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Data_Discard_Delete_Elem_Input>;
  _delete_key: InputMaybe<Data_Discard_Delete_Key_Input>;
  _inc: InputMaybe<Data_Discard_Inc_Input>;
  _prepend: InputMaybe<Data_Discard_Prepend_Input>;
  _set: InputMaybe<Data_Discard_Set_Input>;
  where: Data_Discard_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Discard_By_PkArgs = {
  _append: InputMaybe<Data_Discard_Append_Input>;
  _delete_at_path: InputMaybe<Data_Discard_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Data_Discard_Delete_Elem_Input>;
  _delete_key: InputMaybe<Data_Discard_Delete_Key_Input>;
  _inc: InputMaybe<Data_Discard_Inc_Input>;
  _prepend: InputMaybe<Data_Discard_Prepend_Input>;
  _set: InputMaybe<Data_Discard_Set_Input>;
  pk_columns: Data_Discard_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Discard_ManyArgs = {
  updates: Array<Data_Discard_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_FieldsArgs = {
  _inc: InputMaybe<Data_Fields_Inc_Input>;
  _set: InputMaybe<Data_Fields_Set_Input>;
  where: Data_Fields_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Fields_By_PkArgs = {
  _inc: InputMaybe<Data_Fields_Inc_Input>;
  _set: InputMaybe<Data_Fields_Set_Input>;
  pk_columns: Data_Fields_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Fields_ManyArgs = {
  updates: Array<Data_Fields_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_PartnersArgs = {
  _inc: InputMaybe<Data_Partners_Inc_Input>;
  _set: InputMaybe<Data_Partners_Set_Input>;
  where: Data_Partners_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Partners_By_PkArgs = {
  _inc: InputMaybe<Data_Partners_Inc_Input>;
  _set: InputMaybe<Data_Partners_Set_Input>;
  pk_columns: Data_Partners_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Partners_ManyArgs = {
  updates: Array<Data_Partners_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_RawArgs = {
  _append: InputMaybe<Data_Raw_Append_Input>;
  _delete_at_path: InputMaybe<Data_Raw_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Data_Raw_Delete_Elem_Input>;
  _delete_key: InputMaybe<Data_Raw_Delete_Key_Input>;
  _inc: InputMaybe<Data_Raw_Inc_Input>;
  _prepend: InputMaybe<Data_Raw_Prepend_Input>;
  _set: InputMaybe<Data_Raw_Set_Input>;
  where: Data_Raw_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Raw_By_PkArgs = {
  _append: InputMaybe<Data_Raw_Append_Input>;
  _delete_at_path: InputMaybe<Data_Raw_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Data_Raw_Delete_Elem_Input>;
  _delete_key: InputMaybe<Data_Raw_Delete_Key_Input>;
  _inc: InputMaybe<Data_Raw_Inc_Input>;
  _prepend: InputMaybe<Data_Raw_Prepend_Input>;
  _set: InputMaybe<Data_Raw_Set_Input>;
  pk_columns: Data_Raw_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Raw_ManyArgs = {
  updates: Array<Data_Raw_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Data_RunsArgs = {
  _inc: InputMaybe<Data_Runs_Inc_Input>;
  _set: InputMaybe<Data_Runs_Set_Input>;
  where: Data_Runs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Runs_By_PkArgs = {
  _inc: InputMaybe<Data_Runs_Inc_Input>;
  _set: InputMaybe<Data_Runs_Set_Input>;
  pk_columns: Data_Runs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Data_Runs_ManyArgs = {
  updates: Array<Data_Runs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Disabled_EmailsArgs = {
  _inc: InputMaybe<Disabled_Emails_Inc_Input>;
  _set: InputMaybe<Disabled_Emails_Set_Input>;
  where: Disabled_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Disabled_Emails_By_PkArgs = {
  _inc: InputMaybe<Disabled_Emails_Inc_Input>;
  _set: InputMaybe<Disabled_Emails_Set_Input>;
  pk_columns: Disabled_Emails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Disabled_Emails_ManyArgs = {
  updates: Array<Disabled_Emails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Event_OrganizationArgs = {
  _inc: InputMaybe<Event_Organization_Inc_Input>;
  _set: InputMaybe<Event_Organization_Set_Input>;
  where: Event_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Organization_By_PkArgs = {
  _inc: InputMaybe<Event_Organization_Inc_Input>;
  _set: InputMaybe<Event_Organization_Set_Input>;
  pk_columns: Event_Organization_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Organization_ManyArgs = {
  updates: Array<Event_Organization_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Event_PersonArgs = {
  _inc: InputMaybe<Event_Person_Inc_Input>;
  _set: InputMaybe<Event_Person_Set_Input>;
  where: Event_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Person_By_PkArgs = {
  _inc: InputMaybe<Event_Person_Inc_Input>;
  _set: InputMaybe<Event_Person_Set_Input>;
  pk_columns: Event_Person_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Person_ManyArgs = {
  updates: Array<Event_Person_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_EventsArgs = {
  _append: InputMaybe<Events_Append_Input>;
  _delete_at_path: InputMaybe<Events_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Events_Delete_Elem_Input>;
  _delete_key: InputMaybe<Events_Delete_Key_Input>;
  _inc: InputMaybe<Events_Inc_Input>;
  _prepend: InputMaybe<Events_Prepend_Input>;
  _set: InputMaybe<Events_Set_Input>;
  where: Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Events_By_PkArgs = {
  _append: InputMaybe<Events_Append_Input>;
  _delete_at_path: InputMaybe<Events_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Events_Delete_Elem_Input>;
  _delete_key: InputMaybe<Events_Delete_Key_Input>;
  _inc: InputMaybe<Events_Inc_Input>;
  _prepend: InputMaybe<Events_Prepend_Input>;
  _set: InputMaybe<Events_Set_Input>;
  pk_columns: Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Events_ManyArgs = {
  updates: Array<Events_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FollowsArgs = {
  _inc: InputMaybe<Follows_Inc_Input>;
  _set: InputMaybe<Follows_Set_Input>;
  where: Follows_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_By_PkArgs = {
  _inc: InputMaybe<Follows_Inc_Input>;
  _set: InputMaybe<Follows_Set_Input>;
  pk_columns: Follows_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_CompaniesArgs = {
  _inc: InputMaybe<Follows_Companies_Inc_Input>;
  _set: InputMaybe<Follows_Companies_Set_Input>;
  where: Follows_Companies_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_Companies_ManyArgs = {
  updates: Array<Follows_Companies_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_ManyArgs = {
  updates: Array<Follows_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_PeopleArgs = {
  _inc: InputMaybe<Follows_People_Inc_Input>;
  _set: InputMaybe<Follows_People_Set_Input>;
  where: Follows_People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_People_ManyArgs = {
  updates: Array<Follows_People_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_Vc_FirmsArgs = {
  _inc: InputMaybe<Follows_Vc_Firms_Inc_Input>;
  _set: InputMaybe<Follows_Vc_Firms_Set_Input>;
  where: Follows_Vc_Firms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Follows_Vc_Firms_ManyArgs = {
  updates: Array<Follows_Vc_Firms_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Investment_RoundsArgs = {
  _inc: InputMaybe<Investment_Rounds_Inc_Input>;
  _set: InputMaybe<Investment_Rounds_Set_Input>;
  where: Investment_Rounds_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Investment_Rounds_By_PkArgs = {
  _inc: InputMaybe<Investment_Rounds_Inc_Input>;
  _set: InputMaybe<Investment_Rounds_Set_Input>;
  pk_columns: Investment_Rounds_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Investment_Rounds_ManyArgs = {
  updates: Array<Investment_Rounds_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InvestmentsArgs = {
  _inc: InputMaybe<Investments_Inc_Input>;
  _set: InputMaybe<Investments_Set_Input>;
  where: Investments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Investments_By_PkArgs = {
  _inc: InputMaybe<Investments_Inc_Input>;
  _set: InputMaybe<Investments_Set_Input>;
  pk_columns: Investments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Investments_ManyArgs = {
  updates: Array<Investments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InvestorsArgs = {
  _inc: InputMaybe<Investors_Inc_Input>;
  _set: InputMaybe<Investors_Set_Input>;
  where: Investors_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Investors_By_PkArgs = {
  _inc: InputMaybe<Investors_Inc_Input>;
  _set: InputMaybe<Investors_Set_Input>;
  pk_columns: Investors_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Investors_ManyArgs = {
  updates: Array<Investors_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Invited_PeopleArgs = {
  _inc: InputMaybe<Invited_People_Inc_Input>;
  _set: InputMaybe<Invited_People_Set_Input>;
  where: Invited_People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Invited_People_By_PkArgs = {
  _inc: InputMaybe<Invited_People_Inc_Input>;
  _set: InputMaybe<Invited_People_Set_Input>;
  pk_columns: Invited_People_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Invited_People_ManyArgs = {
  updates: Array<Invited_People_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LeadsArgs = {
  _inc: InputMaybe<Leads_Inc_Input>;
  _set: InputMaybe<Leads_Set_Input>;
  where: Leads_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Leads_By_PkArgs = {
  _inc: InputMaybe<Leads_Inc_Input>;
  _set: InputMaybe<Leads_Set_Input>;
  pk_columns: Leads_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Leads_ManyArgs = {
  updates: Array<Leads_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Leads_SegmentationArgs = {
  _inc: InputMaybe<Leads_Segmentation_Inc_Input>;
  _set: InputMaybe<Leads_Segmentation_Set_Input>;
  where: Leads_Segmentation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Leads_Segmentation_By_PkArgs = {
  _inc: InputMaybe<Leads_Segmentation_Inc_Input>;
  _set: InputMaybe<Leads_Segmentation_Set_Input>;
  pk_columns: Leads_Segmentation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Leads_Segmentation_ManyArgs = {
  updates: Array<Leads_Segmentation_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LikesArgs = {
  _inc: InputMaybe<Likes_Inc_Input>;
  _set: InputMaybe<Likes_Set_Input>;
  where: Likes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Likes_By_PkArgs = {
  _inc: InputMaybe<Likes_Inc_Input>;
  _set: InputMaybe<Likes_Set_Input>;
  pk_columns: Likes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Likes_ManyArgs = {
  updates: Array<Likes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_List_MembersArgs = {
  _inc: InputMaybe<List_Members_Inc_Input>;
  _set: InputMaybe<List_Members_Set_Input>;
  where: List_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_List_Members_By_PkArgs = {
  _inc: InputMaybe<List_Members_Inc_Input>;
  _set: InputMaybe<List_Members_Set_Input>;
  pk_columns: List_Members_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_List_Members_ManyArgs = {
  updates: Array<List_Members_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_List_User_GroupsArgs = {
  _inc: InputMaybe<List_User_Groups_Inc_Input>;
  _set: InputMaybe<List_User_Groups_Set_Input>;
  where: List_User_Groups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_List_User_Groups_By_PkArgs = {
  _inc: InputMaybe<List_User_Groups_Inc_Input>;
  _set: InputMaybe<List_User_Groups_Set_Input>;
  pk_columns: List_User_Groups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_List_User_Groups_ManyArgs = {
  updates: Array<List_User_Groups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ListsArgs = {
  _inc: InputMaybe<Lists_Inc_Input>;
  _set: InputMaybe<Lists_Set_Input>;
  where: Lists_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Lists_By_PkArgs = {
  _inc: InputMaybe<Lists_Inc_Input>;
  _set: InputMaybe<Lists_Set_Input>;
  pk_columns: Lists_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Lists_ManyArgs = {
  updates: Array<Lists_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NewsArgs = {
  _append: InputMaybe<News_Append_Input>;
  _delete_at_path: InputMaybe<News_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<News_Delete_Elem_Input>;
  _delete_key: InputMaybe<News_Delete_Key_Input>;
  _inc: InputMaybe<News_Inc_Input>;
  _prepend: InputMaybe<News_Prepend_Input>;
  _set: InputMaybe<News_Set_Input>;
  where: News_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_News_By_PkArgs = {
  _append: InputMaybe<News_Append_Input>;
  _delete_at_path: InputMaybe<News_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<News_Delete_Elem_Input>;
  _delete_key: InputMaybe<News_Delete_Key_Input>;
  _inc: InputMaybe<News_Inc_Input>;
  _prepend: InputMaybe<News_Prepend_Input>;
  _set: InputMaybe<News_Set_Input>;
  pk_columns: News_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_News_ManyArgs = {
  updates: Array<News_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_News_OrganizationsArgs = {
  _inc: InputMaybe<News_Organizations_Inc_Input>;
  _set: InputMaybe<News_Organizations_Set_Input>;
  where: News_Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_News_Organizations_By_PkArgs = {
  _inc: InputMaybe<News_Organizations_Inc_Input>;
  _set: InputMaybe<News_Organizations_Set_Input>;
  pk_columns: News_Organizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_News_Organizations_ManyArgs = {
  updates: Array<News_Organizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_News_PersonArgs = {
  _inc: InputMaybe<News_Person_Inc_Input>;
  _set: InputMaybe<News_Person_Set_Input>;
  where: News_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_News_Person_By_PkArgs = {
  _inc: InputMaybe<News_Person_Inc_Input>;
  _set: InputMaybe<News_Person_Set_Input>;
  pk_columns: News_Person_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_News_Person_ManyArgs = {
  updates: Array<News_Person_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_OrganizationsArgs = {
  _inc: InputMaybe<News_Related_Organizations_Inc_Input>;
  _set: InputMaybe<News_Related_Organizations_Set_Input>;
  where: News_Related_Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_Organizations_By_PkArgs = {
  _inc: InputMaybe<News_Related_Organizations_Inc_Input>;
  _set: InputMaybe<News_Related_Organizations_Set_Input>;
  pk_columns: News_Related_Organizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_Organizations_ManyArgs = {
  updates: Array<News_Related_Organizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_PersonArgs = {
  _inc: InputMaybe<News_Related_Person_Inc_Input>;
  _set: InputMaybe<News_Related_Person_Set_Input>;
  where: News_Related_Person_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_Person_By_PkArgs = {
  _inc: InputMaybe<News_Related_Person_Inc_Input>;
  _set: InputMaybe<News_Related_Person_Set_Input>;
  pk_columns: News_Related_Person_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_News_Related_Person_ManyArgs = {
  updates: Array<News_Related_Person_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NotesArgs = {
  _inc: InputMaybe<Notes_Inc_Input>;
  _set: InputMaybe<Notes_Set_Input>;
  where: Notes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Notes_By_PkArgs = {
  _inc: InputMaybe<Notes_Inc_Input>;
  _set: InputMaybe<Notes_Set_Input>;
  pk_columns: Notes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Notes_ManyArgs = {
  updates: Array<Notes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Notification_ActionsArgs = {
  _inc: InputMaybe<Notification_Actions_Inc_Input>;
  _set: InputMaybe<Notification_Actions_Set_Input>;
  where: Notification_Actions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Notification_Actions_By_PkArgs = {
  _inc: InputMaybe<Notification_Actions_Inc_Input>;
  _set: InputMaybe<Notification_Actions_Set_Input>;
  pk_columns: Notification_Actions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Notification_Actions_ManyArgs = {
  updates: Array<Notification_Actions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NotificationsArgs = {
  _append: InputMaybe<Notifications_Append_Input>;
  _delete_at_path: InputMaybe<Notifications_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Notifications_Delete_Elem_Input>;
  _delete_key: InputMaybe<Notifications_Delete_Key_Input>;
  _inc: InputMaybe<Notifications_Inc_Input>;
  _prepend: InputMaybe<Notifications_Prepend_Input>;
  _set: InputMaybe<Notifications_Set_Input>;
  where: Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Notifications_By_PkArgs = {
  _append: InputMaybe<Notifications_Append_Input>;
  _delete_at_path: InputMaybe<Notifications_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Notifications_Delete_Elem_Input>;
  _delete_key: InputMaybe<Notifications_Delete_Key_Input>;
  _inc: InputMaybe<Notifications_Inc_Input>;
  _prepend: InputMaybe<Notifications_Prepend_Input>;
  _set: InputMaybe<Notifications_Set_Input>;
  pk_columns: Notifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Notifications_ManyArgs = {
  updates: Array<Notifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PeopleArgs = {
  _append: InputMaybe<People_Append_Input>;
  _delete_at_path: InputMaybe<People_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<People_Delete_Elem_Input>;
  _delete_key: InputMaybe<People_Delete_Key_Input>;
  _inc: InputMaybe<People_Inc_Input>;
  _prepend: InputMaybe<People_Prepend_Input>;
  _set: InputMaybe<People_Set_Input>;
  where: People_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_People_By_PkArgs = {
  _append: InputMaybe<People_Append_Input>;
  _delete_at_path: InputMaybe<People_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<People_Delete_Elem_Input>;
  _delete_key: InputMaybe<People_Delete_Key_Input>;
  _inc: InputMaybe<People_Inc_Input>;
  _prepend: InputMaybe<People_Prepend_Input>;
  _set: InputMaybe<People_Set_Input>;
  pk_columns: People_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_People_Computed_DataArgs = {
  _append: InputMaybe<People_Computed_Data_Append_Input>;
  _delete_at_path: InputMaybe<People_Computed_Data_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<People_Computed_Data_Delete_Elem_Input>;
  _delete_key: InputMaybe<People_Computed_Data_Delete_Key_Input>;
  _inc: InputMaybe<People_Computed_Data_Inc_Input>;
  _prepend: InputMaybe<People_Computed_Data_Prepend_Input>;
  _set: InputMaybe<People_Computed_Data_Set_Input>;
  where: People_Computed_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_People_Computed_Data_By_PkArgs = {
  _append: InputMaybe<People_Computed_Data_Append_Input>;
  _delete_at_path: InputMaybe<People_Computed_Data_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<People_Computed_Data_Delete_Elem_Input>;
  _delete_key: InputMaybe<People_Computed_Data_Delete_Key_Input>;
  _inc: InputMaybe<People_Computed_Data_Inc_Input>;
  _prepend: InputMaybe<People_Computed_Data_Prepend_Input>;
  _set: InputMaybe<People_Computed_Data_Set_Input>;
  pk_columns: People_Computed_Data_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_People_Computed_Data_ManyArgs = {
  updates: Array<People_Computed_Data_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_People_ManyArgs = {
  updates: Array<People_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Reset_PasswordsArgs = {
  _inc: InputMaybe<Reset_Passwords_Inc_Input>;
  _set: InputMaybe<Reset_Passwords_Set_Input>;
  where: Reset_Passwords_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Reset_Passwords_By_PkArgs = {
  _inc: InputMaybe<Reset_Passwords_Inc_Input>;
  _set: InputMaybe<Reset_Passwords_Set_Input>;
  pk_columns: Reset_Passwords_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Reset_Passwords_ManyArgs = {
  updates: Array<Reset_Passwords_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_Edit_AccessArgs = {
  _inc: InputMaybe<Resource_Edit_Access_Inc_Input>;
  _set: InputMaybe<Resource_Edit_Access_Set_Input>;
  where: Resource_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_Edit_Access_By_PkArgs = {
  _inc: InputMaybe<Resource_Edit_Access_Inc_Input>;
  _set: InputMaybe<Resource_Edit_Access_Set_Input>;
  pk_columns: Resource_Edit_Access_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_Edit_Access_ManyArgs = {
  updates: Array<Resource_Edit_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_LinksArgs = {
  _inc: InputMaybe<Resource_Links_Inc_Input>;
  _set: InputMaybe<Resource_Links_Set_Input>;
  where: Resource_Links_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_Links_By_PkArgs = {
  _inc: InputMaybe<Resource_Links_Inc_Input>;
  _set: InputMaybe<Resource_Links_Set_Input>;
  pk_columns: Resource_Links_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Resource_Links_ManyArgs = {
  updates: Array<Resource_Links_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Team_MembersArgs = {
  _inc: InputMaybe<Team_Members_Inc_Input>;
  _set: InputMaybe<Team_Members_Set_Input>;
  where: Team_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Members_By_PkArgs = {
  _inc: InputMaybe<Team_Members_Inc_Input>;
  _set: InputMaybe<Team_Members_Set_Input>;
  pk_columns: Team_Members_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Team_Members_ManyArgs = {
  updates: Array<Team_Members_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_InvitesArgs = {
  _inc: InputMaybe<User_Group_Invites_Inc_Input>;
  _set: InputMaybe<User_Group_Invites_Set_Input>;
  where: User_Group_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_Invites_By_PkArgs = {
  _inc: InputMaybe<User_Group_Invites_Inc_Input>;
  _set: InputMaybe<User_Group_Invites_Set_Input>;
  pk_columns: User_Group_Invites_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_Invites_ManyArgs = {
  updates: Array<User_Group_Invites_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_MembersArgs = {
  _inc: InputMaybe<User_Group_Members_Inc_Input>;
  _set: InputMaybe<User_Group_Members_Set_Input>;
  where: User_Group_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_Members_By_PkArgs = {
  _inc: InputMaybe<User_Group_Members_Inc_Input>;
  _set: InputMaybe<User_Group_Members_Set_Input>;
  pk_columns: User_Group_Members_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Group_Members_ManyArgs = {
  updates: Array<User_Group_Members_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_GroupsArgs = {
  _inc: InputMaybe<User_Groups_Inc_Input>;
  _set: InputMaybe<User_Groups_Set_Input>;
  where: User_Groups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Groups_By_PkArgs = {
  _inc: InputMaybe<User_Groups_Inc_Input>;
  _set: InputMaybe<User_Groups_Set_Input>;
  pk_columns: User_Groups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Groups_ManyArgs = {
  updates: Array<User_Groups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_TokensArgs = {
  _inc: InputMaybe<User_Tokens_Inc_Input>;
  _set: InputMaybe<User_Tokens_Set_Input>;
  where: User_Tokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Tokens_By_PkArgs = {
  _inc: InputMaybe<User_Tokens_Inc_Input>;
  _set: InputMaybe<User_Tokens_Set_Input>;
  pk_columns: User_Tokens_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Tokens_ManyArgs = {
  updates: Array<User_Tokens_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_TransactionsArgs = {
  _inc: InputMaybe<User_Transactions_Inc_Input>;
  _set: InputMaybe<User_Transactions_Set_Input>;
  where: User_Transactions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Transactions_By_PkArgs = {
  _inc: InputMaybe<User_Transactions_Inc_Input>;
  _set: InputMaybe<User_Transactions_Set_Input>;
  pk_columns: User_Transactions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Transactions_ManyArgs = {
  updates: Array<User_Transactions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _append: InputMaybe<Users_Append_Input>;
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  _inc: InputMaybe<Users_Inc_Input>;
  _prepend: InputMaybe<Users_Prepend_Input>;
  _set: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _append: InputMaybe<Users_Append_Input>;
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  _inc: InputMaybe<Users_Inc_Input>;
  _prepend: InputMaybe<Users_Prepend_Input>;
  _set: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Users_PublicArgs = {
  _inc: InputMaybe<Users_Public_Inc_Input>;
  _set: InputMaybe<Users_Public_Set_Input>;
  where: Users_Public_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_Public_ManyArgs = {
  updates: Array<Users_Public_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Vc_FirmsArgs = {
  _append: InputMaybe<Vc_Firms_Append_Input>;
  _delete_at_path: InputMaybe<Vc_Firms_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Vc_Firms_Delete_Elem_Input>;
  _delete_key: InputMaybe<Vc_Firms_Delete_Key_Input>;
  _inc: InputMaybe<Vc_Firms_Inc_Input>;
  _prepend: InputMaybe<Vc_Firms_Prepend_Input>;
  _set: InputMaybe<Vc_Firms_Set_Input>;
  where: Vc_Firms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vc_Firms_By_PkArgs = {
  _append: InputMaybe<Vc_Firms_Append_Input>;
  _delete_at_path: InputMaybe<Vc_Firms_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Vc_Firms_Delete_Elem_Input>;
  _delete_key: InputMaybe<Vc_Firms_Delete_Key_Input>;
  _inc: InputMaybe<Vc_Firms_Inc_Input>;
  _prepend: InputMaybe<Vc_Firms_Prepend_Input>;
  _set: InputMaybe<Vc_Firms_Set_Input>;
  pk_columns: Vc_Firms_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vc_Firms_Edit_AccessArgs = {
  _inc: InputMaybe<Vc_Firms_Edit_Access_Inc_Input>;
  _set: InputMaybe<Vc_Firms_Edit_Access_Set_Input>;
  where: Vc_Firms_Edit_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vc_Firms_Edit_Access_ManyArgs = {
  updates: Array<Vc_Firms_Edit_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Vc_Firms_ManyArgs = {
  updates: Array<Vc_Firms_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Waitlist_EmailsArgs = {
  _inc: InputMaybe<Waitlist_Emails_Inc_Input>;
  _set: InputMaybe<Waitlist_Emails_Set_Input>;
  where: Waitlist_Emails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Waitlist_Emails_By_PkArgs = {
  _inc: InputMaybe<Waitlist_Emails_Inc_Input>;
  _set: InputMaybe<Waitlist_Emails_Set_Input>;
  pk_columns: Waitlist_Emails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Waitlist_Emails_ManyArgs = {
  updates: Array<Waitlist_Emails_Updates>;
};

/** columns and relationships of "news" */
export type News = {
  __typename?: 'news';
  created_at: Scalars['timestamptz'];
  date: Maybe<Scalars['date']>;
  id: Scalars['Int'];
  kind: Maybe<Scalars['String']>;
  library: Maybe<Scalars['jsonb']>;
  link: Maybe<Scalars['String']>;
  metadata: Maybe<Scalars['jsonb']>;
  num_of_views: Maybe<Scalars['Int']>;
  /** An array relationship */
  organizations: Array<News_Organizations>;
  /** An aggregate relationship */
  organizations_aggregate: News_Organizations_Aggregate;
  /** An array relationship */
  people: Array<News_Person>;
  /** An aggregate relationship */
  people_aggregate: News_Person_Aggregate;
  source: Maybe<Scalars['jsonb']>;
  status: Maybe<Scalars['String']>;
  text: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "news" */
export type NewsLibraryArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "news" */
export type NewsMetadataArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "news" */
export type NewsOrganizationsArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "news" */
export type NewsOrganizations_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "news" */
export type NewsPeopleArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


/** columns and relationships of "news" */
export type NewsPeople_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


/** columns and relationships of "news" */
export type NewsSourceArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "news" */
export type News_Aggregate = {
  __typename?: 'news_aggregate';
  aggregate: Maybe<News_Aggregate_Fields>;
  nodes: Array<News>;
};

/** aggregate fields of "news" */
export type News_Aggregate_Fields = {
  __typename?: 'news_aggregate_fields';
  avg: Maybe<News_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<News_Max_Fields>;
  min: Maybe<News_Min_Fields>;
  stddev: Maybe<News_Stddev_Fields>;
  stddev_pop: Maybe<News_Stddev_Pop_Fields>;
  stddev_samp: Maybe<News_Stddev_Samp_Fields>;
  sum: Maybe<News_Sum_Fields>;
  var_pop: Maybe<News_Var_Pop_Fields>;
  var_samp: Maybe<News_Var_Samp_Fields>;
  variance: Maybe<News_Variance_Fields>;
};


/** aggregate fields of "news" */
export type News_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<News_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type News_Append_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  source: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type News_Avg_Fields = {
  __typename?: 'news_avg_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "news". All fields are combined with a logical 'AND'. */
export type News_Bool_Exp = {
  _and: InputMaybe<Array<News_Bool_Exp>>;
  _not: InputMaybe<News_Bool_Exp>;
  _or: InputMaybe<Array<News_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  date: InputMaybe<Date_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  kind: InputMaybe<String_Comparison_Exp>;
  library: InputMaybe<Jsonb_Comparison_Exp>;
  link: InputMaybe<String_Comparison_Exp>;
  metadata: InputMaybe<Jsonb_Comparison_Exp>;
  num_of_views: InputMaybe<Int_Comparison_Exp>;
  organizations: InputMaybe<News_Organizations_Bool_Exp>;
  organizations_aggregate: InputMaybe<News_Organizations_Aggregate_Bool_Exp>;
  people: InputMaybe<News_Person_Bool_Exp>;
  people_aggregate: InputMaybe<News_Person_Aggregate_Bool_Exp>;
  source: InputMaybe<Jsonb_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  text: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "news" */
export enum News_Constraint {
  /** unique or primary key constraint on columns "id" */
  NewsPkey = 'news_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type News_Delete_At_Path_Input = {
  library: InputMaybe<Array<Scalars['String']>>;
  metadata: InputMaybe<Array<Scalars['String']>>;
  source: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type News_Delete_Elem_Input = {
  library: InputMaybe<Scalars['Int']>;
  metadata: InputMaybe<Scalars['Int']>;
  source: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type News_Delete_Key_Input = {
  library: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "news" */
export type News_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "news" */
export type News_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  date: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  kind: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  organizations: InputMaybe<News_Organizations_Arr_Rel_Insert_Input>;
  people: InputMaybe<News_Person_Arr_Rel_Insert_Input>;
  source: InputMaybe<Scalars['jsonb']>;
  status: InputMaybe<Scalars['String']>;
  text: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type News_Max_Fields = {
  __typename?: 'news_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  date: Maybe<Scalars['date']>;
  id: Maybe<Scalars['Int']>;
  kind: Maybe<Scalars['String']>;
  link: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  status: Maybe<Scalars['String']>;
  text: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type News_Min_Fields = {
  __typename?: 'news_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  date: Maybe<Scalars['date']>;
  id: Maybe<Scalars['Int']>;
  kind: Maybe<Scalars['String']>;
  link: Maybe<Scalars['String']>;
  num_of_views: Maybe<Scalars['Int']>;
  status: Maybe<Scalars['String']>;
  text: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "news" */
export type News_Mutation_Response = {
  __typename?: 'news_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<News>;
};

/** input type for inserting object relation for remote table "news" */
export type News_Obj_Rel_Insert_Input = {
  data: News_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<News_On_Conflict>;
};

/** on_conflict condition type for table "news" */
export type News_On_Conflict = {
  constraint: News_Constraint;
  update_columns: Array<News_Update_Column>;
  where: InputMaybe<News_Bool_Exp>;
};

/** Ordering options when selecting data from "news". */
export type News_Order_By = {
  created_at: InputMaybe<Order_By>;
  date: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  kind: InputMaybe<Order_By>;
  library: InputMaybe<Order_By>;
  link: InputMaybe<Order_By>;
  metadata: InputMaybe<Order_By>;
  num_of_views: InputMaybe<Order_By>;
  organizations_aggregate: InputMaybe<News_Organizations_Aggregate_Order_By>;
  people_aggregate: InputMaybe<News_Person_Aggregate_Order_By>;
  source: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  text: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** columns and relationships of "news_organizations" */
export type News_Organizations = {
  __typename?: 'news_organizations';
  /** An object relationship */
  company: Maybe<Companies>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  news: Maybe<News>;
  news_id: Scalars['Int'];
  type: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "news_organizations" */
export type News_Organizations_Aggregate = {
  __typename?: 'news_organizations_aggregate';
  aggregate: Maybe<News_Organizations_Aggregate_Fields>;
  nodes: Array<News_Organizations>;
};

export type News_Organizations_Aggregate_Bool_Exp = {
  count: InputMaybe<News_Organizations_Aggregate_Bool_Exp_Count>;
};

export type News_Organizations_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<News_Organizations_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<News_Organizations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "news_organizations" */
export type News_Organizations_Aggregate_Fields = {
  __typename?: 'news_organizations_aggregate_fields';
  avg: Maybe<News_Organizations_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<News_Organizations_Max_Fields>;
  min: Maybe<News_Organizations_Min_Fields>;
  stddev: Maybe<News_Organizations_Stddev_Fields>;
  stddev_pop: Maybe<News_Organizations_Stddev_Pop_Fields>;
  stddev_samp: Maybe<News_Organizations_Stddev_Samp_Fields>;
  sum: Maybe<News_Organizations_Sum_Fields>;
  var_pop: Maybe<News_Organizations_Var_Pop_Fields>;
  var_samp: Maybe<News_Organizations_Var_Samp_Fields>;
  variance: Maybe<News_Organizations_Variance_Fields>;
};


/** aggregate fields of "news_organizations" */
export type News_Organizations_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<News_Organizations_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "news_organizations" */
export type News_Organizations_Aggregate_Order_By = {
  avg: InputMaybe<News_Organizations_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<News_Organizations_Max_Order_By>;
  min: InputMaybe<News_Organizations_Min_Order_By>;
  stddev: InputMaybe<News_Organizations_Stddev_Order_By>;
  stddev_pop: InputMaybe<News_Organizations_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<News_Organizations_Stddev_Samp_Order_By>;
  sum: InputMaybe<News_Organizations_Sum_Order_By>;
  var_pop: InputMaybe<News_Organizations_Var_Pop_Order_By>;
  var_samp: InputMaybe<News_Organizations_Var_Samp_Order_By>;
  variance: InputMaybe<News_Organizations_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "news_organizations" */
export type News_Organizations_Arr_Rel_Insert_Input = {
  data: Array<News_Organizations_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<News_Organizations_On_Conflict>;
};

/** aggregate avg on columns */
export type News_Organizations_Avg_Fields = {
  __typename?: 'news_organizations_avg_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "news_organizations" */
export type News_Organizations_Avg_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "news_organizations". All fields are combined with a logical 'AND'. */
export type News_Organizations_Bool_Exp = {
  _and: InputMaybe<Array<News_Organizations_Bool_Exp>>;
  _not: InputMaybe<News_Organizations_Bool_Exp>;
  _or: InputMaybe<Array<News_Organizations_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  news: InputMaybe<News_Bool_Exp>;
  news_id: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "news_organizations" */
export enum News_Organizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  NewsOrganizationsPkey = 'news_organizations_pkey'
}

/** input type for incrementing numeric columns in table "news_organizations" */
export type News_Organizations_Inc_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "news_organizations" */
export type News_Organizations_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news: InputMaybe<News_Obj_Rel_Insert_Input>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type News_Organizations_Max_Fields = {
  __typename?: 'news_organizations_max_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "news_organizations" */
export type News_Organizations_Max_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type News_Organizations_Min_Fields = {
  __typename?: 'news_organizations_min_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "news_organizations" */
export type News_Organizations_Min_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "news_organizations" */
export type News_Organizations_Mutation_Response = {
  __typename?: 'news_organizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<News_Organizations>;
};

/** on_conflict condition type for table "news_organizations" */
export type News_Organizations_On_Conflict = {
  constraint: News_Organizations_Constraint;
  update_columns: Array<News_Organizations_Update_Column>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};

/** Ordering options when selecting data from "news_organizations". */
export type News_Organizations_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news: InputMaybe<News_Order_By>;
  news_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: news_organizations */
export type News_Organizations_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "news_organizations" */
export enum News_Organizations_Select_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

/** input type for updating data in table "news_organizations" */
export type News_Organizations_Set_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type News_Organizations_Stddev_Fields = {
  __typename?: 'news_organizations_stddev_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "news_organizations" */
export type News_Organizations_Stddev_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type News_Organizations_Stddev_Pop_Fields = {
  __typename?: 'news_organizations_stddev_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "news_organizations" */
export type News_Organizations_Stddev_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type News_Organizations_Stddev_Samp_Fields = {
  __typename?: 'news_organizations_stddev_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "news_organizations" */
export type News_Organizations_Stddev_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "news_organizations" */
export type News_Organizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: News_Organizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type News_Organizations_Stream_Cursor_Value_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type News_Organizations_Sum_Fields = {
  __typename?: 'news_organizations_sum_fields';
  company_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "news_organizations" */
export type News_Organizations_Sum_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** update columns of table "news_organizations" */
export enum News_Organizations_Update_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

export type News_Organizations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<News_Organizations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<News_Organizations_Set_Input>;
  /** filter the rows which have to be updated */
  where: News_Organizations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type News_Organizations_Var_Pop_Fields = {
  __typename?: 'news_organizations_var_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "news_organizations" */
export type News_Organizations_Var_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type News_Organizations_Var_Samp_Fields = {
  __typename?: 'news_organizations_var_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "news_organizations" */
export type News_Organizations_Var_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type News_Organizations_Variance_Fields = {
  __typename?: 'news_organizations_variance_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "news_organizations" */
export type News_Organizations_Variance_Order_By = {
  company_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** columns and relationships of "news_person" */
export type News_Person = {
  __typename?: 'news_person';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  news: Maybe<News>;
  news_id: Scalars['Int'];
  /** An object relationship */
  people: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "news_person" */
export type News_Person_Aggregate = {
  __typename?: 'news_person_aggregate';
  aggregate: Maybe<News_Person_Aggregate_Fields>;
  nodes: Array<News_Person>;
};

export type News_Person_Aggregate_Bool_Exp = {
  count: InputMaybe<News_Person_Aggregate_Bool_Exp_Count>;
};

export type News_Person_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<News_Person_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<News_Person_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "news_person" */
export type News_Person_Aggregate_Fields = {
  __typename?: 'news_person_aggregate_fields';
  avg: Maybe<News_Person_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<News_Person_Max_Fields>;
  min: Maybe<News_Person_Min_Fields>;
  stddev: Maybe<News_Person_Stddev_Fields>;
  stddev_pop: Maybe<News_Person_Stddev_Pop_Fields>;
  stddev_samp: Maybe<News_Person_Stddev_Samp_Fields>;
  sum: Maybe<News_Person_Sum_Fields>;
  var_pop: Maybe<News_Person_Var_Pop_Fields>;
  var_samp: Maybe<News_Person_Var_Samp_Fields>;
  variance: Maybe<News_Person_Variance_Fields>;
};


/** aggregate fields of "news_person" */
export type News_Person_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<News_Person_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "news_person" */
export type News_Person_Aggregate_Order_By = {
  avg: InputMaybe<News_Person_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<News_Person_Max_Order_By>;
  min: InputMaybe<News_Person_Min_Order_By>;
  stddev: InputMaybe<News_Person_Stddev_Order_By>;
  stddev_pop: InputMaybe<News_Person_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<News_Person_Stddev_Samp_Order_By>;
  sum: InputMaybe<News_Person_Sum_Order_By>;
  var_pop: InputMaybe<News_Person_Var_Pop_Order_By>;
  var_samp: InputMaybe<News_Person_Var_Samp_Order_By>;
  variance: InputMaybe<News_Person_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "news_person" */
export type News_Person_Arr_Rel_Insert_Input = {
  data: Array<News_Person_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<News_Person_On_Conflict>;
};

/** aggregate avg on columns */
export type News_Person_Avg_Fields = {
  __typename?: 'news_person_avg_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "news_person" */
export type News_Person_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "news_person". All fields are combined with a logical 'AND'. */
export type News_Person_Bool_Exp = {
  _and: InputMaybe<Array<News_Person_Bool_Exp>>;
  _not: InputMaybe<News_Person_Bool_Exp>;
  _or: InputMaybe<Array<News_Person_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  news: InputMaybe<News_Bool_Exp>;
  news_id: InputMaybe<Int_Comparison_Exp>;
  people: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "news_person" */
export enum News_Person_Constraint {
  /** unique or primary key constraint on columns "id" */
  NewsPersonPkey = 'news_person_pkey'
}

/** input type for incrementing numeric columns in table "news_person" */
export type News_Person_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "news_person" */
export type News_Person_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news: InputMaybe<News_Obj_Rel_Insert_Input>;
  news_id: InputMaybe<Scalars['Int']>;
  people: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type News_Person_Max_Fields = {
  __typename?: 'news_person_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "news_person" */
export type News_Person_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type News_Person_Min_Fields = {
  __typename?: 'news_person_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "news_person" */
export type News_Person_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** response of any mutation on the table "news_person" */
export type News_Person_Mutation_Response = {
  __typename?: 'news_person_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<News_Person>;
};

/** on_conflict condition type for table "news_person" */
export type News_Person_On_Conflict = {
  constraint: News_Person_Constraint;
  update_columns: Array<News_Person_Update_Column>;
  where: InputMaybe<News_Person_Bool_Exp>;
};

/** Ordering options when selecting data from "news_person". */
export type News_Person_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  news: InputMaybe<News_Order_By>;
  news_id: InputMaybe<Order_By>;
  people: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: news_person */
export type News_Person_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "news_person" */
export enum News_Person_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "news_person" */
export type News_Person_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type News_Person_Stddev_Fields = {
  __typename?: 'news_person_stddev_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "news_person" */
export type News_Person_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type News_Person_Stddev_Pop_Fields = {
  __typename?: 'news_person_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "news_person" */
export type News_Person_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type News_Person_Stddev_Samp_Fields = {
  __typename?: 'news_person_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "news_person" */
export type News_Person_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "news_person" */
export type News_Person_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: News_Person_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type News_Person_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type News_Person_Sum_Fields = {
  __typename?: 'news_person_sum_fields';
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "news_person" */
export type News_Person_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** update columns of table "news_person" */
export enum News_Person_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type News_Person_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<News_Person_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<News_Person_Set_Input>;
  /** filter the rows which have to be updated */
  where: News_Person_Bool_Exp;
};

/** aggregate var_pop on columns */
export type News_Person_Var_Pop_Fields = {
  __typename?: 'news_person_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "news_person" */
export type News_Person_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type News_Person_Var_Samp_Fields = {
  __typename?: 'news_person_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "news_person" */
export type News_Person_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type News_Person_Variance_Fields = {
  __typename?: 'news_person_variance_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "news_person" */
export type News_Person_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: news */
export type News_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type News_Prepend_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  source: InputMaybe<Scalars['jsonb']>;
};

/** columns and relationships of "news_related_organizations" */
export type News_Related_Organizations = {
  __typename?: 'news_related_organizations';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  name: Maybe<Scalars['String']>;
  news_id: Scalars['Int'];
  type: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "news_related_organizations" */
export type News_Related_Organizations_Aggregate = {
  __typename?: 'news_related_organizations_aggregate';
  aggregate: Maybe<News_Related_Organizations_Aggregate_Fields>;
  nodes: Array<News_Related_Organizations>;
};

/** aggregate fields of "news_related_organizations" */
export type News_Related_Organizations_Aggregate_Fields = {
  __typename?: 'news_related_organizations_aggregate_fields';
  avg: Maybe<News_Related_Organizations_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<News_Related_Organizations_Max_Fields>;
  min: Maybe<News_Related_Organizations_Min_Fields>;
  stddev: Maybe<News_Related_Organizations_Stddev_Fields>;
  stddev_pop: Maybe<News_Related_Organizations_Stddev_Pop_Fields>;
  stddev_samp: Maybe<News_Related_Organizations_Stddev_Samp_Fields>;
  sum: Maybe<News_Related_Organizations_Sum_Fields>;
  var_pop: Maybe<News_Related_Organizations_Var_Pop_Fields>;
  var_samp: Maybe<News_Related_Organizations_Var_Samp_Fields>;
  variance: Maybe<News_Related_Organizations_Variance_Fields>;
};


/** aggregate fields of "news_related_organizations" */
export type News_Related_Organizations_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<News_Related_Organizations_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type News_Related_Organizations_Avg_Fields = {
  __typename?: 'news_related_organizations_avg_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "news_related_organizations". All fields are combined with a logical 'AND'. */
export type News_Related_Organizations_Bool_Exp = {
  _and: InputMaybe<Array<News_Related_Organizations_Bool_Exp>>;
  _not: InputMaybe<News_Related_Organizations_Bool_Exp>;
  _or: InputMaybe<Array<News_Related_Organizations_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  news_id: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "news_related_organizations" */
export enum News_Related_Organizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  NewsRelatedOrganizationsPkey = 'news_related_organizations_pkey'
}

/** input type for incrementing numeric columns in table "news_related_organizations" */
export type News_Related_Organizations_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "news_related_organizations" */
export type News_Related_Organizations_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type News_Related_Organizations_Max_Fields = {
  __typename?: 'news_related_organizations_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type News_Related_Organizations_Min_Fields = {
  __typename?: 'news_related_organizations_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "news_related_organizations" */
export type News_Related_Organizations_Mutation_Response = {
  __typename?: 'news_related_organizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<News_Related_Organizations>;
};

/** on_conflict condition type for table "news_related_organizations" */
export type News_Related_Organizations_On_Conflict = {
  constraint: News_Related_Organizations_Constraint;
  update_columns: Array<News_Related_Organizations_Update_Column>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};

/** Ordering options when selecting data from "news_related_organizations". */
export type News_Related_Organizations_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: news_related_organizations */
export type News_Related_Organizations_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "news_related_organizations" */
export enum News_Related_Organizations_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "news_related_organizations" */
export type News_Related_Organizations_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type News_Related_Organizations_Stddev_Fields = {
  __typename?: 'news_related_organizations_stddev_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type News_Related_Organizations_Stddev_Pop_Fields = {
  __typename?: 'news_related_organizations_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type News_Related_Organizations_Stddev_Samp_Fields = {
  __typename?: 'news_related_organizations_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "news_related_organizations" */
export type News_Related_Organizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: News_Related_Organizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type News_Related_Organizations_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type News_Related_Organizations_Sum_Fields = {
  __typename?: 'news_related_organizations_sum_fields';
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
};

/** update columns of table "news_related_organizations" */
export enum News_Related_Organizations_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type News_Related_Organizations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<News_Related_Organizations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<News_Related_Organizations_Set_Input>;
  /** filter the rows which have to be updated */
  where: News_Related_Organizations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type News_Related_Organizations_Var_Pop_Fields = {
  __typename?: 'news_related_organizations_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type News_Related_Organizations_Var_Samp_Fields = {
  __typename?: 'news_related_organizations_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type News_Related_Organizations_Variance_Fields = {
  __typename?: 'news_related_organizations_variance_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "news_related_person" */
export type News_Related_Person = {
  __typename?: 'news_related_person';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  name: Maybe<Scalars['String']>;
  news_id: Scalars['Int'];
  type: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "news_related_person" */
export type News_Related_Person_Aggregate = {
  __typename?: 'news_related_person_aggregate';
  aggregate: Maybe<News_Related_Person_Aggregate_Fields>;
  nodes: Array<News_Related_Person>;
};

/** aggregate fields of "news_related_person" */
export type News_Related_Person_Aggregate_Fields = {
  __typename?: 'news_related_person_aggregate_fields';
  avg: Maybe<News_Related_Person_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<News_Related_Person_Max_Fields>;
  min: Maybe<News_Related_Person_Min_Fields>;
  stddev: Maybe<News_Related_Person_Stddev_Fields>;
  stddev_pop: Maybe<News_Related_Person_Stddev_Pop_Fields>;
  stddev_samp: Maybe<News_Related_Person_Stddev_Samp_Fields>;
  sum: Maybe<News_Related_Person_Sum_Fields>;
  var_pop: Maybe<News_Related_Person_Var_Pop_Fields>;
  var_samp: Maybe<News_Related_Person_Var_Samp_Fields>;
  variance: Maybe<News_Related_Person_Variance_Fields>;
};


/** aggregate fields of "news_related_person" */
export type News_Related_Person_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<News_Related_Person_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type News_Related_Person_Avg_Fields = {
  __typename?: 'news_related_person_avg_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "news_related_person". All fields are combined with a logical 'AND'. */
export type News_Related_Person_Bool_Exp = {
  _and: InputMaybe<Array<News_Related_Person_Bool_Exp>>;
  _not: InputMaybe<News_Related_Person_Bool_Exp>;
  _or: InputMaybe<Array<News_Related_Person_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  news_id: InputMaybe<Int_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "news_related_person" */
export enum News_Related_Person_Constraint {
  /** unique or primary key constraint on columns "id" */
  NewsRelatedPersonPkey = 'news_related_person_pkey'
}

/** input type for incrementing numeric columns in table "news_related_person" */
export type News_Related_Person_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  news_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "news_related_person" */
export type News_Related_Person_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type News_Related_Person_Max_Fields = {
  __typename?: 'news_related_person_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type News_Related_Person_Min_Fields = {
  __typename?: 'news_related_person_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  news_id: Maybe<Scalars['Int']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "news_related_person" */
export type News_Related_Person_Mutation_Response = {
  __typename?: 'news_related_person_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<News_Related_Person>;
};

/** on_conflict condition type for table "news_related_person" */
export type News_Related_Person_On_Conflict = {
  constraint: News_Related_Person_Constraint;
  update_columns: Array<News_Related_Person_Update_Column>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};

/** Ordering options when selecting data from "news_related_person". */
export type News_Related_Person_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  news_id: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: news_related_person */
export type News_Related_Person_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "news_related_person" */
export enum News_Related_Person_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "news_related_person" */
export type News_Related_Person_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type News_Related_Person_Stddev_Fields = {
  __typename?: 'news_related_person_stddev_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type News_Related_Person_Stddev_Pop_Fields = {
  __typename?: 'news_related_person_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type News_Related_Person_Stddev_Samp_Fields = {
  __typename?: 'news_related_person_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "news_related_person" */
export type News_Related_Person_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: News_Related_Person_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type News_Related_Person_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  news_id: InputMaybe<Scalars['Int']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type News_Related_Person_Sum_Fields = {
  __typename?: 'news_related_person_sum_fields';
  id: Maybe<Scalars['Int']>;
  news_id: Maybe<Scalars['Int']>;
};

/** update columns of table "news_related_person" */
export enum News_Related_Person_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  NewsId = 'news_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type News_Related_Person_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<News_Related_Person_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<News_Related_Person_Set_Input>;
  /** filter the rows which have to be updated */
  where: News_Related_Person_Bool_Exp;
};

/** aggregate var_pop on columns */
export type News_Related_Person_Var_Pop_Fields = {
  __typename?: 'news_related_person_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type News_Related_Person_Var_Samp_Fields = {
  __typename?: 'news_related_person_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type News_Related_Person_Variance_Fields = {
  __typename?: 'news_related_person_variance_fields';
  id: Maybe<Scalars['Float']>;
  news_id: Maybe<Scalars['Float']>;
};

/** select columns of table "news" */
export enum News_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Library = 'library',
  /** column name */
  Link = 'link',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Source = 'source',
  /** column name */
  Status = 'status',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "news" */
export type News_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  date: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  kind: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  source: InputMaybe<Scalars['jsonb']>;
  status: InputMaybe<Scalars['String']>;
  text: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type News_Stddev_Fields = {
  __typename?: 'news_stddev_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type News_Stddev_Pop_Fields = {
  __typename?: 'news_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type News_Stddev_Samp_Fields = {
  __typename?: 'news_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "news" */
export type News_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: News_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type News_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  date: InputMaybe<Scalars['date']>;
  id: InputMaybe<Scalars['Int']>;
  kind: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['jsonb']>;
  link: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  source: InputMaybe<Scalars['jsonb']>;
  status: InputMaybe<Scalars['String']>;
  text: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type News_Sum_Fields = {
  __typename?: 'news_sum_fields';
  id: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
};

/** update columns of table "news" */
export enum News_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Library = 'library',
  /** column name */
  Link = 'link',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Source = 'source',
  /** column name */
  Status = 'status',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type News_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<News_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<News_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<News_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<News_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<News_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<News_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<News_Set_Input>;
  /** filter the rows which have to be updated */
  where: News_Bool_Exp;
};

/** aggregate var_pop on columns */
export type News_Var_Pop_Fields = {
  __typename?: 'news_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type News_Var_Samp_Fields = {
  __typename?: 'news_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type News_Variance_Fields = {
  __typename?: 'news_variance_fields';
  id: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
};

/** columns and relationships of "notes" */
export type Notes = {
  __typename?: 'notes';
  audience: Maybe<Scalars['String']>;
  /** An array relationship */
  comments: Array<Comments>;
  /** An aggregate relationship */
  comments_aggregate: Comments_Aggregate;
  created_at: Scalars['timestamp'];
  created_by: Scalars['Int'];
  /** An object relationship */
  created_by_user: Maybe<Users_Public>;
  id: Scalars['Int'];
  /** An array relationship */
  likes: Array<Likes>;
  /** An aggregate relationship */
  likes_aggregate: Likes_Aggregate;
  notes: Scalars['String'];
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user_group: Maybe<User_Groups>;
  user_group_id: Maybe<Scalars['Int']>;
};


/** columns and relationships of "notes" */
export type NotesCommentsArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


/** columns and relationships of "notes" */
export type NotesComments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


/** columns and relationships of "notes" */
export type NotesLikesArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


/** columns and relationships of "notes" */
export type NotesLikes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};

/** aggregated selection of "notes" */
export type Notes_Aggregate = {
  __typename?: 'notes_aggregate';
  aggregate: Maybe<Notes_Aggregate_Fields>;
  nodes: Array<Notes>;
};

export type Notes_Aggregate_Bool_Exp = {
  count: InputMaybe<Notes_Aggregate_Bool_Exp_Count>;
};

export type Notes_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Notes_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Notes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "notes" */
export type Notes_Aggregate_Fields = {
  __typename?: 'notes_aggregate_fields';
  avg: Maybe<Notes_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Notes_Max_Fields>;
  min: Maybe<Notes_Min_Fields>;
  stddev: Maybe<Notes_Stddev_Fields>;
  stddev_pop: Maybe<Notes_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Notes_Stddev_Samp_Fields>;
  sum: Maybe<Notes_Sum_Fields>;
  var_pop: Maybe<Notes_Var_Pop_Fields>;
  var_samp: Maybe<Notes_Var_Samp_Fields>;
  variance: Maybe<Notes_Variance_Fields>;
};


/** aggregate fields of "notes" */
export type Notes_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Notes_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "notes" */
export type Notes_Aggregate_Order_By = {
  avg: InputMaybe<Notes_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Notes_Max_Order_By>;
  min: InputMaybe<Notes_Min_Order_By>;
  stddev: InputMaybe<Notes_Stddev_Order_By>;
  stddev_pop: InputMaybe<Notes_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Notes_Stddev_Samp_Order_By>;
  sum: InputMaybe<Notes_Sum_Order_By>;
  var_pop: InputMaybe<Notes_Var_Pop_Order_By>;
  var_samp: InputMaybe<Notes_Var_Samp_Order_By>;
  variance: InputMaybe<Notes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "notes" */
export type Notes_Arr_Rel_Insert_Input = {
  data: Array<Notes_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Notes_On_Conflict>;
};

/** aggregate avg on columns */
export type Notes_Avg_Fields = {
  __typename?: 'notes_avg_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "notes" */
export type Notes_Avg_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'. */
export type Notes_Bool_Exp = {
  _and: InputMaybe<Array<Notes_Bool_Exp>>;
  _not: InputMaybe<Notes_Bool_Exp>;
  _or: InputMaybe<Array<Notes_Bool_Exp>>;
  audience: InputMaybe<String_Comparison_Exp>;
  comments: InputMaybe<Comments_Bool_Exp>;
  comments_aggregate: InputMaybe<Comments_Aggregate_Bool_Exp>;
  created_at: InputMaybe<Timestamp_Comparison_Exp>;
  created_by: InputMaybe<Int_Comparison_Exp>;
  created_by_user: InputMaybe<Users_Public_Bool_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  likes: InputMaybe<Likes_Bool_Exp>;
  likes_aggregate: InputMaybe<Likes_Aggregate_Bool_Exp>;
  notes: InputMaybe<String_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  user_group: InputMaybe<User_Groups_Bool_Exp>;
  user_group_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "notes" */
export enum Notes_Constraint {
  /** unique or primary key constraint on columns "id" */
  NotesPkey = 'notes_pkey'
}

/** input type for incrementing numeric columns in table "notes" */
export type Notes_Inc_Input = {
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "notes" */
export type Notes_Insert_Input = {
  audience: InputMaybe<Scalars['String']>;
  comments: InputMaybe<Comments_Arr_Rel_Insert_Input>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  created_by_user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['Int']>;
  likes: InputMaybe<Likes_Arr_Rel_Insert_Input>;
  notes: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_group: InputMaybe<User_Groups_Obj_Rel_Insert_Input>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Notes_Max_Fields = {
  __typename?: 'notes_max_fields';
  audience: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamp']>;
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  notes: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "notes" */
export type Notes_Max_Order_By = {
  audience: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notes: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Notes_Min_Fields = {
  __typename?: 'notes_min_fields';
  audience: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamp']>;
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  notes: Maybe<Scalars['String']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "notes" */
export type Notes_Min_Order_By = {
  audience: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notes: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "notes" */
export type Notes_Mutation_Response = {
  __typename?: 'notes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Notes>;
};

/** input type for inserting object relation for remote table "notes" */
export type Notes_Obj_Rel_Insert_Input = {
  data: Notes_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Notes_On_Conflict>;
};

/** on_conflict condition type for table "notes" */
export type Notes_On_Conflict = {
  constraint: Notes_Constraint;
  update_columns: Array<Notes_Update_Column>;
  where: InputMaybe<Notes_Bool_Exp>;
};

/** Ordering options when selecting data from "notes". */
export type Notes_Order_By = {
  audience: InputMaybe<Order_By>;
  comments_aggregate: InputMaybe<Comments_Aggregate_Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Order_By>;
  created_by_user: InputMaybe<Users_Public_Order_By>;
  id: InputMaybe<Order_By>;
  likes_aggregate: InputMaybe<Likes_Aggregate_Order_By>;
  notes: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_group: InputMaybe<User_Groups_Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: notes */
export type Notes_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "notes" */
export enum Notes_Select_Column {
  /** column name */
  Audience = 'audience',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserGroupId = 'user_group_id'
}

/** input type for updating data in table "notes" */
export type Notes_Set_Input = {
  audience: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  notes: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Notes_Stddev_Fields = {
  __typename?: 'notes_stddev_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "notes" */
export type Notes_Stddev_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Notes_Stddev_Pop_Fields = {
  __typename?: 'notes_stddev_pop_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "notes" */
export type Notes_Stddev_Pop_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Notes_Stddev_Samp_Fields = {
  __typename?: 'notes_stddev_samp_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "notes" */
export type Notes_Stddev_Samp_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "notes" */
export type Notes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notes_Stream_Cursor_Value_Input = {
  audience: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  notes: InputMaybe<Scalars['String']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Notes_Sum_Fields = {
  __typename?: 'notes_sum_fields';
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "notes" */
export type Notes_Sum_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** update columns of table "notes" */
export enum Notes_Update_Column {
  /** column name */
  Audience = 'audience',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserGroupId = 'user_group_id'
}

export type Notes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Notes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Notes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Notes_Var_Pop_Fields = {
  __typename?: 'notes_var_pop_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "notes" */
export type Notes_Var_Pop_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Notes_Var_Samp_Fields = {
  __typename?: 'notes_var_samp_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "notes" */
export type Notes_Var_Samp_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Notes_Variance_Fields = {
  __typename?: 'notes_variance_fields';
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "notes" */
export type Notes_Variance_Order_By = {
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** columns and relationships of "notification_actions" */
export type Notification_Actions = {
  __typename?: 'notification_actions';
  /** An object relationship */
  action: Maybe<Actions>;
  action_id: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  notification: Maybe<Notifications>;
  notification_id: Scalars['Int'];
};

/** aggregated selection of "notification_actions" */
export type Notification_Actions_Aggregate = {
  __typename?: 'notification_actions_aggregate';
  aggregate: Maybe<Notification_Actions_Aggregate_Fields>;
  nodes: Array<Notification_Actions>;
};

export type Notification_Actions_Aggregate_Bool_Exp = {
  count: InputMaybe<Notification_Actions_Aggregate_Bool_Exp_Count>;
};

export type Notification_Actions_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Notification_Actions_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Notification_Actions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "notification_actions" */
export type Notification_Actions_Aggregate_Fields = {
  __typename?: 'notification_actions_aggregate_fields';
  avg: Maybe<Notification_Actions_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Notification_Actions_Max_Fields>;
  min: Maybe<Notification_Actions_Min_Fields>;
  stddev: Maybe<Notification_Actions_Stddev_Fields>;
  stddev_pop: Maybe<Notification_Actions_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Notification_Actions_Stddev_Samp_Fields>;
  sum: Maybe<Notification_Actions_Sum_Fields>;
  var_pop: Maybe<Notification_Actions_Var_Pop_Fields>;
  var_samp: Maybe<Notification_Actions_Var_Samp_Fields>;
  variance: Maybe<Notification_Actions_Variance_Fields>;
};


/** aggregate fields of "notification_actions" */
export type Notification_Actions_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Notification_Actions_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "notification_actions" */
export type Notification_Actions_Aggregate_Order_By = {
  avg: InputMaybe<Notification_Actions_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Notification_Actions_Max_Order_By>;
  min: InputMaybe<Notification_Actions_Min_Order_By>;
  stddev: InputMaybe<Notification_Actions_Stddev_Order_By>;
  stddev_pop: InputMaybe<Notification_Actions_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Notification_Actions_Stddev_Samp_Order_By>;
  sum: InputMaybe<Notification_Actions_Sum_Order_By>;
  var_pop: InputMaybe<Notification_Actions_Var_Pop_Order_By>;
  var_samp: InputMaybe<Notification_Actions_Var_Samp_Order_By>;
  variance: InputMaybe<Notification_Actions_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "notification_actions" */
export type Notification_Actions_Arr_Rel_Insert_Input = {
  data: Array<Notification_Actions_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Notification_Actions_On_Conflict>;
};

/** aggregate avg on columns */
export type Notification_Actions_Avg_Fields = {
  __typename?: 'notification_actions_avg_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "notification_actions" */
export type Notification_Actions_Avg_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "notification_actions". All fields are combined with a logical 'AND'. */
export type Notification_Actions_Bool_Exp = {
  _and: InputMaybe<Array<Notification_Actions_Bool_Exp>>;
  _not: InputMaybe<Notification_Actions_Bool_Exp>;
  _or: InputMaybe<Array<Notification_Actions_Bool_Exp>>;
  action: InputMaybe<Actions_Bool_Exp>;
  action_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  notification: InputMaybe<Notifications_Bool_Exp>;
  notification_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "notification_actions" */
export enum Notification_Actions_Constraint {
  /** unique or primary key constraint on columns "id" */
  NotificationActionsPkey = 'notification_actions_pkey'
}

/** input type for incrementing numeric columns in table "notification_actions" */
export type Notification_Actions_Inc_Input = {
  action_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  notification_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "notification_actions" */
export type Notification_Actions_Insert_Input = {
  action: InputMaybe<Actions_Obj_Rel_Insert_Input>;
  action_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  notification: InputMaybe<Notifications_Obj_Rel_Insert_Input>;
  notification_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Notification_Actions_Max_Fields = {
  __typename?: 'notification_actions_max_fields';
  action_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  notification_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "notification_actions" */
export type Notification_Actions_Max_Order_By = {
  action_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Notification_Actions_Min_Fields = {
  __typename?: 'notification_actions_min_fields';
  action_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  notification_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "notification_actions" */
export type Notification_Actions_Min_Order_By = {
  action_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "notification_actions" */
export type Notification_Actions_Mutation_Response = {
  __typename?: 'notification_actions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Notification_Actions>;
};

/** on_conflict condition type for table "notification_actions" */
export type Notification_Actions_On_Conflict = {
  constraint: Notification_Actions_Constraint;
  update_columns: Array<Notification_Actions_Update_Column>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};

/** Ordering options when selecting data from "notification_actions". */
export type Notification_Actions_Order_By = {
  action: InputMaybe<Actions_Order_By>;
  action_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification: InputMaybe<Notifications_Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: notification_actions */
export type Notification_Actions_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "notification_actions" */
export enum Notification_Actions_Select_Column {
  /** column name */
  ActionId = 'action_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NotificationId = 'notification_id'
}

/** input type for updating data in table "notification_actions" */
export type Notification_Actions_Set_Input = {
  action_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  notification_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Notification_Actions_Stddev_Fields = {
  __typename?: 'notification_actions_stddev_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "notification_actions" */
export type Notification_Actions_Stddev_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Notification_Actions_Stddev_Pop_Fields = {
  __typename?: 'notification_actions_stddev_pop_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "notification_actions" */
export type Notification_Actions_Stddev_Pop_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Notification_Actions_Stddev_Samp_Fields = {
  __typename?: 'notification_actions_stddev_samp_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "notification_actions" */
export type Notification_Actions_Stddev_Samp_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "notification_actions" */
export type Notification_Actions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notification_Actions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notification_Actions_Stream_Cursor_Value_Input = {
  action_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  notification_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Notification_Actions_Sum_Fields = {
  __typename?: 'notification_actions_sum_fields';
  action_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  notification_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "notification_actions" */
export type Notification_Actions_Sum_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** update columns of table "notification_actions" */
export enum Notification_Actions_Update_Column {
  /** column name */
  ActionId = 'action_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  NotificationId = 'notification_id'
}

export type Notification_Actions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Notification_Actions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Notification_Actions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notification_Actions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Notification_Actions_Var_Pop_Fields = {
  __typename?: 'notification_actions_var_pop_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "notification_actions" */
export type Notification_Actions_Var_Pop_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Notification_Actions_Var_Samp_Fields = {
  __typename?: 'notification_actions_var_samp_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "notification_actions" */
export type Notification_Actions_Var_Samp_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Notification_Actions_Variance_Fields = {
  __typename?: 'notification_actions_variance_fields';
  action_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "notification_actions" */
export type Notification_Actions_Variance_Order_By = {
  action_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  notification_id: InputMaybe<Order_By>;
};

/** columns and relationships of "notifications" */
export type Notifications = {
  __typename?: 'notifications';
  action_ids: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  company: Maybe<Companies>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  event_type: Scalars['String'];
  follow_resource_type: Scalars['String'];
  id: Scalars['Int'];
  message: Maybe<Scalars['String']>;
  /** An array relationship */
  notification_actions: Array<Notification_Actions>;
  /** An aggregate relationship */
  notification_actions_aggregate: Notification_Actions_Aggregate;
  notification_resource_id: Maybe<Scalars['Int']>;
  notification_resource_type: Scalars['String'];
  read: Scalars['Boolean'];
  read_at: Maybe<Scalars['timestamptz']>;
  target_user_id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
  vc_firm_id: Maybe<Scalars['Int']>;
};


/** columns and relationships of "notifications" */
export type NotificationsAction_IdsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "notifications" */
export type NotificationsNotification_ActionsArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


/** columns and relationships of "notifications" */
export type NotificationsNotification_Actions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};

/** aggregated selection of "notifications" */
export type Notifications_Aggregate = {
  __typename?: 'notifications_aggregate';
  aggregate: Maybe<Notifications_Aggregate_Fields>;
  nodes: Array<Notifications>;
};

/** aggregate fields of "notifications" */
export type Notifications_Aggregate_Fields = {
  __typename?: 'notifications_aggregate_fields';
  avg: Maybe<Notifications_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Notifications_Max_Fields>;
  min: Maybe<Notifications_Min_Fields>;
  stddev: Maybe<Notifications_Stddev_Fields>;
  stddev_pop: Maybe<Notifications_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Notifications_Stddev_Samp_Fields>;
  sum: Maybe<Notifications_Sum_Fields>;
  var_pop: Maybe<Notifications_Var_Pop_Fields>;
  var_samp: Maybe<Notifications_Var_Samp_Fields>;
  variance: Maybe<Notifications_Variance_Fields>;
};


/** aggregate fields of "notifications" */
export type Notifications_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Notifications_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Notifications_Append_Input = {
  action_ids: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Notifications_Avg_Fields = {
  __typename?: 'notifications_avg_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'. */
export type Notifications_Bool_Exp = {
  _and: InputMaybe<Array<Notifications_Bool_Exp>>;
  _not: InputMaybe<Notifications_Bool_Exp>;
  _or: InputMaybe<Array<Notifications_Bool_Exp>>;
  action_ids: InputMaybe<Jsonb_Comparison_Exp>;
  company: InputMaybe<Companies_Bool_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  event_type: InputMaybe<String_Comparison_Exp>;
  follow_resource_type: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  message: InputMaybe<String_Comparison_Exp>;
  notification_actions: InputMaybe<Notification_Actions_Bool_Exp>;
  notification_actions_aggregate: InputMaybe<Notification_Actions_Aggregate_Bool_Exp>;
  notification_resource_id: InputMaybe<Int_Comparison_Exp>;
  notification_resource_type: InputMaybe<String_Comparison_Exp>;
  read: InputMaybe<Boolean_Comparison_Exp>;
  read_at: InputMaybe<Timestamptz_Comparison_Exp>;
  target_user_id: InputMaybe<Int_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "notifications" */
export enum Notifications_Constraint {
  /** unique or primary key constraint on columns "id" */
  NotificationsPkey = 'notifications_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Notifications_Delete_At_Path_Input = {
  action_ids: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Notifications_Delete_Elem_Input = {
  action_ids: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Notifications_Delete_Key_Input = {
  action_ids: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "notifications" */
export type Notifications_Inc_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  notification_resource_id: InputMaybe<Scalars['Int']>;
  target_user_id: InputMaybe<Scalars['Int']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "notifications" */
export type Notifications_Insert_Input = {
  action_ids: InputMaybe<Scalars['jsonb']>;
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_type: InputMaybe<Scalars['String']>;
  follow_resource_type: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  message: InputMaybe<Scalars['String']>;
  notification_actions: InputMaybe<Notification_Actions_Arr_Rel_Insert_Input>;
  notification_resource_id: InputMaybe<Scalars['Int']>;
  notification_resource_type: InputMaybe<Scalars['String']>;
  read: InputMaybe<Scalars['Boolean']>;
  read_at: InputMaybe<Scalars['timestamptz']>;
  target_user_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Notifications_Max_Fields = {
  __typename?: 'notifications_max_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  event_type: Maybe<Scalars['String']>;
  follow_resource_type: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  message: Maybe<Scalars['String']>;
  notification_resource_id: Maybe<Scalars['Int']>;
  notification_resource_type: Maybe<Scalars['String']>;
  read_at: Maybe<Scalars['timestamptz']>;
  target_user_id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Notifications_Min_Fields = {
  __typename?: 'notifications_min_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  event_type: Maybe<Scalars['String']>;
  follow_resource_type: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  message: Maybe<Scalars['String']>;
  notification_resource_id: Maybe<Scalars['Int']>;
  notification_resource_type: Maybe<Scalars['String']>;
  read_at: Maybe<Scalars['timestamptz']>;
  target_user_id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "notifications" */
export type Notifications_Mutation_Response = {
  __typename?: 'notifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Notifications>;
};

/** input type for inserting object relation for remote table "notifications" */
export type Notifications_Obj_Rel_Insert_Input = {
  data: Notifications_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Notifications_On_Conflict>;
};

/** on_conflict condition type for table "notifications" */
export type Notifications_On_Conflict = {
  constraint: Notifications_Constraint;
  update_columns: Array<Notifications_Update_Column>;
  where: InputMaybe<Notifications_Bool_Exp>;
};

/** Ordering options when selecting data from "notifications". */
export type Notifications_Order_By = {
  action_ids: InputMaybe<Order_By>;
  company: InputMaybe<Companies_Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  event_type: InputMaybe<Order_By>;
  follow_resource_type: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  message: InputMaybe<Order_By>;
  notification_actions_aggregate: InputMaybe<Notification_Actions_Aggregate_Order_By>;
  notification_resource_id: InputMaybe<Order_By>;
  notification_resource_type: InputMaybe<Order_By>;
  read: InputMaybe<Order_By>;
  read_at: InputMaybe<Order_By>;
  target_user_id: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
  vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: notifications */
export type Notifications_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Notifications_Prepend_Input = {
  action_ids: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "notifications" */
export enum Notifications_Select_Column {
  /** column name */
  ActionIds = 'action_ids',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventType = 'event_type',
  /** column name */
  FollowResourceType = 'follow_resource_type',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  NotificationResourceId = 'notification_resource_id',
  /** column name */
  NotificationResourceType = 'notification_resource_type',
  /** column name */
  Read = 'read',
  /** column name */
  ReadAt = 'read_at',
  /** column name */
  TargetUserId = 'target_user_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

/** input type for updating data in table "notifications" */
export type Notifications_Set_Input = {
  action_ids: InputMaybe<Scalars['jsonb']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_type: InputMaybe<Scalars['String']>;
  follow_resource_type: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  message: InputMaybe<Scalars['String']>;
  notification_resource_id: InputMaybe<Scalars['Int']>;
  notification_resource_type: InputMaybe<Scalars['String']>;
  read: InputMaybe<Scalars['Boolean']>;
  read_at: InputMaybe<Scalars['timestamptz']>;
  target_user_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Notifications_Stddev_Fields = {
  __typename?: 'notifications_stddev_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Notifications_Stddev_Pop_Fields = {
  __typename?: 'notifications_stddev_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Notifications_Stddev_Samp_Fields = {
  __typename?: 'notifications_stddev_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "notifications" */
export type Notifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notifications_Stream_Cursor_Value_Input = {
  action_ids: InputMaybe<Scalars['jsonb']>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  event_type: InputMaybe<Scalars['String']>;
  follow_resource_type: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  message: InputMaybe<Scalars['String']>;
  notification_resource_id: InputMaybe<Scalars['Int']>;
  notification_resource_type: InputMaybe<Scalars['String']>;
  read: InputMaybe<Scalars['Boolean']>;
  read_at: InputMaybe<Scalars['timestamptz']>;
  target_user_id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Notifications_Sum_Fields = {
  __typename?: 'notifications_sum_fields';
  company_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  notification_resource_id: Maybe<Scalars['Int']>;
  target_user_id: Maybe<Scalars['Int']>;
  vc_firm_id: Maybe<Scalars['Int']>;
};

/** update columns of table "notifications" */
export enum Notifications_Update_Column {
  /** column name */
  ActionIds = 'action_ids',
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventType = 'event_type',
  /** column name */
  FollowResourceType = 'follow_resource_type',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  NotificationResourceId = 'notification_resource_id',
  /** column name */
  NotificationResourceType = 'notification_resource_type',
  /** column name */
  Read = 'read',
  /** column name */
  ReadAt = 'read_at',
  /** column name */
  TargetUserId = 'target_user_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VcFirmId = 'vc_firm_id'
}

export type Notifications_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Notifications_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Notifications_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Notifications_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Notifications_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Notifications_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Notifications_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Notifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Notifications_Var_Pop_Fields = {
  __typename?: 'notifications_var_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Notifications_Var_Samp_Fields = {
  __typename?: 'notifications_var_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Notifications_Variance_Fields = {
  __typename?: 'notifications_variance_fields';
  company_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  notification_resource_id: Maybe<Scalars['Float']>;
  target_user_id: Maybe<Scalars['Float']>;
  vc_firm_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq: InputMaybe<Scalars['numeric']>;
  _gt: InputMaybe<Scalars['numeric']>;
  _gte: InputMaybe<Scalars['numeric']>;
  _in: InputMaybe<Array<Scalars['numeric']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['numeric']>;
  _lte: InputMaybe<Scalars['numeric']>;
  _neq: InputMaybe<Scalars['numeric']>;
  _nin: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "people" */
export type People = {
  __typename?: 'people';
  about: Maybe<Scalars['String']>;
  city: Maybe<Scalars['String']>;
  country: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Maybe<Scalars['Int']>;
  discord: Maybe<Scalars['String']>;
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: Maybe<Scalars['jsonb']>;
  enrichment_priority: Scalars['Int'];
  external_id: Maybe<Scalars['String']>;
  facebook_url: Maybe<Scalars['String']>;
  /** An array relationship */
  follows: Array<Follows_People>;
  /** An aggregate relationship */
  follows_aggregate: Follows_People_Aggregate;
  geopoint: Maybe<Scalars['geography']>;
  github: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An array relationship */
  investments: Array<Investments>;
  /** An aggregate relationship */
  investments_aggregate: Investments_Aggregate;
  /** An array relationship */
  investors: Array<Investors>;
  /** An aggregate relationship */
  investors_aggregate: Investors_Aggregate;
  latitude: Maybe<Scalars['float8']>;
  library: Maybe<Scalars['jsonb']>;
  linkedin: Maybe<Scalars['String']>;
  location_json: Maybe<Scalars['jsonb']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  /** An array relationship */
  news_links: Array<News_Person>;
  /** An aggregate relationship */
  news_links_aggregate: News_Person_Aggregate;
  /** An object relationship */
  people_computed_data: Maybe<People_Computed_Data>;
  personal_email: Maybe<Scalars['String']>;
  picture: Maybe<Scalars['jsonb']>;
  slug: Scalars['String'];
  status: Scalars['String'];
  /** An array relationship */
  team_members: Array<Team_Members>;
  /** An aggregate relationship */
  team_members_aggregate: Team_Members_Aggregate;
  telegram: Maybe<Scalars['String']>;
  twitter_url: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user: Maybe<Users_Public>;
  web3_address: Maybe<Scalars['jsonb']>;
  website_url: Maybe<Scalars['String']>;
  work_email: Maybe<Scalars['String']>;
};


/** columns and relationships of "people" */
export type PeopleEmailArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "people" */
export type PeopleFollowsArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleFollows_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleInvestmentsArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleInvestments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleInvestorsArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleInvestors_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleLibraryArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "people" */
export type PeopleLocation_JsonArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "people" */
export type PeopleNews_LinksArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleNews_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeoplePictureArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "people" */
export type PeopleTeam_MembersArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleTeam_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


/** columns and relationships of "people" */
export type PeopleWeb3_AddressArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "people" */
export type People_Aggregate = {
  __typename?: 'people_aggregate';
  aggregate: Maybe<People_Aggregate_Fields>;
  nodes: Array<People>;
};

/** aggregate fields of "people" */
export type People_Aggregate_Fields = {
  __typename?: 'people_aggregate_fields';
  avg: Maybe<People_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<People_Max_Fields>;
  min: Maybe<People_Min_Fields>;
  stddev: Maybe<People_Stddev_Fields>;
  stddev_pop: Maybe<People_Stddev_Pop_Fields>;
  stddev_samp: Maybe<People_Stddev_Samp_Fields>;
  sum: Maybe<People_Sum_Fields>;
  var_pop: Maybe<People_Var_Pop_Fields>;
  var_samp: Maybe<People_Var_Samp_Fields>;
  variance: Maybe<People_Variance_Fields>;
};


/** aggregate fields of "people" */
export type People_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<People_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type People_Append_Input = {
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['jsonb']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  picture: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type People_Avg_Fields = {
  __typename?: 'people_avg_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "people". All fields are combined with a logical 'AND'. */
export type People_Bool_Exp = {
  _and: InputMaybe<Array<People_Bool_Exp>>;
  _not: InputMaybe<People_Bool_Exp>;
  _or: InputMaybe<Array<People_Bool_Exp>>;
  about: InputMaybe<String_Comparison_Exp>;
  city: InputMaybe<String_Comparison_Exp>;
  country: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  datapoints_count: InputMaybe<Int_Comparison_Exp>;
  discord: InputMaybe<String_Comparison_Exp>;
  email: InputMaybe<Jsonb_Comparison_Exp>;
  enrichment_priority: InputMaybe<Int_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  facebook_url: InputMaybe<String_Comparison_Exp>;
  follows: InputMaybe<Follows_People_Bool_Exp>;
  follows_aggregate: InputMaybe<Follows_People_Aggregate_Bool_Exp>;
  geopoint: InputMaybe<Geography_Comparison_Exp>;
  github: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  investments: InputMaybe<Investments_Bool_Exp>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Bool_Exp>;
  investors: InputMaybe<Investors_Bool_Exp>;
  investors_aggregate: InputMaybe<Investors_Aggregate_Bool_Exp>;
  latitude: InputMaybe<Float8_Comparison_Exp>;
  library: InputMaybe<Jsonb_Comparison_Exp>;
  linkedin: InputMaybe<String_Comparison_Exp>;
  location_json: InputMaybe<Jsonb_Comparison_Exp>;
  longitude: InputMaybe<Float8_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  news_links: InputMaybe<News_Person_Bool_Exp>;
  news_links_aggregate: InputMaybe<News_Person_Aggregate_Bool_Exp>;
  people_computed_data: InputMaybe<People_Computed_Data_Bool_Exp>;
  personal_email: InputMaybe<String_Comparison_Exp>;
  picture: InputMaybe<Jsonb_Comparison_Exp>;
  slug: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  team_members: InputMaybe<Team_Members_Bool_Exp>;
  team_members_aggregate: InputMaybe<Team_Members_Aggregate_Bool_Exp>;
  telegram: InputMaybe<String_Comparison_Exp>;
  twitter_url: InputMaybe<String_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  user: InputMaybe<Users_Public_Bool_Exp>;
  web3_address: InputMaybe<Jsonb_Comparison_Exp>;
  website_url: InputMaybe<String_Comparison_Exp>;
  work_email: InputMaybe<String_Comparison_Exp>;
};

/** Computed data from its relations for better performance */
export type People_Computed_Data = {
  __typename?: 'people_computed_data';
  geopoint: Maybe<Scalars['geography']>;
  id: Scalars['Int'];
  location_json: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  people_computed_data_person: People;
  person_id: Scalars['Int'];
  tags: Maybe<Scalars['jsonb']>;
  title: Maybe<Scalars['String']>;
};


/** Computed data from its relations for better performance */
export type People_Computed_DataLocation_JsonArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** Computed data from its relations for better performance */
export type People_Computed_DataTagsArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "people_computed_data" */
export type People_Computed_Data_Aggregate = {
  __typename?: 'people_computed_data_aggregate';
  aggregate: Maybe<People_Computed_Data_Aggregate_Fields>;
  nodes: Array<People_Computed_Data>;
};

/** aggregate fields of "people_computed_data" */
export type People_Computed_Data_Aggregate_Fields = {
  __typename?: 'people_computed_data_aggregate_fields';
  avg: Maybe<People_Computed_Data_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<People_Computed_Data_Max_Fields>;
  min: Maybe<People_Computed_Data_Min_Fields>;
  stddev: Maybe<People_Computed_Data_Stddev_Fields>;
  stddev_pop: Maybe<People_Computed_Data_Stddev_Pop_Fields>;
  stddev_samp: Maybe<People_Computed_Data_Stddev_Samp_Fields>;
  sum: Maybe<People_Computed_Data_Sum_Fields>;
  var_pop: Maybe<People_Computed_Data_Var_Pop_Fields>;
  var_samp: Maybe<People_Computed_Data_Var_Samp_Fields>;
  variance: Maybe<People_Computed_Data_Variance_Fields>;
};


/** aggregate fields of "people_computed_data" */
export type People_Computed_Data_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<People_Computed_Data_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type People_Computed_Data_Append_Input = {
  location_json: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type People_Computed_Data_Avg_Fields = {
  __typename?: 'people_computed_data_avg_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "people_computed_data". All fields are combined with a logical 'AND'. */
export type People_Computed_Data_Bool_Exp = {
  _and: InputMaybe<Array<People_Computed_Data_Bool_Exp>>;
  _not: InputMaybe<People_Computed_Data_Bool_Exp>;
  _or: InputMaybe<Array<People_Computed_Data_Bool_Exp>>;
  geopoint: InputMaybe<Geography_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  location_json: InputMaybe<Jsonb_Comparison_Exp>;
  people_computed_data_person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  tags: InputMaybe<Jsonb_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "people_computed_data" */
export enum People_Computed_Data_Constraint {
  /** unique or primary key constraint on columns "person_id" */
  PeopleComputedDataPersonIdKey = 'people_computed_data_person_id_key',
  /** unique or primary key constraint on columns "id" */
  PeopleComputedDataPkey = 'people_computed_data_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type People_Computed_Data_Delete_At_Path_Input = {
  location_json: InputMaybe<Array<Scalars['String']>>;
  tags: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type People_Computed_Data_Delete_Elem_Input = {
  location_json: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type People_Computed_Data_Delete_Key_Input = {
  location_json: InputMaybe<Scalars['String']>;
  tags: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "people_computed_data" */
export type People_Computed_Data_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "people_computed_data" */
export type People_Computed_Data_Insert_Input = {
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  people_computed_data_person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['jsonb']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type People_Computed_Data_Max_Fields = {
  __typename?: 'people_computed_data_max_fields';
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  title: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type People_Computed_Data_Min_Fields = {
  __typename?: 'people_computed_data_min_fields';
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  title: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "people_computed_data" */
export type People_Computed_Data_Mutation_Response = {
  __typename?: 'people_computed_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<People_Computed_Data>;
};

/** input type for inserting object relation for remote table "people_computed_data" */
export type People_Computed_Data_Obj_Rel_Insert_Input = {
  data: People_Computed_Data_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<People_Computed_Data_On_Conflict>;
};

/** on_conflict condition type for table "people_computed_data" */
export type People_Computed_Data_On_Conflict = {
  constraint: People_Computed_Data_Constraint;
  update_columns: Array<People_Computed_Data_Update_Column>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};

/** Ordering options when selecting data from "people_computed_data". */
export type People_Computed_Data_Order_By = {
  geopoint: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  location_json: InputMaybe<Order_By>;
  people_computed_data_person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  tags: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** primary key columns input for table: people_computed_data */
export type People_Computed_Data_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type People_Computed_Data_Prepend_Input = {
  location_json: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "people_computed_data" */
export enum People_Computed_Data_Select_Column {
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  Title = 'title'
}

/** input type for updating data in table "people_computed_data" */
export type People_Computed_Data_Set_Input = {
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  person_id: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['jsonb']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type People_Computed_Data_Stddev_Fields = {
  __typename?: 'people_computed_data_stddev_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type People_Computed_Data_Stddev_Pop_Fields = {
  __typename?: 'people_computed_data_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type People_Computed_Data_Stddev_Samp_Fields = {
  __typename?: 'people_computed_data_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "people_computed_data" */
export type People_Computed_Data_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: People_Computed_Data_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type People_Computed_Data_Stream_Cursor_Value_Input = {
  geopoint: InputMaybe<Scalars['geography']>;
  id: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  person_id: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['jsonb']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type People_Computed_Data_Sum_Fields = {
  __typename?: 'people_computed_data_sum_fields';
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** update columns of table "people_computed_data" */
export enum People_Computed_Data_Update_Column {
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  Title = 'title'
}

export type People_Computed_Data_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<People_Computed_Data_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<People_Computed_Data_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<People_Computed_Data_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<People_Computed_Data_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<People_Computed_Data_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<People_Computed_Data_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<People_Computed_Data_Set_Input>;
  /** filter the rows which have to be updated */
  where: People_Computed_Data_Bool_Exp;
};

/** aggregate var_pop on columns */
export type People_Computed_Data_Var_Pop_Fields = {
  __typename?: 'people_computed_data_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type People_Computed_Data_Var_Samp_Fields = {
  __typename?: 'people_computed_data_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type People_Computed_Data_Variance_Fields = {
  __typename?: 'people_computed_data_variance_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "people" */
export enum People_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  PeopleExternalIdKey = 'people_external_id_key',
  /** unique or primary key constraint on columns "id" */
  PeoplePkey = 'people_pkey',
  /** unique or primary key constraint on columns "slug" */
  PeopleSlugKey = 'people_slug_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type People_Delete_At_Path_Input = {
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Array<Scalars['String']>>;
  library: InputMaybe<Array<Scalars['String']>>;
  location_json: InputMaybe<Array<Scalars['String']>>;
  picture: InputMaybe<Array<Scalars['String']>>;
  web3_address: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type People_Delete_Elem_Input = {
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['Int']>;
  library: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['Int']>;
  picture: InputMaybe<Scalars['Int']>;
  web3_address: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type People_Delete_Key_Input = {
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['String']>;
  library: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['String']>;
  picture: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "people" */
export type People_Inc_Input = {
  datapoints_count: InputMaybe<Scalars['Int']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  latitude: InputMaybe<Scalars['float8']>;
  longitude: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "people" */
export type People_Insert_Input = {
  about: InputMaybe<Scalars['String']>;
  city: InputMaybe<Scalars['String']>;
  country: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['jsonb']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook_url: InputMaybe<Scalars['String']>;
  follows: InputMaybe<Follows_People_Arr_Rel_Insert_Input>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investments: InputMaybe<Investments_Arr_Rel_Insert_Input>;
  investors: InputMaybe<Investors_Arr_Rel_Insert_Input>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  news_links: InputMaybe<News_Person_Arr_Rel_Insert_Input>;
  people_computed_data: InputMaybe<People_Computed_Data_Obj_Rel_Insert_Input>;
  personal_email: InputMaybe<Scalars['String']>;
  picture: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  team_members: InputMaybe<Team_Members_Arr_Rel_Insert_Input>;
  telegram: InputMaybe<Scalars['String']>;
  twitter_url: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  website_url: InputMaybe<Scalars['String']>;
  work_email: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type People_Max_Fields = {
  __typename?: 'people_max_fields';
  about: Maybe<Scalars['String']>;
  city: Maybe<Scalars['String']>;
  country: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Maybe<Scalars['Int']>;
  discord: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  facebook_url: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  latitude: Maybe<Scalars['float8']>;
  linkedin: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  personal_email: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  twitter_url: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  website_url: Maybe<Scalars['String']>;
  work_email: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type People_Min_Fields = {
  __typename?: 'people_min_fields';
  about: Maybe<Scalars['String']>;
  city: Maybe<Scalars['String']>;
  country: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Maybe<Scalars['Int']>;
  discord: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  facebook_url: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  latitude: Maybe<Scalars['float8']>;
  linkedin: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  personal_email: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  twitter_url: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  website_url: Maybe<Scalars['String']>;
  work_email: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "people" */
export type People_Mutation_Response = {
  __typename?: 'people_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<People>;
};

/** input type for inserting object relation for remote table "people" */
export type People_Obj_Rel_Insert_Input = {
  data: People_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<People_On_Conflict>;
};

/** on_conflict condition type for table "people" */
export type People_On_Conflict = {
  constraint: People_Constraint;
  update_columns: Array<People_Update_Column>;
  where: InputMaybe<People_Bool_Exp>;
};

/** Ordering options when selecting data from "people". */
export type People_Order_By = {
  about: InputMaybe<Order_By>;
  city: InputMaybe<Order_By>;
  country: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  datapoints_count: InputMaybe<Order_By>;
  discord: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  facebook_url: InputMaybe<Order_By>;
  follows_aggregate: InputMaybe<Follows_People_Aggregate_Order_By>;
  geopoint: InputMaybe<Order_By>;
  github: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Order_By>;
  investors_aggregate: InputMaybe<Investors_Aggregate_Order_By>;
  latitude: InputMaybe<Order_By>;
  library: InputMaybe<Order_By>;
  linkedin: InputMaybe<Order_By>;
  location_json: InputMaybe<Order_By>;
  longitude: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  news_links_aggregate: InputMaybe<News_Person_Aggregate_Order_By>;
  people_computed_data: InputMaybe<People_Computed_Data_Order_By>;
  personal_email: InputMaybe<Order_By>;
  picture: InputMaybe<Order_By>;
  slug: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  team_members_aggregate: InputMaybe<Team_Members_Aggregate_Order_By>;
  telegram: InputMaybe<Order_By>;
  twitter_url: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user: InputMaybe<Users_Public_Order_By>;
  web3_address: InputMaybe<Order_By>;
  website_url: InputMaybe<Order_By>;
  work_email: InputMaybe<Order_By>;
};

/** primary key columns input for table: people */
export type People_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type People_Prepend_Input = {
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['jsonb']>;
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  picture: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "people" */
export enum People_Select_Column {
  /** column name */
  About = 'about',
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  Discord = 'discord',
  /** column name */
  Email = 'email',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  FacebookUrl = 'facebook_url',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Library = 'library',
  /** column name */
  Linkedin = 'linkedin',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  PersonalEmail = 'personal_email',
  /** column name */
  Picture = 'picture',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  TwitterUrl = 'twitter_url',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebsiteUrl = 'website_url',
  /** column name */
  WorkEmail = 'work_email'
}

/** input type for updating data in table "people" */
export type People_Set_Input = {
  about: InputMaybe<Scalars['String']>;
  city: InputMaybe<Scalars['String']>;
  country: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['jsonb']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook_url: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  personal_email: InputMaybe<Scalars['String']>;
  picture: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter_url: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  website_url: InputMaybe<Scalars['String']>;
  work_email: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type People_Stddev_Fields = {
  __typename?: 'people_stddev_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type People_Stddev_Pop_Fields = {
  __typename?: 'people_stddev_pop_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type People_Stddev_Samp_Fields = {
  __typename?: 'people_stddev_samp_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "people" */
export type People_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: People_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type People_Stream_Cursor_Value_Input = {
  about: InputMaybe<Scalars['String']>;
  city: InputMaybe<Scalars['String']>;
  country: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  /** [{"email": "john@example.com", "isPrimary": false}, {"email": "johny@example.com", "isPrimary": true}] */
  email: InputMaybe<Scalars['jsonb']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  facebook_url: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  personal_email: InputMaybe<Scalars['String']>;
  picture: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter_url: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  website_url: InputMaybe<Scalars['String']>;
  work_email: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type People_Sum_Fields = {
  __typename?: 'people_sum_fields';
  datapoints_count: Maybe<Scalars['Int']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  latitude: Maybe<Scalars['float8']>;
  longitude: Maybe<Scalars['float8']>;
};

/** update columns of table "people" */
export enum People_Update_Column {
  /** column name */
  About = 'about',
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  Discord = 'discord',
  /** column name */
  Email = 'email',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  FacebookUrl = 'facebook_url',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Library = 'library',
  /** column name */
  Linkedin = 'linkedin',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  PersonalEmail = 'personal_email',
  /** column name */
  Picture = 'picture',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  TwitterUrl = 'twitter_url',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebsiteUrl = 'website_url',
  /** column name */
  WorkEmail = 'work_email'
}

export type People_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<People_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<People_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<People_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<People_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<People_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<People_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<People_Set_Input>;
  /** filter the rows which have to be updated */
  where: People_Bool_Exp;
};

/** aggregate var_pop on columns */
export type People_Var_Pop_Fields = {
  __typename?: 'people_var_pop_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type People_Var_Samp_Fields = {
  __typename?: 'people_var_samp_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type People_Variance_Fields = {
  __typename?: 'people_variance_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "actions" */
  actions: Array<Actions>;
  /** fetch aggregated fields from the table: "actions" */
  actions_aggregate: Actions_Aggregate;
  /** fetch data from the table: "actions" using primary key columns */
  actions_by_pk: Maybe<Actions>;
  /** fetch data from the table: "allowed_emails" */
  allowed_emails: Array<Allowed_Emails>;
  /** fetch aggregated fields from the table: "allowed_emails" */
  allowed_emails_aggregate: Allowed_Emails_Aggregate;
  /** fetch data from the table: "allowed_emails" using primary key columns */
  allowed_emails_by_pk: Maybe<Allowed_Emails>;
  /** fetch data from the table: "application_meta" */
  application_meta: Array<Application_Meta>;
  /** fetch aggregated fields from the table: "application_meta" */
  application_meta_aggregate: Application_Meta_Aggregate;
  /** fetch data from the table: "application_meta" using primary key columns */
  application_meta_by_pk: Maybe<Application_Meta>;
  /** fetch data from the table: "billing_org" */
  billing_org: Array<Billing_Org>;
  /** fetch aggregated fields from the table: "billing_org" */
  billing_org_aggregate: Billing_Org_Aggregate;
  /** fetch data from the table: "billing_org" using primary key columns */
  billing_org_by_pk: Maybe<Billing_Org>;
  /** fetch data from the table: "blockchains" */
  blockchains: Array<Blockchains>;
  /** fetch aggregated fields from the table: "blockchains" */
  blockchains_aggregate: Blockchains_Aggregate;
  /** fetch data from the table: "blockchains" using primary key columns */
  blockchains_by_pk: Maybe<Blockchains>;
  /** fetch data from the table: "coins" */
  coins: Array<Coins>;
  /** fetch aggregated fields from the table: "coins" */
  coins_aggregate: Coins_Aggregate;
  /** fetch data from the table: "coins" using primary key columns */
  coins_by_pk: Maybe<Coins>;
  /** An array relationship */
  comments: Array<Comments>;
  /** An aggregate relationship */
  comments_aggregate: Comments_Aggregate;
  /** fetch data from the table: "comments" using primary key columns */
  comments_by_pk: Maybe<Comments>;
  /** fetch data from the table: "companies" */
  companies: Array<Companies>;
  /** fetch aggregated fields from the table: "companies" */
  companies_aggregate: Companies_Aggregate;
  /** fetch data from the table: "companies" using primary key columns */
  companies_by_pk: Maybe<Companies>;
  /** fetch data from the table: "companies_edit_access" */
  companies_edit_access: Array<Companies_Edit_Access>;
  /** fetch aggregated fields from the table: "companies_edit_access" */
  companies_edit_access_aggregate: Companies_Edit_Access_Aggregate;
  /** fetch data from the table: "data_actions" */
  data_actions: Array<Data_Actions>;
  /** fetch aggregated fields from the table: "data_actions" */
  data_actions_aggregate: Data_Actions_Aggregate;
  /** fetch data from the table: "data_actions" using primary key columns */
  data_actions_by_pk: Maybe<Data_Actions>;
  /** fetch data from the table: "data_discard" */
  data_discard: Array<Data_Discard>;
  /** fetch aggregated fields from the table: "data_discard" */
  data_discard_aggregate: Data_Discard_Aggregate;
  /** fetch data from the table: "data_discard" using primary key columns */
  data_discard_by_pk: Maybe<Data_Discard>;
  /** fetch data from the table: "data_fields" */
  data_fields: Array<Data_Fields>;
  /** fetch aggregated fields from the table: "data_fields" */
  data_fields_aggregate: Data_Fields_Aggregate;
  /** fetch data from the table: "data_fields" using primary key columns */
  data_fields_by_pk: Maybe<Data_Fields>;
  /** fetch data from the table: "data_partners" */
  data_partners: Array<Data_Partners>;
  /** fetch aggregated fields from the table: "data_partners" */
  data_partners_aggregate: Data_Partners_Aggregate;
  /** fetch data from the table: "data_partners" using primary key columns */
  data_partners_by_pk: Maybe<Data_Partners>;
  /** fetch data from the table: "data_raw" */
  data_raw: Array<Data_Raw>;
  /** fetch aggregated fields from the table: "data_raw" */
  data_raw_aggregate: Data_Raw_Aggregate;
  /** fetch data from the table: "data_raw" using primary key columns */
  data_raw_by_pk: Maybe<Data_Raw>;
  /** fetch data from the table: "data_runs" */
  data_runs: Array<Data_Runs>;
  /** fetch aggregated fields from the table: "data_runs" */
  data_runs_aggregate: Data_Runs_Aggregate;
  /** fetch data from the table: "data_runs" using primary key columns */
  data_runs_by_pk: Maybe<Data_Runs>;
  /** fetch data from the table: "disabled_emails" */
  disabled_emails: Array<Disabled_Emails>;
  /** fetch aggregated fields from the table: "disabled_emails" */
  disabled_emails_aggregate: Disabled_Emails_Aggregate;
  /** fetch data from the table: "disabled_emails" using primary key columns */
  disabled_emails_by_pk: Maybe<Disabled_Emails>;
  /** An array relationship */
  event_organization: Array<Event_Organization>;
  /** An aggregate relationship */
  event_organization_aggregate: Event_Organization_Aggregate;
  /** fetch data from the table: "event_organization" using primary key columns */
  event_organization_by_pk: Maybe<Event_Organization>;
  /** An array relationship */
  event_person: Array<Event_Person>;
  /** An aggregate relationship */
  event_person_aggregate: Event_Person_Aggregate;
  /** fetch data from the table: "event_person" using primary key columns */
  event_person_by_pk: Maybe<Event_Person>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: Events_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk: Maybe<Events>;
  /** fetch data from the table: "follows" */
  follows: Array<Follows>;
  /** fetch aggregated fields from the table: "follows" */
  follows_aggregate: Follows_Aggregate;
  /** fetch data from the table: "follows" using primary key columns */
  follows_by_pk: Maybe<Follows>;
  /** An array relationship */
  follows_companies: Array<Follows_Companies>;
  /** An aggregate relationship */
  follows_companies_aggregate: Follows_Companies_Aggregate;
  /** An array relationship */
  follows_people: Array<Follows_People>;
  /** An aggregate relationship */
  follows_people_aggregate: Follows_People_Aggregate;
  /** fetch data from the table: "follows_vc_firms" */
  follows_vc_firms: Array<Follows_Vc_Firms>;
  /** fetch aggregated fields from the table: "follows_vc_firms" */
  follows_vc_firms_aggregate: Follows_Vc_Firms_Aggregate;
  /** An array relationship */
  investment_rounds: Array<Investment_Rounds>;
  /** An aggregate relationship */
  investment_rounds_aggregate: Investment_Rounds_Aggregate;
  /** fetch data from the table: "investment_rounds" using primary key columns */
  investment_rounds_by_pk: Maybe<Investment_Rounds>;
  /** An array relationship */
  investments: Array<Investments>;
  /** An aggregate relationship */
  investments_aggregate: Investments_Aggregate;
  /** fetch data from the table: "investments" using primary key columns */
  investments_by_pk: Maybe<Investments>;
  /** An array relationship */
  investors: Array<Investors>;
  /** An aggregate relationship */
  investors_aggregate: Investors_Aggregate;
  /** fetch data from the table: "investors" using primary key columns */
  investors_by_pk: Maybe<Investors>;
  /** fetch data from the table: "invited_people" */
  invited_people: Array<Invited_People>;
  /** fetch aggregated fields from the table: "invited_people" */
  invited_people_aggregate: Invited_People_Aggregate;
  /** fetch data from the table: "invited_people" using primary key columns */
  invited_people_by_pk: Maybe<Invited_People>;
  /** fetch data from the table: "leads" */
  leads: Array<Leads>;
  /** fetch aggregated fields from the table: "leads" */
  leads_aggregate: Leads_Aggregate;
  /** fetch data from the table: "leads" using primary key columns */
  leads_by_pk: Maybe<Leads>;
  /** fetch data from the table: "leads_segmentation" */
  leads_segmentation: Array<Leads_Segmentation>;
  /** fetch aggregated fields from the table: "leads_segmentation" */
  leads_segmentation_aggregate: Leads_Segmentation_Aggregate;
  /** fetch data from the table: "leads_segmentation" using primary key columns */
  leads_segmentation_by_pk: Maybe<Leads_Segmentation>;
  /** An array relationship */
  likes: Array<Likes>;
  /** An aggregate relationship */
  likes_aggregate: Likes_Aggregate;
  /** fetch data from the table: "likes" using primary key columns */
  likes_by_pk: Maybe<Likes>;
  /** An array relationship */
  list_members: Array<List_Members>;
  /** An aggregate relationship */
  list_members_aggregate: List_Members_Aggregate;
  /** fetch data from the table: "list_members" using primary key columns */
  list_members_by_pk: Maybe<List_Members>;
  /** An array relationship */
  list_user_groups: Array<List_User_Groups>;
  /** An aggregate relationship */
  list_user_groups_aggregate: List_User_Groups_Aggregate;
  /** fetch data from the table: "list_user_groups" using primary key columns */
  list_user_groups_by_pk: Maybe<List_User_Groups>;
  /** fetch data from the table: "lists" */
  lists: Array<Lists>;
  /** fetch aggregated fields from the table: "lists" */
  lists_aggregate: Lists_Aggregate;
  /** fetch data from the table: "lists" using primary key columns */
  lists_by_pk: Maybe<Lists>;
  /** fetch data from the table: "news" */
  news: Array<News>;
  /** fetch aggregated fields from the table: "news" */
  news_aggregate: News_Aggregate;
  /** fetch data from the table: "news" using primary key columns */
  news_by_pk: Maybe<News>;
  /** fetch data from the table: "news_organizations" */
  news_organizations: Array<News_Organizations>;
  /** fetch aggregated fields from the table: "news_organizations" */
  news_organizations_aggregate: News_Organizations_Aggregate;
  /** fetch data from the table: "news_organizations" using primary key columns */
  news_organizations_by_pk: Maybe<News_Organizations>;
  /** fetch data from the table: "news_person" */
  news_person: Array<News_Person>;
  /** fetch aggregated fields from the table: "news_person" */
  news_person_aggregate: News_Person_Aggregate;
  /** fetch data from the table: "news_person" using primary key columns */
  news_person_by_pk: Maybe<News_Person>;
  /** fetch data from the table: "news_related_organizations" */
  news_related_organizations: Array<News_Related_Organizations>;
  /** fetch aggregated fields from the table: "news_related_organizations" */
  news_related_organizations_aggregate: News_Related_Organizations_Aggregate;
  /** fetch data from the table: "news_related_organizations" using primary key columns */
  news_related_organizations_by_pk: Maybe<News_Related_Organizations>;
  /** fetch data from the table: "news_related_person" */
  news_related_person: Array<News_Related_Person>;
  /** fetch aggregated fields from the table: "news_related_person" */
  news_related_person_aggregate: News_Related_Person_Aggregate;
  /** fetch data from the table: "news_related_person" using primary key columns */
  news_related_person_by_pk: Maybe<News_Related_Person>;
  /** An array relationship */
  notes: Array<Notes>;
  /** An aggregate relationship */
  notes_aggregate: Notes_Aggregate;
  /** fetch data from the table: "notes" using primary key columns */
  notes_by_pk: Maybe<Notes>;
  /** An array relationship */
  notification_actions: Array<Notification_Actions>;
  /** An aggregate relationship */
  notification_actions_aggregate: Notification_Actions_Aggregate;
  /** fetch data from the table: "notification_actions" using primary key columns */
  notification_actions_by_pk: Maybe<Notification_Actions>;
  /** fetch data from the table: "notifications" */
  notifications: Array<Notifications>;
  /** fetch aggregated fields from the table: "notifications" */
  notifications_aggregate: Notifications_Aggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notifications_by_pk: Maybe<Notifications>;
  /** fetch data from the table: "people" */
  people: Array<People>;
  /** fetch aggregated fields from the table: "people" */
  people_aggregate: People_Aggregate;
  /** fetch data from the table: "people" using primary key columns */
  people_by_pk: Maybe<People>;
  /** fetch data from the table: "people_computed_data" */
  people_computed_data: Array<People_Computed_Data>;
  /** fetch aggregated fields from the table: "people_computed_data" */
  people_computed_data_aggregate: People_Computed_Data_Aggregate;
  /** fetch data from the table: "people_computed_data" using primary key columns */
  people_computed_data_by_pk: Maybe<People_Computed_Data>;
  /** fetch data from the table: "reset_passwords" */
  reset_passwords: Array<Reset_Passwords>;
  /** fetch aggregated fields from the table: "reset_passwords" */
  reset_passwords_aggregate: Reset_Passwords_Aggregate;
  /** fetch data from the table: "reset_passwords" using primary key columns */
  reset_passwords_by_pk: Maybe<Reset_Passwords>;
  /** fetch data from the table: "resource_edit_access" */
  resource_edit_access: Array<Resource_Edit_Access>;
  /** fetch aggregated fields from the table: "resource_edit_access" */
  resource_edit_access_aggregate: Resource_Edit_Access_Aggregate;
  /** fetch data from the table: "resource_edit_access" using primary key columns */
  resource_edit_access_by_pk: Maybe<Resource_Edit_Access>;
  /** fetch data from the table: "resource_links" */
  resource_links: Array<Resource_Links>;
  /** fetch aggregated fields from the table: "resource_links" */
  resource_links_aggregate: Resource_Links_Aggregate;
  /** fetch data from the table: "resource_links" using primary key columns */
  resource_links_by_pk: Maybe<Resource_Links>;
  /** An array relationship */
  team_members: Array<Team_Members>;
  /** An aggregate relationship */
  team_members_aggregate: Team_Members_Aggregate;
  /** fetch data from the table: "team_members" using primary key columns */
  team_members_by_pk: Maybe<Team_Members>;
  /** An array relationship */
  user_group_invites: Array<User_Group_Invites>;
  /** An aggregate relationship */
  user_group_invites_aggregate: User_Group_Invites_Aggregate;
  /** fetch data from the table: "user_group_invites" using primary key columns */
  user_group_invites_by_pk: Maybe<User_Group_Invites>;
  /** An array relationship */
  user_group_members: Array<User_Group_Members>;
  /** An aggregate relationship */
  user_group_members_aggregate: User_Group_Members_Aggregate;
  /** fetch data from the table: "user_group_members" using primary key columns */
  user_group_members_by_pk: Maybe<User_Group_Members>;
  /** fetch data from the table: "user_groups" */
  user_groups: Array<User_Groups>;
  /** fetch aggregated fields from the table: "user_groups" */
  user_groups_aggregate: User_Groups_Aggregate;
  /** fetch data from the table: "user_groups" using primary key columns */
  user_groups_by_pk: Maybe<User_Groups>;
  /** fetch data from the table: "user_tokens" */
  user_tokens: Array<User_Tokens>;
  /** fetch aggregated fields from the table: "user_tokens" */
  user_tokens_aggregate: User_Tokens_Aggregate;
  /** fetch data from the table: "user_tokens" using primary key columns */
  user_tokens_by_pk: Maybe<User_Tokens>;
  /** fetch data from the table: "user_transactions" */
  user_transactions: Array<User_Transactions>;
  /** fetch aggregated fields from the table: "user_transactions" */
  user_transactions_aggregate: User_Transactions_Aggregate;
  /** fetch data from the table: "user_transactions" using primary key columns */
  user_transactions_by_pk: Maybe<User_Transactions>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk: Maybe<Users>;
  /** fetch data from the table: "users_public" */
  users_public: Array<Users_Public>;
  /** fetch aggregated fields from the table: "users_public" */
  users_public_aggregate: Users_Public_Aggregate;
  /** fetch data from the table: "vc_firms" */
  vc_firms: Array<Vc_Firms>;
  /** fetch aggregated fields from the table: "vc_firms" */
  vc_firms_aggregate: Vc_Firms_Aggregate;
  /** fetch data from the table: "vc_firms" using primary key columns */
  vc_firms_by_pk: Maybe<Vc_Firms>;
  /** fetch data from the table: "vc_firms_edit_access" */
  vc_firms_edit_access: Array<Vc_Firms_Edit_Access>;
  /** fetch aggregated fields from the table: "vc_firms_edit_access" */
  vc_firms_edit_access_aggregate: Vc_Firms_Edit_Access_Aggregate;
  /** fetch data from the table: "waitlist_emails" */
  waitlist_emails: Array<Waitlist_Emails>;
  /** fetch aggregated fields from the table: "waitlist_emails" */
  waitlist_emails_aggregate: Waitlist_Emails_Aggregate;
  /** fetch data from the table: "waitlist_emails" using primary key columns */
  waitlist_emails_by_pk: Maybe<Waitlist_Emails>;
};


export type Query_RootActionsArgs = {
  distinct_on: InputMaybe<Array<Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Actions_Order_By>>;
  where: InputMaybe<Actions_Bool_Exp>;
};


export type Query_RootActions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Actions_Order_By>>;
  where: InputMaybe<Actions_Bool_Exp>;
};


export type Query_RootActions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootAllowed_EmailsArgs = {
  distinct_on: InputMaybe<Array<Allowed_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Allowed_Emails_Order_By>>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};


export type Query_RootAllowed_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Allowed_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Allowed_Emails_Order_By>>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};


export type Query_RootAllowed_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootApplication_MetaArgs = {
  distinct_on: InputMaybe<Array<Application_Meta_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Application_Meta_Order_By>>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};


export type Query_RootApplication_Meta_AggregateArgs = {
  distinct_on: InputMaybe<Array<Application_Meta_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Application_Meta_Order_By>>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};


export type Query_RootApplication_Meta_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootBilling_OrgArgs = {
  distinct_on: InputMaybe<Array<Billing_Org_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Billing_Org_Order_By>>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};


export type Query_RootBilling_Org_AggregateArgs = {
  distinct_on: InputMaybe<Array<Billing_Org_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Billing_Org_Order_By>>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};


export type Query_RootBilling_Org_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootBlockchainsArgs = {
  distinct_on: InputMaybe<Array<Blockchains_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Blockchains_Order_By>>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};


export type Query_RootBlockchains_AggregateArgs = {
  distinct_on: InputMaybe<Array<Blockchains_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Blockchains_Order_By>>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};


export type Query_RootBlockchains_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootCoinsArgs = {
  distinct_on: InputMaybe<Array<Coins_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Coins_Order_By>>;
  where: InputMaybe<Coins_Bool_Exp>;
};


export type Query_RootCoins_AggregateArgs = {
  distinct_on: InputMaybe<Array<Coins_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Coins_Order_By>>;
  where: InputMaybe<Coins_Bool_Exp>;
};


export type Query_RootCoins_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootCommentsArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


export type Query_RootComments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


export type Query_RootComments_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootCompaniesArgs = {
  distinct_on: InputMaybe<Array<Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Order_By>>;
  where: InputMaybe<Companies_Bool_Exp>;
};


export type Query_RootCompanies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Order_By>>;
  where: InputMaybe<Companies_Bool_Exp>;
};


export type Query_RootCompanies_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootCompanies_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


export type Query_RootCompanies_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


export type Query_RootData_ActionsArgs = {
  distinct_on: InputMaybe<Array<Data_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Actions_Order_By>>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};


export type Query_RootData_Actions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Actions_Order_By>>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};


export type Query_RootData_Actions_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootData_DiscardArgs = {
  distinct_on: InputMaybe<Array<Data_Discard_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Discard_Order_By>>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};


export type Query_RootData_Discard_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Discard_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Discard_Order_By>>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};


export type Query_RootData_Discard_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootData_FieldsArgs = {
  distinct_on: InputMaybe<Array<Data_Fields_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Fields_Order_By>>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};


export type Query_RootData_Fields_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Fields_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Fields_Order_By>>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};


export type Query_RootData_Fields_By_PkArgs = {
  path: Scalars['String'];
};


export type Query_RootData_PartnersArgs = {
  distinct_on: InputMaybe<Array<Data_Partners_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Partners_Order_By>>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};


export type Query_RootData_Partners_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Partners_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Partners_Order_By>>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};


export type Query_RootData_Partners_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootData_RawArgs = {
  distinct_on: InputMaybe<Array<Data_Raw_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Raw_Order_By>>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};


export type Query_RootData_Raw_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Raw_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Raw_Order_By>>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};


export type Query_RootData_Raw_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootData_RunsArgs = {
  distinct_on: InputMaybe<Array<Data_Runs_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Runs_Order_By>>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};


export type Query_RootData_Runs_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Runs_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Runs_Order_By>>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};


export type Query_RootData_Runs_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootDisabled_EmailsArgs = {
  distinct_on: InputMaybe<Array<Disabled_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Disabled_Emails_Order_By>>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};


export type Query_RootDisabled_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Disabled_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Disabled_Emails_Order_By>>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};


export type Query_RootDisabled_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootEvent_OrganizationArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


export type Query_RootEvent_Organization_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


export type Query_RootEvent_Organization_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootEvent_PersonArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


export type Query_RootEvent_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


export type Query_RootEvent_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootEventsArgs = {
  distinct_on: InputMaybe<Array<Events_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Events_Order_By>>;
  where: InputMaybe<Events_Bool_Exp>;
};


export type Query_RootEvents_AggregateArgs = {
  distinct_on: InputMaybe<Array<Events_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Events_Order_By>>;
  where: InputMaybe<Events_Bool_Exp>;
};


export type Query_RootEvents_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootFollowsArgs = {
  distinct_on: InputMaybe<Array<Follows_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Order_By>>;
  where: InputMaybe<Follows_Bool_Exp>;
};


export type Query_RootFollows_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Order_By>>;
  where: InputMaybe<Follows_Bool_Exp>;
};


export type Query_RootFollows_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootFollows_CompaniesArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


export type Query_RootFollows_Companies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


export type Query_RootFollows_PeopleArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


export type Query_RootFollows_People_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


export type Query_RootFollows_Vc_FirmsArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


export type Query_RootFollows_Vc_Firms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


export type Query_RootInvestment_RoundsArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


export type Query_RootInvestment_Rounds_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


export type Query_RootInvestment_Rounds_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootInvestmentsArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


export type Query_RootInvestments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


export type Query_RootInvestments_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootInvestorsArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


export type Query_RootInvestors_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


export type Query_RootInvestors_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootInvited_PeopleArgs = {
  distinct_on: InputMaybe<Array<Invited_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Invited_People_Order_By>>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};


export type Query_RootInvited_People_AggregateArgs = {
  distinct_on: InputMaybe<Array<Invited_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Invited_People_Order_By>>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};


export type Query_RootInvited_People_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootLeadsArgs = {
  distinct_on: InputMaybe<Array<Leads_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Order_By>>;
  where: InputMaybe<Leads_Bool_Exp>;
};


export type Query_RootLeads_AggregateArgs = {
  distinct_on: InputMaybe<Array<Leads_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Order_By>>;
  where: InputMaybe<Leads_Bool_Exp>;
};


export type Query_RootLeads_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootLeads_SegmentationArgs = {
  distinct_on: InputMaybe<Array<Leads_Segmentation_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Segmentation_Order_By>>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};


export type Query_RootLeads_Segmentation_AggregateArgs = {
  distinct_on: InputMaybe<Array<Leads_Segmentation_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Segmentation_Order_By>>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};


export type Query_RootLeads_Segmentation_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootLikesArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


export type Query_RootLikes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


export type Query_RootLikes_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootList_MembersArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


export type Query_RootList_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


export type Query_RootList_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootList_User_GroupsArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


export type Query_RootList_User_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


export type Query_RootList_User_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootListsArgs = {
  distinct_on: InputMaybe<Array<Lists_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Lists_Order_By>>;
  where: InputMaybe<Lists_Bool_Exp>;
};


export type Query_RootLists_AggregateArgs = {
  distinct_on: InputMaybe<Array<Lists_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Lists_Order_By>>;
  where: InputMaybe<Lists_Bool_Exp>;
};


export type Query_RootLists_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNewsArgs = {
  distinct_on: InputMaybe<Array<News_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Order_By>>;
  where: InputMaybe<News_Bool_Exp>;
};


export type Query_RootNews_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Order_By>>;
  where: InputMaybe<News_Bool_Exp>;
};


export type Query_RootNews_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNews_OrganizationsArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


export type Query_RootNews_Organizations_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


export type Query_RootNews_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNews_PersonArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


export type Query_RootNews_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


export type Query_RootNews_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNews_Related_OrganizationsArgs = {
  distinct_on: InputMaybe<Array<News_Related_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Organizations_Order_By>>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};


export type Query_RootNews_Related_Organizations_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Related_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Organizations_Order_By>>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};


export type Query_RootNews_Related_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNews_Related_PersonArgs = {
  distinct_on: InputMaybe<Array<News_Related_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Person_Order_By>>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};


export type Query_RootNews_Related_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Related_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Person_Order_By>>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};


export type Query_RootNews_Related_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNotesArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


export type Query_RootNotes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


export type Query_RootNotes_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNotification_ActionsArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


export type Query_RootNotification_Actions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


export type Query_RootNotification_Actions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootNotificationsArgs = {
  distinct_on: InputMaybe<Array<Notifications_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notifications_Order_By>>;
  where: InputMaybe<Notifications_Bool_Exp>;
};


export type Query_RootNotifications_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notifications_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notifications_Order_By>>;
  where: InputMaybe<Notifications_Bool_Exp>;
};


export type Query_RootNotifications_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootPeopleArgs = {
  distinct_on: InputMaybe<Array<People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Order_By>>;
  where: InputMaybe<People_Bool_Exp>;
};


export type Query_RootPeople_AggregateArgs = {
  distinct_on: InputMaybe<Array<People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Order_By>>;
  where: InputMaybe<People_Bool_Exp>;
};


export type Query_RootPeople_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootPeople_Computed_DataArgs = {
  distinct_on: InputMaybe<Array<People_Computed_Data_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Computed_Data_Order_By>>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};


export type Query_RootPeople_Computed_Data_AggregateArgs = {
  distinct_on: InputMaybe<Array<People_Computed_Data_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Computed_Data_Order_By>>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};


export type Query_RootPeople_Computed_Data_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootReset_PasswordsArgs = {
  distinct_on: InputMaybe<Array<Reset_Passwords_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Reset_Passwords_Order_By>>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};


export type Query_RootReset_Passwords_AggregateArgs = {
  distinct_on: InputMaybe<Array<Reset_Passwords_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Reset_Passwords_Order_By>>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};


export type Query_RootReset_Passwords_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootResource_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Resource_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Edit_Access_Order_By>>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};


export type Query_RootResource_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Edit_Access_Order_By>>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};


export type Query_RootResource_Edit_Access_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootResource_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


export type Query_RootResource_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


export type Query_RootResource_Links_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootTeam_MembersArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


export type Query_RootTeam_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


export type Query_RootTeam_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_Group_InvitesArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


export type Query_RootUser_Group_Invites_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


export type Query_RootUser_Group_Invites_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_Group_MembersArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


export type Query_RootUser_Group_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


export type Query_RootUser_Group_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_GroupsArgs = {
  distinct_on: InputMaybe<Array<User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Groups_Order_By>>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};


export type Query_RootUser_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Groups_Order_By>>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};


export type Query_RootUser_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_TokensArgs = {
  distinct_on: InputMaybe<Array<User_Tokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Tokens_Order_By>>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};


export type Query_RootUser_Tokens_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Tokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Tokens_Order_By>>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};


export type Query_RootUser_Tokens_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUser_TransactionsArgs = {
  distinct_on: InputMaybe<Array<User_Transactions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Transactions_Order_By>>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};


export type Query_RootUser_Transactions_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Transactions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Transactions_Order_By>>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};


export type Query_RootUser_Transactions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUsersArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootUsers_PublicArgs = {
  distinct_on: InputMaybe<Array<Users_Public_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Public_Order_By>>;
  where: InputMaybe<Users_Public_Bool_Exp>;
};


export type Query_RootUsers_Public_AggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Public_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Public_Order_By>>;
  where: InputMaybe<Users_Public_Bool_Exp>;
};


export type Query_RootVc_FirmsArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Order_By>>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};


export type Query_RootVc_Firms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Order_By>>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};


export type Query_RootVc_Firms_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootVc_Firms_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


export type Query_RootVc_Firms_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


export type Query_RootWaitlist_EmailsArgs = {
  distinct_on: InputMaybe<Array<Waitlist_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Waitlist_Emails_Order_By>>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};


export type Query_RootWaitlist_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Waitlist_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Waitlist_Emails_Order_By>>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};


export type Query_RootWaitlist_Emails_By_PkArgs = {
  id: Scalars['Int'];
};

/** columns and relationships of "reset_passwords" */
export type Reset_Passwords = {
  __typename?: 'reset_passwords';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  created_by_user: Maybe<Users>;
  created_by_user_id: Scalars['Int'];
  generated_password: Scalars['String'];
  id: Scalars['Int'];
  /** An object relationship */
  user: Maybe<Users>;
  user_id: Scalars['Int'];
};

/** aggregated selection of "reset_passwords" */
export type Reset_Passwords_Aggregate = {
  __typename?: 'reset_passwords_aggregate';
  aggregate: Maybe<Reset_Passwords_Aggregate_Fields>;
  nodes: Array<Reset_Passwords>;
};

/** aggregate fields of "reset_passwords" */
export type Reset_Passwords_Aggregate_Fields = {
  __typename?: 'reset_passwords_aggregate_fields';
  avg: Maybe<Reset_Passwords_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Reset_Passwords_Max_Fields>;
  min: Maybe<Reset_Passwords_Min_Fields>;
  stddev: Maybe<Reset_Passwords_Stddev_Fields>;
  stddev_pop: Maybe<Reset_Passwords_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Reset_Passwords_Stddev_Samp_Fields>;
  sum: Maybe<Reset_Passwords_Sum_Fields>;
  var_pop: Maybe<Reset_Passwords_Var_Pop_Fields>;
  var_samp: Maybe<Reset_Passwords_Var_Samp_Fields>;
  variance: Maybe<Reset_Passwords_Variance_Fields>;
};


/** aggregate fields of "reset_passwords" */
export type Reset_Passwords_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Reset_Passwords_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Reset_Passwords_Avg_Fields = {
  __typename?: 'reset_passwords_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "reset_passwords". All fields are combined with a logical 'AND'. */
export type Reset_Passwords_Bool_Exp = {
  _and: InputMaybe<Array<Reset_Passwords_Bool_Exp>>;
  _not: InputMaybe<Reset_Passwords_Bool_Exp>;
  _or: InputMaybe<Array<Reset_Passwords_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by_user: InputMaybe<Users_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  generated_password: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  user: InputMaybe<Users_Bool_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "reset_passwords" */
export enum Reset_Passwords_Constraint {
  /** unique or primary key constraint on columns "id" */
  ResetPasswordsPkey = 'reset_passwords_pkey'
}

/** input type for incrementing numeric columns in table "reset_passwords" */
export type Reset_Passwords_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "reset_passwords" */
export type Reset_Passwords_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  generated_password: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Reset_Passwords_Max_Fields = {
  __typename?: 'reset_passwords_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  generated_password: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Reset_Passwords_Min_Fields = {
  __typename?: 'reset_passwords_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  generated_password: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "reset_passwords" */
export type Reset_Passwords_Mutation_Response = {
  __typename?: 'reset_passwords_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Reset_Passwords>;
};

/** on_conflict condition type for table "reset_passwords" */
export type Reset_Passwords_On_Conflict = {
  constraint: Reset_Passwords_Constraint;
  update_columns: Array<Reset_Passwords_Update_Column>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};

/** Ordering options when selecting data from "reset_passwords". */
export type Reset_Passwords_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user: InputMaybe<Users_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  generated_password: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user: InputMaybe<Users_Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: reset_passwords */
export type Reset_Passwords_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "reset_passwords" */
export enum Reset_Passwords_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  GeneratedPassword = 'generated_password',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "reset_passwords" */
export type Reset_Passwords_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  generated_password: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Reset_Passwords_Stddev_Fields = {
  __typename?: 'reset_passwords_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Reset_Passwords_Stddev_Pop_Fields = {
  __typename?: 'reset_passwords_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Reset_Passwords_Stddev_Samp_Fields = {
  __typename?: 'reset_passwords_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "reset_passwords" */
export type Reset_Passwords_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Reset_Passwords_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Reset_Passwords_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  generated_password: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Reset_Passwords_Sum_Fields = {
  __typename?: 'reset_passwords_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "reset_passwords" */
export enum Reset_Passwords_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  GeneratedPassword = 'generated_password',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

export type Reset_Passwords_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Reset_Passwords_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Reset_Passwords_Set_Input>;
  /** filter the rows which have to be updated */
  where: Reset_Passwords_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Reset_Passwords_Var_Pop_Fields = {
  __typename?: 'reset_passwords_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Reset_Passwords_Var_Samp_Fields = {
  __typename?: 'reset_passwords_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Reset_Passwords_Variance_Fields = {
  __typename?: 'reset_passwords_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Add access to user if he has verified the access to organization */
export type Resource_Edit_Access = {
  __typename?: 'resource_edit_access';
  /** An object relationship */
  company: Maybe<Companies>;
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  resource_id: Scalars['Int'];
  resource_type: Scalars['String'];
  user_id: Scalars['Int'];
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
};

/** aggregated selection of "resource_edit_access" */
export type Resource_Edit_Access_Aggregate = {
  __typename?: 'resource_edit_access_aggregate';
  aggregate: Maybe<Resource_Edit_Access_Aggregate_Fields>;
  nodes: Array<Resource_Edit_Access>;
};

/** aggregate fields of "resource_edit_access" */
export type Resource_Edit_Access_Aggregate_Fields = {
  __typename?: 'resource_edit_access_aggregate_fields';
  avg: Maybe<Resource_Edit_Access_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Resource_Edit_Access_Max_Fields>;
  min: Maybe<Resource_Edit_Access_Min_Fields>;
  stddev: Maybe<Resource_Edit_Access_Stddev_Fields>;
  stddev_pop: Maybe<Resource_Edit_Access_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Resource_Edit_Access_Stddev_Samp_Fields>;
  sum: Maybe<Resource_Edit_Access_Sum_Fields>;
  var_pop: Maybe<Resource_Edit_Access_Var_Pop_Fields>;
  var_samp: Maybe<Resource_Edit_Access_Var_Samp_Fields>;
  variance: Maybe<Resource_Edit_Access_Variance_Fields>;
};


/** aggregate fields of "resource_edit_access" */
export type Resource_Edit_Access_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Resource_Edit_Access_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Resource_Edit_Access_Avg_Fields = {
  __typename?: 'resource_edit_access_avg_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "resource_edit_access". All fields are combined with a logical 'AND'. */
export type Resource_Edit_Access_Bool_Exp = {
  _and: InputMaybe<Array<Resource_Edit_Access_Bool_Exp>>;
  _not: InputMaybe<Resource_Edit_Access_Bool_Exp>;
  _or: InputMaybe<Array<Resource_Edit_Access_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
};

/** unique or primary key constraints on table "resource_edit_access" */
export enum Resource_Edit_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  ResourceEditAccessPkey = 'resource_edit_access_pkey',
  /** unique or primary key constraint on columns "resource_id", "user_id", "resource_type" */
  ResourceEditAccessResourceIdUserIdResourceTypeKey = 'resource_edit_access_resource_id_user_id_resource_type_key'
}

/** input type for incrementing numeric columns in table "resource_edit_access" */
export type Resource_Edit_Access_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "resource_edit_access" */
export type Resource_Edit_Access_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Resource_Edit_Access_Max_Fields = {
  __typename?: 'resource_edit_access_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Resource_Edit_Access_Min_Fields = {
  __typename?: 'resource_edit_access_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "resource_edit_access" */
export type Resource_Edit_Access_Mutation_Response = {
  __typename?: 'resource_edit_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Resource_Edit_Access>;
};

/** on_conflict condition type for table "resource_edit_access" */
export type Resource_Edit_Access_On_Conflict = {
  constraint: Resource_Edit_Access_Constraint;
  update_columns: Array<Resource_Edit_Access_Update_Column>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "resource_edit_access". */
export type Resource_Edit_Access_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
};

/** primary key columns input for table: resource_edit_access */
export type Resource_Edit_Access_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "resource_edit_access" */
export enum Resource_Edit_Access_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "resource_edit_access" */
export type Resource_Edit_Access_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Resource_Edit_Access_Stddev_Fields = {
  __typename?: 'resource_edit_access_stddev_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Resource_Edit_Access_Stddev_Pop_Fields = {
  __typename?: 'resource_edit_access_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Resource_Edit_Access_Stddev_Samp_Fields = {
  __typename?: 'resource_edit_access_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "resource_edit_access" */
export type Resource_Edit_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Resource_Edit_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Resource_Edit_Access_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Resource_Edit_Access_Sum_Fields = {
  __typename?: 'resource_edit_access_sum_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "resource_edit_access" */
export enum Resource_Edit_Access_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UserId = 'user_id'
}

export type Resource_Edit_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Resource_Edit_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Resource_Edit_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Resource_Edit_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Resource_Edit_Access_Var_Pop_Fields = {
  __typename?: 'resource_edit_access_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Resource_Edit_Access_Var_Samp_Fields = {
  __typename?: 'resource_edit_access_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Resource_Edit_Access_Variance_Fields = {
  __typename?: 'resource_edit_access_variance_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "resource_links" */
export type Resource_Links = {
  __typename?: 'resource_links';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  from_company: Maybe<Companies>;
  from_company_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  from_vc_firm: Maybe<Vc_Firms>;
  from_vc_firm_id: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  link_type: Scalars['String'];
  /** An object relationship */
  to_company: Maybe<Companies>;
  to_company_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  to_vc_firm: Maybe<Vc_Firms>;
  to_vc_firm_id: Maybe<Scalars['Int']>;
};

/** aggregated selection of "resource_links" */
export type Resource_Links_Aggregate = {
  __typename?: 'resource_links_aggregate';
  aggregate: Maybe<Resource_Links_Aggregate_Fields>;
  nodes: Array<Resource_Links>;
};

export type Resource_Links_Aggregate_Bool_Exp = {
  count: InputMaybe<Resource_Links_Aggregate_Bool_Exp_Count>;
};

export type Resource_Links_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Resource_Links_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Resource_Links_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "resource_links" */
export type Resource_Links_Aggregate_Fields = {
  __typename?: 'resource_links_aggregate_fields';
  avg: Maybe<Resource_Links_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Resource_Links_Max_Fields>;
  min: Maybe<Resource_Links_Min_Fields>;
  stddev: Maybe<Resource_Links_Stddev_Fields>;
  stddev_pop: Maybe<Resource_Links_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Resource_Links_Stddev_Samp_Fields>;
  sum: Maybe<Resource_Links_Sum_Fields>;
  var_pop: Maybe<Resource_Links_Var_Pop_Fields>;
  var_samp: Maybe<Resource_Links_Var_Samp_Fields>;
  variance: Maybe<Resource_Links_Variance_Fields>;
};


/** aggregate fields of "resource_links" */
export type Resource_Links_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Resource_Links_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "resource_links" */
export type Resource_Links_Aggregate_Order_By = {
  avg: InputMaybe<Resource_Links_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Resource_Links_Max_Order_By>;
  min: InputMaybe<Resource_Links_Min_Order_By>;
  stddev: InputMaybe<Resource_Links_Stddev_Order_By>;
  stddev_pop: InputMaybe<Resource_Links_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Resource_Links_Stddev_Samp_Order_By>;
  sum: InputMaybe<Resource_Links_Sum_Order_By>;
  var_pop: InputMaybe<Resource_Links_Var_Pop_Order_By>;
  var_samp: InputMaybe<Resource_Links_Var_Samp_Order_By>;
  variance: InputMaybe<Resource_Links_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "resource_links" */
export type Resource_Links_Arr_Rel_Insert_Input = {
  data: Array<Resource_Links_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Resource_Links_On_Conflict>;
};

/** aggregate avg on columns */
export type Resource_Links_Avg_Fields = {
  __typename?: 'resource_links_avg_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "resource_links" */
export type Resource_Links_Avg_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "resource_links". All fields are combined with a logical 'AND'. */
export type Resource_Links_Bool_Exp = {
  _and: InputMaybe<Array<Resource_Links_Bool_Exp>>;
  _not: InputMaybe<Resource_Links_Bool_Exp>;
  _or: InputMaybe<Array<Resource_Links_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  from_company: InputMaybe<Companies_Bool_Exp>;
  from_company_id: InputMaybe<Int_Comparison_Exp>;
  from_vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  from_vc_firm_id: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  link_type: InputMaybe<String_Comparison_Exp>;
  to_company: InputMaybe<Companies_Bool_Exp>;
  to_company_id: InputMaybe<Int_Comparison_Exp>;
  to_vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
  to_vc_firm_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "resource_links" */
export enum Resource_Links_Constraint {
  /** unique or primary key constraint on columns "id" */
  ResourceLinksPkey = 'resource_links_pkey'
}

/** input type for incrementing numeric columns in table "resource_links" */
export type Resource_Links_Inc_Input = {
  from_company_id: InputMaybe<Scalars['Int']>;
  from_vc_firm_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  to_company_id: InputMaybe<Scalars['Int']>;
  to_vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "resource_links" */
export type Resource_Links_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  from_company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  from_company_id: InputMaybe<Scalars['Int']>;
  from_vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  from_vc_firm_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  link_type: InputMaybe<Scalars['String']>;
  to_company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  to_company_id: InputMaybe<Scalars['Int']>;
  to_vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
  to_vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Resource_Links_Max_Fields = {
  __typename?: 'resource_links_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  from_company_id: Maybe<Scalars['Int']>;
  from_vc_firm_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  link_type: Maybe<Scalars['String']>;
  to_company_id: Maybe<Scalars['Int']>;
  to_vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "resource_links" */
export type Resource_Links_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  link_type: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Resource_Links_Min_Fields = {
  __typename?: 'resource_links_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  from_company_id: Maybe<Scalars['Int']>;
  from_vc_firm_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  link_type: Maybe<Scalars['String']>;
  to_company_id: Maybe<Scalars['Int']>;
  to_vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "resource_links" */
export type Resource_Links_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  link_type: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "resource_links" */
export type Resource_Links_Mutation_Response = {
  __typename?: 'resource_links_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Resource_Links>;
};

/** on_conflict condition type for table "resource_links" */
export type Resource_Links_On_Conflict = {
  constraint: Resource_Links_Constraint;
  update_columns: Array<Resource_Links_Update_Column>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};

/** Ordering options when selecting data from "resource_links". */
export type Resource_Links_Order_By = {
  created_at: InputMaybe<Order_By>;
  from_company: InputMaybe<Companies_Order_By>;
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm: InputMaybe<Vc_Firms_Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  link_type: InputMaybe<Order_By>;
  to_company: InputMaybe<Companies_Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm: InputMaybe<Vc_Firms_Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: resource_links */
export type Resource_Links_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "resource_links" */
export enum Resource_Links_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FromCompanyId = 'from_company_id',
  /** column name */
  FromVcFirmId = 'from_vc_firm_id',
  /** column name */
  Id = 'id',
  /** column name */
  LinkType = 'link_type',
  /** column name */
  ToCompanyId = 'to_company_id',
  /** column name */
  ToVcFirmId = 'to_vc_firm_id'
}

/** input type for updating data in table "resource_links" */
export type Resource_Links_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  from_company_id: InputMaybe<Scalars['Int']>;
  from_vc_firm_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  link_type: InputMaybe<Scalars['String']>;
  to_company_id: InputMaybe<Scalars['Int']>;
  to_vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Resource_Links_Stddev_Fields = {
  __typename?: 'resource_links_stddev_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "resource_links" */
export type Resource_Links_Stddev_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Resource_Links_Stddev_Pop_Fields = {
  __typename?: 'resource_links_stddev_pop_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "resource_links" */
export type Resource_Links_Stddev_Pop_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Resource_Links_Stddev_Samp_Fields = {
  __typename?: 'resource_links_stddev_samp_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "resource_links" */
export type Resource_Links_Stddev_Samp_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "resource_links" */
export type Resource_Links_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Resource_Links_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Resource_Links_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  from_company_id: InputMaybe<Scalars['Int']>;
  from_vc_firm_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  link_type: InputMaybe<Scalars['String']>;
  to_company_id: InputMaybe<Scalars['Int']>;
  to_vc_firm_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Resource_Links_Sum_Fields = {
  __typename?: 'resource_links_sum_fields';
  from_company_id: Maybe<Scalars['Int']>;
  from_vc_firm_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  to_company_id: Maybe<Scalars['Int']>;
  to_vc_firm_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "resource_links" */
export type Resource_Links_Sum_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** update columns of table "resource_links" */
export enum Resource_Links_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FromCompanyId = 'from_company_id',
  /** column name */
  FromVcFirmId = 'from_vc_firm_id',
  /** column name */
  Id = 'id',
  /** column name */
  LinkType = 'link_type',
  /** column name */
  ToCompanyId = 'to_company_id',
  /** column name */
  ToVcFirmId = 'to_vc_firm_id'
}

export type Resource_Links_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Resource_Links_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Resource_Links_Set_Input>;
  /** filter the rows which have to be updated */
  where: Resource_Links_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Resource_Links_Var_Pop_Fields = {
  __typename?: 'resource_links_var_pop_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "resource_links" */
export type Resource_Links_Var_Pop_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Resource_Links_Var_Samp_Fields = {
  __typename?: 'resource_links_var_samp_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "resource_links" */
export type Resource_Links_Var_Samp_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Resource_Links_Variance_Fields = {
  __typename?: 'resource_links_variance_fields';
  from_company_id: Maybe<Scalars['Float']>;
  from_vc_firm_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  to_company_id: Maybe<Scalars['Float']>;
  to_vc_firm_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "resource_links" */
export type Resource_Links_Variance_Order_By = {
  from_company_id: InputMaybe<Order_By>;
  from_vc_firm_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  to_company_id: InputMaybe<Order_By>;
  to_vc_firm_id: InputMaybe<Order_By>;
};

export type St_D_Within_Geography_Input = {
  distance: Scalars['Float'];
  from: Scalars['geography'];
  use_spheroid: InputMaybe<Scalars['Boolean']>;
};

export type St_D_Within_Input = {
  distance: Scalars['Float'];
  from: Scalars['geometry'];
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "actions" */
  actions: Array<Actions>;
  /** fetch aggregated fields from the table: "actions" */
  actions_aggregate: Actions_Aggregate;
  /** fetch data from the table: "actions" using primary key columns */
  actions_by_pk: Maybe<Actions>;
  /** fetch data from the table in a streaming manner: "actions" */
  actions_stream: Array<Actions>;
  /** fetch data from the table: "allowed_emails" */
  allowed_emails: Array<Allowed_Emails>;
  /** fetch aggregated fields from the table: "allowed_emails" */
  allowed_emails_aggregate: Allowed_Emails_Aggregate;
  /** fetch data from the table: "allowed_emails" using primary key columns */
  allowed_emails_by_pk: Maybe<Allowed_Emails>;
  /** fetch data from the table in a streaming manner: "allowed_emails" */
  allowed_emails_stream: Array<Allowed_Emails>;
  /** fetch data from the table: "application_meta" */
  application_meta: Array<Application_Meta>;
  /** fetch aggregated fields from the table: "application_meta" */
  application_meta_aggregate: Application_Meta_Aggregate;
  /** fetch data from the table: "application_meta" using primary key columns */
  application_meta_by_pk: Maybe<Application_Meta>;
  /** fetch data from the table in a streaming manner: "application_meta" */
  application_meta_stream: Array<Application_Meta>;
  /** fetch data from the table: "billing_org" */
  billing_org: Array<Billing_Org>;
  /** fetch aggregated fields from the table: "billing_org" */
  billing_org_aggregate: Billing_Org_Aggregate;
  /** fetch data from the table: "billing_org" using primary key columns */
  billing_org_by_pk: Maybe<Billing_Org>;
  /** fetch data from the table in a streaming manner: "billing_org" */
  billing_org_stream: Array<Billing_Org>;
  /** fetch data from the table: "blockchains" */
  blockchains: Array<Blockchains>;
  /** fetch aggregated fields from the table: "blockchains" */
  blockchains_aggregate: Blockchains_Aggregate;
  /** fetch data from the table: "blockchains" using primary key columns */
  blockchains_by_pk: Maybe<Blockchains>;
  /** fetch data from the table in a streaming manner: "blockchains" */
  blockchains_stream: Array<Blockchains>;
  /** fetch data from the table: "coins" */
  coins: Array<Coins>;
  /** fetch aggregated fields from the table: "coins" */
  coins_aggregate: Coins_Aggregate;
  /** fetch data from the table: "coins" using primary key columns */
  coins_by_pk: Maybe<Coins>;
  /** fetch data from the table in a streaming manner: "coins" */
  coins_stream: Array<Coins>;
  /** An array relationship */
  comments: Array<Comments>;
  /** An aggregate relationship */
  comments_aggregate: Comments_Aggregate;
  /** fetch data from the table: "comments" using primary key columns */
  comments_by_pk: Maybe<Comments>;
  /** fetch data from the table in a streaming manner: "comments" */
  comments_stream: Array<Comments>;
  /** fetch data from the table: "companies" */
  companies: Array<Companies>;
  /** fetch aggregated fields from the table: "companies" */
  companies_aggregate: Companies_Aggregate;
  /** fetch data from the table: "companies" using primary key columns */
  companies_by_pk: Maybe<Companies>;
  /** fetch data from the table: "companies_edit_access" */
  companies_edit_access: Array<Companies_Edit_Access>;
  /** fetch aggregated fields from the table: "companies_edit_access" */
  companies_edit_access_aggregate: Companies_Edit_Access_Aggregate;
  /** fetch data from the table in a streaming manner: "companies_edit_access" */
  companies_edit_access_stream: Array<Companies_Edit_Access>;
  /** fetch data from the table in a streaming manner: "companies" */
  companies_stream: Array<Companies>;
  /** fetch data from the table: "data_actions" */
  data_actions: Array<Data_Actions>;
  /** fetch aggregated fields from the table: "data_actions" */
  data_actions_aggregate: Data_Actions_Aggregate;
  /** fetch data from the table: "data_actions" using primary key columns */
  data_actions_by_pk: Maybe<Data_Actions>;
  /** fetch data from the table in a streaming manner: "data_actions" */
  data_actions_stream: Array<Data_Actions>;
  /** fetch data from the table: "data_discard" */
  data_discard: Array<Data_Discard>;
  /** fetch aggregated fields from the table: "data_discard" */
  data_discard_aggregate: Data_Discard_Aggregate;
  /** fetch data from the table: "data_discard" using primary key columns */
  data_discard_by_pk: Maybe<Data_Discard>;
  /** fetch data from the table in a streaming manner: "data_discard" */
  data_discard_stream: Array<Data_Discard>;
  /** fetch data from the table: "data_fields" */
  data_fields: Array<Data_Fields>;
  /** fetch aggregated fields from the table: "data_fields" */
  data_fields_aggregate: Data_Fields_Aggregate;
  /** fetch data from the table: "data_fields" using primary key columns */
  data_fields_by_pk: Maybe<Data_Fields>;
  /** fetch data from the table in a streaming manner: "data_fields" */
  data_fields_stream: Array<Data_Fields>;
  /** fetch data from the table: "data_partners" */
  data_partners: Array<Data_Partners>;
  /** fetch aggregated fields from the table: "data_partners" */
  data_partners_aggregate: Data_Partners_Aggregate;
  /** fetch data from the table: "data_partners" using primary key columns */
  data_partners_by_pk: Maybe<Data_Partners>;
  /** fetch data from the table in a streaming manner: "data_partners" */
  data_partners_stream: Array<Data_Partners>;
  /** fetch data from the table: "data_raw" */
  data_raw: Array<Data_Raw>;
  /** fetch aggregated fields from the table: "data_raw" */
  data_raw_aggregate: Data_Raw_Aggregate;
  /** fetch data from the table: "data_raw" using primary key columns */
  data_raw_by_pk: Maybe<Data_Raw>;
  /** fetch data from the table in a streaming manner: "data_raw" */
  data_raw_stream: Array<Data_Raw>;
  /** fetch data from the table: "data_runs" */
  data_runs: Array<Data_Runs>;
  /** fetch aggregated fields from the table: "data_runs" */
  data_runs_aggregate: Data_Runs_Aggregate;
  /** fetch data from the table: "data_runs" using primary key columns */
  data_runs_by_pk: Maybe<Data_Runs>;
  /** fetch data from the table in a streaming manner: "data_runs" */
  data_runs_stream: Array<Data_Runs>;
  /** fetch data from the table: "disabled_emails" */
  disabled_emails: Array<Disabled_Emails>;
  /** fetch aggregated fields from the table: "disabled_emails" */
  disabled_emails_aggregate: Disabled_Emails_Aggregate;
  /** fetch data from the table: "disabled_emails" using primary key columns */
  disabled_emails_by_pk: Maybe<Disabled_Emails>;
  /** fetch data from the table in a streaming manner: "disabled_emails" */
  disabled_emails_stream: Array<Disabled_Emails>;
  /** An array relationship */
  event_organization: Array<Event_Organization>;
  /** An aggregate relationship */
  event_organization_aggregate: Event_Organization_Aggregate;
  /** fetch data from the table: "event_organization" using primary key columns */
  event_organization_by_pk: Maybe<Event_Organization>;
  /** fetch data from the table in a streaming manner: "event_organization" */
  event_organization_stream: Array<Event_Organization>;
  /** An array relationship */
  event_person: Array<Event_Person>;
  /** An aggregate relationship */
  event_person_aggregate: Event_Person_Aggregate;
  /** fetch data from the table: "event_person" using primary key columns */
  event_person_by_pk: Maybe<Event_Person>;
  /** fetch data from the table in a streaming manner: "event_person" */
  event_person_stream: Array<Event_Person>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: Events_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk: Maybe<Events>;
  /** fetch data from the table in a streaming manner: "events" */
  events_stream: Array<Events>;
  /** fetch data from the table: "follows" */
  follows: Array<Follows>;
  /** fetch aggregated fields from the table: "follows" */
  follows_aggregate: Follows_Aggregate;
  /** fetch data from the table: "follows" using primary key columns */
  follows_by_pk: Maybe<Follows>;
  /** An array relationship */
  follows_companies: Array<Follows_Companies>;
  /** An aggregate relationship */
  follows_companies_aggregate: Follows_Companies_Aggregate;
  /** fetch data from the table in a streaming manner: "follows_companies" */
  follows_companies_stream: Array<Follows_Companies>;
  /** An array relationship */
  follows_people: Array<Follows_People>;
  /** An aggregate relationship */
  follows_people_aggregate: Follows_People_Aggregate;
  /** fetch data from the table in a streaming manner: "follows_people" */
  follows_people_stream: Array<Follows_People>;
  /** fetch data from the table in a streaming manner: "follows" */
  follows_stream: Array<Follows>;
  /** fetch data from the table: "follows_vc_firms" */
  follows_vc_firms: Array<Follows_Vc_Firms>;
  /** fetch aggregated fields from the table: "follows_vc_firms" */
  follows_vc_firms_aggregate: Follows_Vc_Firms_Aggregate;
  /** fetch data from the table in a streaming manner: "follows_vc_firms" */
  follows_vc_firms_stream: Array<Follows_Vc_Firms>;
  /** An array relationship */
  investment_rounds: Array<Investment_Rounds>;
  /** An aggregate relationship */
  investment_rounds_aggregate: Investment_Rounds_Aggregate;
  /** fetch data from the table: "investment_rounds" using primary key columns */
  investment_rounds_by_pk: Maybe<Investment_Rounds>;
  /** fetch data from the table in a streaming manner: "investment_rounds" */
  investment_rounds_stream: Array<Investment_Rounds>;
  /** An array relationship */
  investments: Array<Investments>;
  /** An aggregate relationship */
  investments_aggregate: Investments_Aggregate;
  /** fetch data from the table: "investments" using primary key columns */
  investments_by_pk: Maybe<Investments>;
  /** fetch data from the table in a streaming manner: "investments" */
  investments_stream: Array<Investments>;
  /** An array relationship */
  investors: Array<Investors>;
  /** An aggregate relationship */
  investors_aggregate: Investors_Aggregate;
  /** fetch data from the table: "investors" using primary key columns */
  investors_by_pk: Maybe<Investors>;
  /** fetch data from the table in a streaming manner: "investors" */
  investors_stream: Array<Investors>;
  /** fetch data from the table: "invited_people" */
  invited_people: Array<Invited_People>;
  /** fetch aggregated fields from the table: "invited_people" */
  invited_people_aggregate: Invited_People_Aggregate;
  /** fetch data from the table: "invited_people" using primary key columns */
  invited_people_by_pk: Maybe<Invited_People>;
  /** fetch data from the table in a streaming manner: "invited_people" */
  invited_people_stream: Array<Invited_People>;
  /** fetch data from the table: "leads" */
  leads: Array<Leads>;
  /** fetch aggregated fields from the table: "leads" */
  leads_aggregate: Leads_Aggregate;
  /** fetch data from the table: "leads" using primary key columns */
  leads_by_pk: Maybe<Leads>;
  /** fetch data from the table: "leads_segmentation" */
  leads_segmentation: Array<Leads_Segmentation>;
  /** fetch aggregated fields from the table: "leads_segmentation" */
  leads_segmentation_aggregate: Leads_Segmentation_Aggregate;
  /** fetch data from the table: "leads_segmentation" using primary key columns */
  leads_segmentation_by_pk: Maybe<Leads_Segmentation>;
  /** fetch data from the table in a streaming manner: "leads_segmentation" */
  leads_segmentation_stream: Array<Leads_Segmentation>;
  /** fetch data from the table in a streaming manner: "leads" */
  leads_stream: Array<Leads>;
  /** An array relationship */
  likes: Array<Likes>;
  /** An aggregate relationship */
  likes_aggregate: Likes_Aggregate;
  /** fetch data from the table: "likes" using primary key columns */
  likes_by_pk: Maybe<Likes>;
  /** fetch data from the table in a streaming manner: "likes" */
  likes_stream: Array<Likes>;
  /** An array relationship */
  list_members: Array<List_Members>;
  /** An aggregate relationship */
  list_members_aggregate: List_Members_Aggregate;
  /** fetch data from the table: "list_members" using primary key columns */
  list_members_by_pk: Maybe<List_Members>;
  /** fetch data from the table in a streaming manner: "list_members" */
  list_members_stream: Array<List_Members>;
  /** An array relationship */
  list_user_groups: Array<List_User_Groups>;
  /** An aggregate relationship */
  list_user_groups_aggregate: List_User_Groups_Aggregate;
  /** fetch data from the table: "list_user_groups" using primary key columns */
  list_user_groups_by_pk: Maybe<List_User_Groups>;
  /** fetch data from the table in a streaming manner: "list_user_groups" */
  list_user_groups_stream: Array<List_User_Groups>;
  /** fetch data from the table: "lists" */
  lists: Array<Lists>;
  /** fetch aggregated fields from the table: "lists" */
  lists_aggregate: Lists_Aggregate;
  /** fetch data from the table: "lists" using primary key columns */
  lists_by_pk: Maybe<Lists>;
  /** fetch data from the table in a streaming manner: "lists" */
  lists_stream: Array<Lists>;
  /** fetch data from the table: "news" */
  news: Array<News>;
  /** fetch aggregated fields from the table: "news" */
  news_aggregate: News_Aggregate;
  /** fetch data from the table: "news" using primary key columns */
  news_by_pk: Maybe<News>;
  /** fetch data from the table: "news_organizations" */
  news_organizations: Array<News_Organizations>;
  /** fetch aggregated fields from the table: "news_organizations" */
  news_organizations_aggregate: News_Organizations_Aggregate;
  /** fetch data from the table: "news_organizations" using primary key columns */
  news_organizations_by_pk: Maybe<News_Organizations>;
  /** fetch data from the table in a streaming manner: "news_organizations" */
  news_organizations_stream: Array<News_Organizations>;
  /** fetch data from the table: "news_person" */
  news_person: Array<News_Person>;
  /** fetch aggregated fields from the table: "news_person" */
  news_person_aggregate: News_Person_Aggregate;
  /** fetch data from the table: "news_person" using primary key columns */
  news_person_by_pk: Maybe<News_Person>;
  /** fetch data from the table in a streaming manner: "news_person" */
  news_person_stream: Array<News_Person>;
  /** fetch data from the table: "news_related_organizations" */
  news_related_organizations: Array<News_Related_Organizations>;
  /** fetch aggregated fields from the table: "news_related_organizations" */
  news_related_organizations_aggregate: News_Related_Organizations_Aggregate;
  /** fetch data from the table: "news_related_organizations" using primary key columns */
  news_related_organizations_by_pk: Maybe<News_Related_Organizations>;
  /** fetch data from the table in a streaming manner: "news_related_organizations" */
  news_related_organizations_stream: Array<News_Related_Organizations>;
  /** fetch data from the table: "news_related_person" */
  news_related_person: Array<News_Related_Person>;
  /** fetch aggregated fields from the table: "news_related_person" */
  news_related_person_aggregate: News_Related_Person_Aggregate;
  /** fetch data from the table: "news_related_person" using primary key columns */
  news_related_person_by_pk: Maybe<News_Related_Person>;
  /** fetch data from the table in a streaming manner: "news_related_person" */
  news_related_person_stream: Array<News_Related_Person>;
  /** fetch data from the table in a streaming manner: "news" */
  news_stream: Array<News>;
  /** An array relationship */
  notes: Array<Notes>;
  /** An aggregate relationship */
  notes_aggregate: Notes_Aggregate;
  /** fetch data from the table: "notes" using primary key columns */
  notes_by_pk: Maybe<Notes>;
  /** fetch data from the table in a streaming manner: "notes" */
  notes_stream: Array<Notes>;
  /** An array relationship */
  notification_actions: Array<Notification_Actions>;
  /** An aggregate relationship */
  notification_actions_aggregate: Notification_Actions_Aggregate;
  /** fetch data from the table: "notification_actions" using primary key columns */
  notification_actions_by_pk: Maybe<Notification_Actions>;
  /** fetch data from the table in a streaming manner: "notification_actions" */
  notification_actions_stream: Array<Notification_Actions>;
  /** fetch data from the table: "notifications" */
  notifications: Array<Notifications>;
  /** fetch aggregated fields from the table: "notifications" */
  notifications_aggregate: Notifications_Aggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notifications_by_pk: Maybe<Notifications>;
  /** fetch data from the table in a streaming manner: "notifications" */
  notifications_stream: Array<Notifications>;
  /** fetch data from the table: "people" */
  people: Array<People>;
  /** fetch aggregated fields from the table: "people" */
  people_aggregate: People_Aggregate;
  /** fetch data from the table: "people" using primary key columns */
  people_by_pk: Maybe<People>;
  /** fetch data from the table: "people_computed_data" */
  people_computed_data: Array<People_Computed_Data>;
  /** fetch aggregated fields from the table: "people_computed_data" */
  people_computed_data_aggregate: People_Computed_Data_Aggregate;
  /** fetch data from the table: "people_computed_data" using primary key columns */
  people_computed_data_by_pk: Maybe<People_Computed_Data>;
  /** fetch data from the table in a streaming manner: "people_computed_data" */
  people_computed_data_stream: Array<People_Computed_Data>;
  /** fetch data from the table in a streaming manner: "people" */
  people_stream: Array<People>;
  /** fetch data from the table: "reset_passwords" */
  reset_passwords: Array<Reset_Passwords>;
  /** fetch aggregated fields from the table: "reset_passwords" */
  reset_passwords_aggregate: Reset_Passwords_Aggregate;
  /** fetch data from the table: "reset_passwords" using primary key columns */
  reset_passwords_by_pk: Maybe<Reset_Passwords>;
  /** fetch data from the table in a streaming manner: "reset_passwords" */
  reset_passwords_stream: Array<Reset_Passwords>;
  /** fetch data from the table: "resource_edit_access" */
  resource_edit_access: Array<Resource_Edit_Access>;
  /** fetch aggregated fields from the table: "resource_edit_access" */
  resource_edit_access_aggregate: Resource_Edit_Access_Aggregate;
  /** fetch data from the table: "resource_edit_access" using primary key columns */
  resource_edit_access_by_pk: Maybe<Resource_Edit_Access>;
  /** fetch data from the table in a streaming manner: "resource_edit_access" */
  resource_edit_access_stream: Array<Resource_Edit_Access>;
  /** fetch data from the table: "resource_links" */
  resource_links: Array<Resource_Links>;
  /** fetch aggregated fields from the table: "resource_links" */
  resource_links_aggregate: Resource_Links_Aggregate;
  /** fetch data from the table: "resource_links" using primary key columns */
  resource_links_by_pk: Maybe<Resource_Links>;
  /** fetch data from the table in a streaming manner: "resource_links" */
  resource_links_stream: Array<Resource_Links>;
  /** An array relationship */
  team_members: Array<Team_Members>;
  /** An aggregate relationship */
  team_members_aggregate: Team_Members_Aggregate;
  /** fetch data from the table: "team_members" using primary key columns */
  team_members_by_pk: Maybe<Team_Members>;
  /** fetch data from the table in a streaming manner: "team_members" */
  team_members_stream: Array<Team_Members>;
  /** An array relationship */
  user_group_invites: Array<User_Group_Invites>;
  /** An aggregate relationship */
  user_group_invites_aggregate: User_Group_Invites_Aggregate;
  /** fetch data from the table: "user_group_invites" using primary key columns */
  user_group_invites_by_pk: Maybe<User_Group_Invites>;
  /** fetch data from the table in a streaming manner: "user_group_invites" */
  user_group_invites_stream: Array<User_Group_Invites>;
  /** An array relationship */
  user_group_members: Array<User_Group_Members>;
  /** An aggregate relationship */
  user_group_members_aggregate: User_Group_Members_Aggregate;
  /** fetch data from the table: "user_group_members" using primary key columns */
  user_group_members_by_pk: Maybe<User_Group_Members>;
  /** fetch data from the table in a streaming manner: "user_group_members" */
  user_group_members_stream: Array<User_Group_Members>;
  /** fetch data from the table: "user_groups" */
  user_groups: Array<User_Groups>;
  /** fetch aggregated fields from the table: "user_groups" */
  user_groups_aggregate: User_Groups_Aggregate;
  /** fetch data from the table: "user_groups" using primary key columns */
  user_groups_by_pk: Maybe<User_Groups>;
  /** fetch data from the table in a streaming manner: "user_groups" */
  user_groups_stream: Array<User_Groups>;
  /** fetch data from the table: "user_tokens" */
  user_tokens: Array<User_Tokens>;
  /** fetch aggregated fields from the table: "user_tokens" */
  user_tokens_aggregate: User_Tokens_Aggregate;
  /** fetch data from the table: "user_tokens" using primary key columns */
  user_tokens_by_pk: Maybe<User_Tokens>;
  /** fetch data from the table in a streaming manner: "user_tokens" */
  user_tokens_stream: Array<User_Tokens>;
  /** fetch data from the table: "user_transactions" */
  user_transactions: Array<User_Transactions>;
  /** fetch aggregated fields from the table: "user_transactions" */
  user_transactions_aggregate: User_Transactions_Aggregate;
  /** fetch data from the table: "user_transactions" using primary key columns */
  user_transactions_by_pk: Maybe<User_Transactions>;
  /** fetch data from the table in a streaming manner: "user_transactions" */
  user_transactions_stream: Array<User_Transactions>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk: Maybe<Users>;
  /** fetch data from the table: "users_public" */
  users_public: Array<Users_Public>;
  /** fetch aggregated fields from the table: "users_public" */
  users_public_aggregate: Users_Public_Aggregate;
  /** fetch data from the table in a streaming manner: "users_public" */
  users_public_stream: Array<Users_Public>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "vc_firms" */
  vc_firms: Array<Vc_Firms>;
  /** fetch aggregated fields from the table: "vc_firms" */
  vc_firms_aggregate: Vc_Firms_Aggregate;
  /** fetch data from the table: "vc_firms" using primary key columns */
  vc_firms_by_pk: Maybe<Vc_Firms>;
  /** fetch data from the table: "vc_firms_edit_access" */
  vc_firms_edit_access: Array<Vc_Firms_Edit_Access>;
  /** fetch aggregated fields from the table: "vc_firms_edit_access" */
  vc_firms_edit_access_aggregate: Vc_Firms_Edit_Access_Aggregate;
  /** fetch data from the table in a streaming manner: "vc_firms_edit_access" */
  vc_firms_edit_access_stream: Array<Vc_Firms_Edit_Access>;
  /** fetch data from the table in a streaming manner: "vc_firms" */
  vc_firms_stream: Array<Vc_Firms>;
  /** fetch data from the table: "waitlist_emails" */
  waitlist_emails: Array<Waitlist_Emails>;
  /** fetch aggregated fields from the table: "waitlist_emails" */
  waitlist_emails_aggregate: Waitlist_Emails_Aggregate;
  /** fetch data from the table: "waitlist_emails" using primary key columns */
  waitlist_emails_by_pk: Maybe<Waitlist_Emails>;
  /** fetch data from the table in a streaming manner: "waitlist_emails" */
  waitlist_emails_stream: Array<Waitlist_Emails>;
};


export type Subscription_RootActionsArgs = {
  distinct_on: InputMaybe<Array<Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Actions_Order_By>>;
  where: InputMaybe<Actions_Bool_Exp>;
};


export type Subscription_RootActions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Actions_Order_By>>;
  where: InputMaybe<Actions_Bool_Exp>;
};


export type Subscription_RootActions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootActions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Actions_Stream_Cursor_Input>>;
  where: InputMaybe<Actions_Bool_Exp>;
};


export type Subscription_RootAllowed_EmailsArgs = {
  distinct_on: InputMaybe<Array<Allowed_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Allowed_Emails_Order_By>>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};


export type Subscription_RootAllowed_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Allowed_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Allowed_Emails_Order_By>>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};


export type Subscription_RootAllowed_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootAllowed_Emails_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Allowed_Emails_Stream_Cursor_Input>>;
  where: InputMaybe<Allowed_Emails_Bool_Exp>;
};


export type Subscription_RootApplication_MetaArgs = {
  distinct_on: InputMaybe<Array<Application_Meta_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Application_Meta_Order_By>>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};


export type Subscription_RootApplication_Meta_AggregateArgs = {
  distinct_on: InputMaybe<Array<Application_Meta_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Application_Meta_Order_By>>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};


export type Subscription_RootApplication_Meta_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootApplication_Meta_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Application_Meta_Stream_Cursor_Input>>;
  where: InputMaybe<Application_Meta_Bool_Exp>;
};


export type Subscription_RootBilling_OrgArgs = {
  distinct_on: InputMaybe<Array<Billing_Org_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Billing_Org_Order_By>>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};


export type Subscription_RootBilling_Org_AggregateArgs = {
  distinct_on: InputMaybe<Array<Billing_Org_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Billing_Org_Order_By>>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};


export type Subscription_RootBilling_Org_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootBilling_Org_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Org_Stream_Cursor_Input>>;
  where: InputMaybe<Billing_Org_Bool_Exp>;
};


export type Subscription_RootBlockchainsArgs = {
  distinct_on: InputMaybe<Array<Blockchains_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Blockchains_Order_By>>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};


export type Subscription_RootBlockchains_AggregateArgs = {
  distinct_on: InputMaybe<Array<Blockchains_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Blockchains_Order_By>>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};


export type Subscription_RootBlockchains_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootBlockchains_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Blockchains_Stream_Cursor_Input>>;
  where: InputMaybe<Blockchains_Bool_Exp>;
};


export type Subscription_RootCoinsArgs = {
  distinct_on: InputMaybe<Array<Coins_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Coins_Order_By>>;
  where: InputMaybe<Coins_Bool_Exp>;
};


export type Subscription_RootCoins_AggregateArgs = {
  distinct_on: InputMaybe<Array<Coins_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Coins_Order_By>>;
  where: InputMaybe<Coins_Bool_Exp>;
};


export type Subscription_RootCoins_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootCoins_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Coins_Stream_Cursor_Input>>;
  where: InputMaybe<Coins_Bool_Exp>;
};


export type Subscription_RootCommentsArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


export type Subscription_RootComments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Comments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Comments_Order_By>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


export type Subscription_RootComments_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootComments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Comments_Stream_Cursor_Input>>;
  where: InputMaybe<Comments_Bool_Exp>;
};


export type Subscription_RootCompaniesArgs = {
  distinct_on: InputMaybe<Array<Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Order_By>>;
  where: InputMaybe<Companies_Bool_Exp>;
};


export type Subscription_RootCompanies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Order_By>>;
  where: InputMaybe<Companies_Bool_Exp>;
};


export type Subscription_RootCompanies_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootCompanies_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


export type Subscription_RootCompanies_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


export type Subscription_RootCompanies_Edit_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Companies_Edit_Access_Stream_Cursor_Input>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


export type Subscription_RootCompanies_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Companies_Stream_Cursor_Input>>;
  where: InputMaybe<Companies_Bool_Exp>;
};


export type Subscription_RootData_ActionsArgs = {
  distinct_on: InputMaybe<Array<Data_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Actions_Order_By>>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};


export type Subscription_RootData_Actions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Actions_Order_By>>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};


export type Subscription_RootData_Actions_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootData_Actions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Actions_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Actions_Bool_Exp>;
};


export type Subscription_RootData_DiscardArgs = {
  distinct_on: InputMaybe<Array<Data_Discard_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Discard_Order_By>>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};


export type Subscription_RootData_Discard_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Discard_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Discard_Order_By>>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};


export type Subscription_RootData_Discard_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootData_Discard_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Discard_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Discard_Bool_Exp>;
};


export type Subscription_RootData_FieldsArgs = {
  distinct_on: InputMaybe<Array<Data_Fields_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Fields_Order_By>>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};


export type Subscription_RootData_Fields_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Fields_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Fields_Order_By>>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};


export type Subscription_RootData_Fields_By_PkArgs = {
  path: Scalars['String'];
};


export type Subscription_RootData_Fields_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Fields_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Fields_Bool_Exp>;
};


export type Subscription_RootData_PartnersArgs = {
  distinct_on: InputMaybe<Array<Data_Partners_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Partners_Order_By>>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};


export type Subscription_RootData_Partners_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Partners_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Partners_Order_By>>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};


export type Subscription_RootData_Partners_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootData_Partners_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Partners_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Partners_Bool_Exp>;
};


export type Subscription_RootData_RawArgs = {
  distinct_on: InputMaybe<Array<Data_Raw_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Raw_Order_By>>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};


export type Subscription_RootData_Raw_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Raw_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Raw_Order_By>>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};


export type Subscription_RootData_Raw_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootData_Raw_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Raw_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Raw_Bool_Exp>;
};


export type Subscription_RootData_RunsArgs = {
  distinct_on: InputMaybe<Array<Data_Runs_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Runs_Order_By>>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};


export type Subscription_RootData_Runs_AggregateArgs = {
  distinct_on: InputMaybe<Array<Data_Runs_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Data_Runs_Order_By>>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};


export type Subscription_RootData_Runs_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootData_Runs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Data_Runs_Stream_Cursor_Input>>;
  where: InputMaybe<Data_Runs_Bool_Exp>;
};


export type Subscription_RootDisabled_EmailsArgs = {
  distinct_on: InputMaybe<Array<Disabled_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Disabled_Emails_Order_By>>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};


export type Subscription_RootDisabled_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Disabled_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Disabled_Emails_Order_By>>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};


export type Subscription_RootDisabled_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootDisabled_Emails_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Disabled_Emails_Stream_Cursor_Input>>;
  where: InputMaybe<Disabled_Emails_Bool_Exp>;
};


export type Subscription_RootEvent_OrganizationArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


export type Subscription_RootEvent_Organization_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Organization_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Organization_Order_By>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


export type Subscription_RootEvent_Organization_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootEvent_Organization_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Event_Organization_Stream_Cursor_Input>>;
  where: InputMaybe<Event_Organization_Bool_Exp>;
};


export type Subscription_RootEvent_PersonArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


export type Subscription_RootEvent_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Person_Order_By>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


export type Subscription_RootEvent_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootEvent_Person_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Event_Person_Stream_Cursor_Input>>;
  where: InputMaybe<Event_Person_Bool_Exp>;
};


export type Subscription_RootEventsArgs = {
  distinct_on: InputMaybe<Array<Events_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Events_Order_By>>;
  where: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootEvents_AggregateArgs = {
  distinct_on: InputMaybe<Array<Events_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Events_Order_By>>;
  where: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootEvents_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootEvents_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Events_Stream_Cursor_Input>>;
  where: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootFollowsArgs = {
  distinct_on: InputMaybe<Array<Follows_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Order_By>>;
  where: InputMaybe<Follows_Bool_Exp>;
};


export type Subscription_RootFollows_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Order_By>>;
  where: InputMaybe<Follows_Bool_Exp>;
};


export type Subscription_RootFollows_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootFollows_CompaniesArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


export type Subscription_RootFollows_Companies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Companies_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Companies_Order_By>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


export type Subscription_RootFollows_Companies_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Follows_Companies_Stream_Cursor_Input>>;
  where: InputMaybe<Follows_Companies_Bool_Exp>;
};


export type Subscription_RootFollows_PeopleArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


export type Subscription_RootFollows_People_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_People_Order_By>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


export type Subscription_RootFollows_People_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Follows_People_Stream_Cursor_Input>>;
  where: InputMaybe<Follows_People_Bool_Exp>;
};


export type Subscription_RootFollows_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Follows_Stream_Cursor_Input>>;
  where: InputMaybe<Follows_Bool_Exp>;
};


export type Subscription_RootFollows_Vc_FirmsArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


export type Subscription_RootFollows_Vc_Firms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


export type Subscription_RootFollows_Vc_Firms_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Follows_Vc_Firms_Stream_Cursor_Input>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


export type Subscription_RootInvestment_RoundsArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


export type Subscription_RootInvestment_Rounds_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investment_Rounds_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investment_Rounds_Order_By>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


export type Subscription_RootInvestment_Rounds_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootInvestment_Rounds_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Investment_Rounds_Stream_Cursor_Input>>;
  where: InputMaybe<Investment_Rounds_Bool_Exp>;
};


export type Subscription_RootInvestmentsArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


export type Subscription_RootInvestments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


export type Subscription_RootInvestments_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootInvestments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Investments_Stream_Cursor_Input>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


export type Subscription_RootInvestorsArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


export type Subscription_RootInvestors_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


export type Subscription_RootInvestors_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootInvestors_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Investors_Stream_Cursor_Input>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


export type Subscription_RootInvited_PeopleArgs = {
  distinct_on: InputMaybe<Array<Invited_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Invited_People_Order_By>>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};


export type Subscription_RootInvited_People_AggregateArgs = {
  distinct_on: InputMaybe<Array<Invited_People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Invited_People_Order_By>>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};


export type Subscription_RootInvited_People_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootInvited_People_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Invited_People_Stream_Cursor_Input>>;
  where: InputMaybe<Invited_People_Bool_Exp>;
};


export type Subscription_RootLeadsArgs = {
  distinct_on: InputMaybe<Array<Leads_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Order_By>>;
  where: InputMaybe<Leads_Bool_Exp>;
};


export type Subscription_RootLeads_AggregateArgs = {
  distinct_on: InputMaybe<Array<Leads_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Order_By>>;
  where: InputMaybe<Leads_Bool_Exp>;
};


export type Subscription_RootLeads_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootLeads_SegmentationArgs = {
  distinct_on: InputMaybe<Array<Leads_Segmentation_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Segmentation_Order_By>>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};


export type Subscription_RootLeads_Segmentation_AggregateArgs = {
  distinct_on: InputMaybe<Array<Leads_Segmentation_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Leads_Segmentation_Order_By>>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};


export type Subscription_RootLeads_Segmentation_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootLeads_Segmentation_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Leads_Segmentation_Stream_Cursor_Input>>;
  where: InputMaybe<Leads_Segmentation_Bool_Exp>;
};


export type Subscription_RootLeads_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Leads_Stream_Cursor_Input>>;
  where: InputMaybe<Leads_Bool_Exp>;
};


export type Subscription_RootLikesArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


export type Subscription_RootLikes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Likes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Likes_Order_By>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


export type Subscription_RootLikes_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootLikes_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Likes_Stream_Cursor_Input>>;
  where: InputMaybe<Likes_Bool_Exp>;
};


export type Subscription_RootList_MembersArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


export type Subscription_RootList_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


export type Subscription_RootList_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootList_Members_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<List_Members_Stream_Cursor_Input>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


export type Subscription_RootList_User_GroupsArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


export type Subscription_RootList_User_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


export type Subscription_RootList_User_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootList_User_Groups_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<List_User_Groups_Stream_Cursor_Input>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


export type Subscription_RootListsArgs = {
  distinct_on: InputMaybe<Array<Lists_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Lists_Order_By>>;
  where: InputMaybe<Lists_Bool_Exp>;
};


export type Subscription_RootLists_AggregateArgs = {
  distinct_on: InputMaybe<Array<Lists_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Lists_Order_By>>;
  where: InputMaybe<Lists_Bool_Exp>;
};


export type Subscription_RootLists_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootLists_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Lists_Stream_Cursor_Input>>;
  where: InputMaybe<Lists_Bool_Exp>;
};


export type Subscription_RootNewsArgs = {
  distinct_on: InputMaybe<Array<News_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Order_By>>;
  where: InputMaybe<News_Bool_Exp>;
};


export type Subscription_RootNews_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Order_By>>;
  where: InputMaybe<News_Bool_Exp>;
};


export type Subscription_RootNews_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNews_OrganizationsArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_Organizations_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNews_Organizations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<News_Organizations_Stream_Cursor_Input>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_PersonArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


export type Subscription_RootNews_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Person_Order_By>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


export type Subscription_RootNews_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNews_Person_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<News_Person_Stream_Cursor_Input>>;
  where: InputMaybe<News_Person_Bool_Exp>;
};


export type Subscription_RootNews_Related_OrganizationsArgs = {
  distinct_on: InputMaybe<Array<News_Related_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Organizations_Order_By>>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_Related_Organizations_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Related_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Organizations_Order_By>>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_Related_Organizations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNews_Related_Organizations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<News_Related_Organizations_Stream_Cursor_Input>>;
  where: InputMaybe<News_Related_Organizations_Bool_Exp>;
};


export type Subscription_RootNews_Related_PersonArgs = {
  distinct_on: InputMaybe<Array<News_Related_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Person_Order_By>>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};


export type Subscription_RootNews_Related_Person_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Related_Person_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Related_Person_Order_By>>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};


export type Subscription_RootNews_Related_Person_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNews_Related_Person_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<News_Related_Person_Stream_Cursor_Input>>;
  where: InputMaybe<News_Related_Person_Bool_Exp>;
};


export type Subscription_RootNews_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<News_Stream_Cursor_Input>>;
  where: InputMaybe<News_Bool_Exp>;
};


export type Subscription_RootNotesArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


export type Subscription_RootNotes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


export type Subscription_RootNotes_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNotes_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Notes_Stream_Cursor_Input>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


export type Subscription_RootNotification_ActionsArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


export type Subscription_RootNotification_Actions_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notification_Actions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notification_Actions_Order_By>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


export type Subscription_RootNotification_Actions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNotification_Actions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Notification_Actions_Stream_Cursor_Input>>;
  where: InputMaybe<Notification_Actions_Bool_Exp>;
};


export type Subscription_RootNotificationsArgs = {
  distinct_on: InputMaybe<Array<Notifications_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notifications_Order_By>>;
  where: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootNotifications_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notifications_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notifications_Order_By>>;
  where: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootNotifications_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootNotifications_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Notifications_Stream_Cursor_Input>>;
  where: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootPeopleArgs = {
  distinct_on: InputMaybe<Array<People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Order_By>>;
  where: InputMaybe<People_Bool_Exp>;
};


export type Subscription_RootPeople_AggregateArgs = {
  distinct_on: InputMaybe<Array<People_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Order_By>>;
  where: InputMaybe<People_Bool_Exp>;
};


export type Subscription_RootPeople_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootPeople_Computed_DataArgs = {
  distinct_on: InputMaybe<Array<People_Computed_Data_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Computed_Data_Order_By>>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};


export type Subscription_RootPeople_Computed_Data_AggregateArgs = {
  distinct_on: InputMaybe<Array<People_Computed_Data_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<People_Computed_Data_Order_By>>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};


export type Subscription_RootPeople_Computed_Data_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootPeople_Computed_Data_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<People_Computed_Data_Stream_Cursor_Input>>;
  where: InputMaybe<People_Computed_Data_Bool_Exp>;
};


export type Subscription_RootPeople_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<People_Stream_Cursor_Input>>;
  where: InputMaybe<People_Bool_Exp>;
};


export type Subscription_RootReset_PasswordsArgs = {
  distinct_on: InputMaybe<Array<Reset_Passwords_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Reset_Passwords_Order_By>>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};


export type Subscription_RootReset_Passwords_AggregateArgs = {
  distinct_on: InputMaybe<Array<Reset_Passwords_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Reset_Passwords_Order_By>>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};


export type Subscription_RootReset_Passwords_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootReset_Passwords_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Reset_Passwords_Stream_Cursor_Input>>;
  where: InputMaybe<Reset_Passwords_Bool_Exp>;
};


export type Subscription_RootResource_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Resource_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Edit_Access_Order_By>>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};


export type Subscription_RootResource_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Edit_Access_Order_By>>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};


export type Subscription_RootResource_Edit_Access_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootResource_Edit_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Resource_Edit_Access_Stream_Cursor_Input>>;
  where: InputMaybe<Resource_Edit_Access_Bool_Exp>;
};


export type Subscription_RootResource_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


export type Subscription_RootResource_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


export type Subscription_RootResource_Links_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootResource_Links_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Resource_Links_Stream_Cursor_Input>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


export type Subscription_RootTeam_MembersArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


export type Subscription_RootTeam_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<Team_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Team_Members_Order_By>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


export type Subscription_RootTeam_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootTeam_Members_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Team_Members_Stream_Cursor_Input>>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};


export type Subscription_RootUser_Group_InvitesArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


export type Subscription_RootUser_Group_Invites_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


export type Subscription_RootUser_Group_Invites_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Group_Invites_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<User_Group_Invites_Stream_Cursor_Input>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


export type Subscription_RootUser_Group_MembersArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


export type Subscription_RootUser_Group_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


export type Subscription_RootUser_Group_Members_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Group_Members_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<User_Group_Members_Stream_Cursor_Input>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


export type Subscription_RootUser_GroupsArgs = {
  distinct_on: InputMaybe<Array<User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Groups_Order_By>>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};


export type Subscription_RootUser_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Groups_Order_By>>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};


export type Subscription_RootUser_Groups_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Groups_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<User_Groups_Stream_Cursor_Input>>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};


export type Subscription_RootUser_TokensArgs = {
  distinct_on: InputMaybe<Array<User_Tokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Tokens_Order_By>>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};


export type Subscription_RootUser_Tokens_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Tokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Tokens_Order_By>>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};


export type Subscription_RootUser_Tokens_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Tokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<User_Tokens_Stream_Cursor_Input>>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};


export type Subscription_RootUser_TransactionsArgs = {
  distinct_on: InputMaybe<Array<User_Transactions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Transactions_Order_By>>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};


export type Subscription_RootUser_Transactions_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Transactions_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Transactions_Order_By>>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};


export type Subscription_RootUser_Transactions_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUser_Transactions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<User_Transactions_Stream_Cursor_Input>>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};


export type Subscription_RootUsersArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootUsers_PublicArgs = {
  distinct_on: InputMaybe<Array<Users_Public_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Public_Order_By>>;
  where: InputMaybe<Users_Public_Bool_Exp>;
};


export type Subscription_RootUsers_Public_AggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Public_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Public_Order_By>>;
  where: InputMaybe<Users_Public_Bool_Exp>;
};


export type Subscription_RootUsers_Public_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Users_Public_Stream_Cursor_Input>>;
  where: InputMaybe<Users_Public_Bool_Exp>;
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootVc_FirmsArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Order_By>>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};


export type Subscription_RootVc_Firms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Order_By>>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};


export type Subscription_RootVc_Firms_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootVc_Firms_Edit_AccessArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


export type Subscription_RootVc_Firms_Edit_Access_AggregateArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


export type Subscription_RootVc_Firms_Edit_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Vc_Firms_Edit_Access_Stream_Cursor_Input>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


export type Subscription_RootVc_Firms_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Vc_Firms_Stream_Cursor_Input>>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};


export type Subscription_RootWaitlist_EmailsArgs = {
  distinct_on: InputMaybe<Array<Waitlist_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Waitlist_Emails_Order_By>>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};


export type Subscription_RootWaitlist_Emails_AggregateArgs = {
  distinct_on: InputMaybe<Array<Waitlist_Emails_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Waitlist_Emails_Order_By>>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};


export type Subscription_RootWaitlist_Emails_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootWaitlist_Emails_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Waitlist_Emails_Stream_Cursor_Input>>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};

/** columns and relationships of "team_members" */
export type Team_Members = {
  __typename?: 'team_members';
  /** An object relationship */
  company: Maybe<Companies>;
  company_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Scalars['Int'];
  external_id: Maybe<Scalars['String']>;
  founder: Maybe<Scalars['Boolean']>;
  function: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object relationship */
  person: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
};

/** aggregated selection of "team_members" */
export type Team_Members_Aggregate = {
  __typename?: 'team_members_aggregate';
  aggregate: Maybe<Team_Members_Aggregate_Fields>;
  nodes: Array<Team_Members>;
};

export type Team_Members_Aggregate_Bool_Exp = {
  bool_and: InputMaybe<Team_Members_Aggregate_Bool_Exp_Bool_And>;
  bool_or: InputMaybe<Team_Members_Aggregate_Bool_Exp_Bool_Or>;
  count: InputMaybe<Team_Members_Aggregate_Bool_Exp_Count>;
};

export type Team_Members_Aggregate_Bool_Exp_Bool_And = {
  arguments: Team_Members_Select_Column_Team_Members_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Team_Members_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Team_Members_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Team_Members_Select_Column_Team_Members_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Team_Members_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Team_Members_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Team_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Team_Members_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "team_members" */
export type Team_Members_Aggregate_Fields = {
  __typename?: 'team_members_aggregate_fields';
  avg: Maybe<Team_Members_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Team_Members_Max_Fields>;
  min: Maybe<Team_Members_Min_Fields>;
  stddev: Maybe<Team_Members_Stddev_Fields>;
  stddev_pop: Maybe<Team_Members_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Team_Members_Stddev_Samp_Fields>;
  sum: Maybe<Team_Members_Sum_Fields>;
  var_pop: Maybe<Team_Members_Var_Pop_Fields>;
  var_samp: Maybe<Team_Members_Var_Samp_Fields>;
  variance: Maybe<Team_Members_Variance_Fields>;
};


/** aggregate fields of "team_members" */
export type Team_Members_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Team_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "team_members" */
export type Team_Members_Aggregate_Order_By = {
  avg: InputMaybe<Team_Members_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Team_Members_Max_Order_By>;
  min: InputMaybe<Team_Members_Min_Order_By>;
  stddev: InputMaybe<Team_Members_Stddev_Order_By>;
  stddev_pop: InputMaybe<Team_Members_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Team_Members_Stddev_Samp_Order_By>;
  sum: InputMaybe<Team_Members_Sum_Order_By>;
  var_pop: InputMaybe<Team_Members_Var_Pop_Order_By>;
  var_samp: InputMaybe<Team_Members_Var_Samp_Order_By>;
  variance: InputMaybe<Team_Members_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "team_members" */
export type Team_Members_Arr_Rel_Insert_Input = {
  data: Array<Team_Members_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Team_Members_On_Conflict>;
};

/** aggregate avg on columns */
export type Team_Members_Avg_Fields = {
  __typename?: 'team_members_avg_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "team_members" */
export type Team_Members_Avg_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "team_members". All fields are combined with a logical 'AND'. */
export type Team_Members_Bool_Exp = {
  _and: InputMaybe<Array<Team_Members_Bool_Exp>>;
  _not: InputMaybe<Team_Members_Bool_Exp>;
  _or: InputMaybe<Array<Team_Members_Bool_Exp>>;
  company: InputMaybe<Companies_Bool_Exp>;
  company_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email_address: InputMaybe<String_Comparison_Exp>;
  email_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  end_date: InputMaybe<Date_Comparison_Exp>;
  enrichment_priority: InputMaybe<Int_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  founder: InputMaybe<Boolean_Comparison_Exp>;
  function: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  seniority: InputMaybe<String_Comparison_Exp>;
  start_date: InputMaybe<Date_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "team_members" */
export enum Team_Members_Constraint {
  /** unique or primary key constraint on columns "company_id", "person_id" */
  TeamMembersCompanyIdPersonIdKey = 'team_members_company_id_person_id_key',
  /** unique or primary key constraint on columns "external_id" */
  TeamMembersExternalIdKey = 'team_members_external_id_key',
  /** unique or primary key constraint on columns "id" */
  TeamMembersPkey = 'team_members_pkey'
}

/** input type for incrementing numeric columns in table "team_members" */
export type Team_Members_Inc_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "team_members" */
export type Team_Members_Insert_Input = {
  company: InputMaybe<Companies_Obj_Rel_Insert_Input>;
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Team_Members_Max_Fields = {
  __typename?: 'team_members_max_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  function: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "team_members" */
export type Team_Members_Max_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Team_Members_Min_Fields = {
  __typename?: 'team_members_min_fields';
  company_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  email_address: Maybe<Scalars['String']>;
  email_enriched_at: Maybe<Scalars['timestamptz']>;
  end_date: Maybe<Scalars['date']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  function: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  seniority: Maybe<Scalars['String']>;
  start_date: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "team_members" */
export type Team_Members_Min_Order_By = {
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** response of any mutation on the table "team_members" */
export type Team_Members_Mutation_Response = {
  __typename?: 'team_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Team_Members>;
};

/** on_conflict condition type for table "team_members" */
export type Team_Members_On_Conflict = {
  constraint: Team_Members_Constraint;
  update_columns: Array<Team_Members_Update_Column>;
  where: InputMaybe<Team_Members_Bool_Exp>;
};

/** Ordering options when selecting data from "team_members". */
export type Team_Members_Order_By = {
  company: InputMaybe<Companies_Order_By>;
  company_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  email_address: InputMaybe<Order_By>;
  email_enriched_at: InputMaybe<Order_By>;
  end_date: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  founder: InputMaybe<Order_By>;
  function: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  seniority: InputMaybe<Order_By>;
  start_date: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** primary key columns input for table: team_members */
export type Team_Members_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "team_members" */
export enum Team_Members_Select_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  EmailAddress = 'email_address',
  /** column name */
  EmailEnrichedAt = 'email_enriched_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Founder = 'founder',
  /** column name */
  Function = 'function',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Seniority = 'seniority',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title'
}

/** select "team_members_aggregate_bool_exp_bool_and_arguments_columns" columns of table "team_members" */
export enum Team_Members_Select_Column_Team_Members_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Founder = 'founder'
}

/** select "team_members_aggregate_bool_exp_bool_or_arguments_columns" columns of table "team_members" */
export enum Team_Members_Select_Column_Team_Members_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Founder = 'founder'
}

/** input type for updating data in table "team_members" */
export type Team_Members_Set_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Team_Members_Stddev_Fields = {
  __typename?: 'team_members_stddev_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "team_members" */
export type Team_Members_Stddev_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Team_Members_Stddev_Pop_Fields = {
  __typename?: 'team_members_stddev_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "team_members" */
export type Team_Members_Stddev_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Team_Members_Stddev_Samp_Fields = {
  __typename?: 'team_members_stddev_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "team_members" */
export type Team_Members_Stddev_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "team_members" */
export type Team_Members_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Team_Members_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Team_Members_Stream_Cursor_Value_Input = {
  company_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_address: InputMaybe<Scalars['String']>;
  email_enriched_at: InputMaybe<Scalars['timestamptz']>;
  end_date: InputMaybe<Scalars['date']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  founder: InputMaybe<Scalars['Boolean']>;
  function: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  seniority: InputMaybe<Scalars['String']>;
  start_date: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Team_Members_Sum_Fields = {
  __typename?: 'team_members_sum_fields';
  company_id: Maybe<Scalars['Int']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "team_members" */
export type Team_Members_Sum_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** update columns of table "team_members" */
export enum Team_Members_Update_Column {
  /** column name */
  CompanyId = 'company_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  EmailAddress = 'email_address',
  /** column name */
  EmailEnrichedAt = 'email_enriched_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Founder = 'founder',
  /** column name */
  Function = 'function',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Seniority = 'seniority',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title'
}

export type Team_Members_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Team_Members_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Team_Members_Set_Input>;
  /** filter the rows which have to be updated */
  where: Team_Members_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Team_Members_Var_Pop_Fields = {
  __typename?: 'team_members_var_pop_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "team_members" */
export type Team_Members_Var_Pop_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Team_Members_Var_Samp_Fields = {
  __typename?: 'team_members_var_samp_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "team_members" */
export type Team_Members_Var_Samp_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Team_Members_Variance_Fields = {
  __typename?: 'team_members_variance_fields';
  company_id: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "team_members" */
export type Team_Members_Variance_Order_By = {
  company_id: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  person_id: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'. */
export type Time_Comparison_Exp = {
  _eq: InputMaybe<Scalars['time']>;
  _gt: InputMaybe<Scalars['time']>;
  _gte: InputMaybe<Scalars['time']>;
  _in: InputMaybe<Array<Scalars['time']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['time']>;
  _lte: InputMaybe<Scalars['time']>;
  _neq: InputMaybe<Scalars['time']>;
  _nin: InputMaybe<Array<Scalars['time']>>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq: InputMaybe<Scalars['timestamp']>;
  _gt: InputMaybe<Scalars['timestamp']>;
  _gte: InputMaybe<Scalars['timestamp']>;
  _in: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['timestamp']>;
  _lte: InputMaybe<Scalars['timestamp']>;
  _neq: InputMaybe<Scalars['timestamp']>;
  _nin: InputMaybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq: InputMaybe<Scalars['timestamptz']>;
  _gt: InputMaybe<Scalars['timestamptz']>;
  _gte: InputMaybe<Scalars['timestamptz']>;
  _in: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['timestamptz']>;
  _lte: InputMaybe<Scalars['timestamptz']>;
  _neq: InputMaybe<Scalars['timestamptz']>;
  _nin: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "user_group_invites" */
export type User_Group_Invites = {
  __typename?: 'user_group_invites';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  created_by: Maybe<Users_Public>;
  created_by_user_id: Maybe<Scalars['Int']>;
  email: Scalars['String'];
  id: Scalars['Int'];
  /** An object relationship */
  user_group: User_Groups;
  user_group_id: Scalars['Int'];
};

/** aggregated selection of "user_group_invites" */
export type User_Group_Invites_Aggregate = {
  __typename?: 'user_group_invites_aggregate';
  aggregate: Maybe<User_Group_Invites_Aggregate_Fields>;
  nodes: Array<User_Group_Invites>;
};

export type User_Group_Invites_Aggregate_Bool_Exp = {
  count: InputMaybe<User_Group_Invites_Aggregate_Bool_Exp_Count>;
};

export type User_Group_Invites_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<User_Group_Invites_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_group_invites" */
export type User_Group_Invites_Aggregate_Fields = {
  __typename?: 'user_group_invites_aggregate_fields';
  avg: Maybe<User_Group_Invites_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<User_Group_Invites_Max_Fields>;
  min: Maybe<User_Group_Invites_Min_Fields>;
  stddev: Maybe<User_Group_Invites_Stddev_Fields>;
  stddev_pop: Maybe<User_Group_Invites_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Group_Invites_Stddev_Samp_Fields>;
  sum: Maybe<User_Group_Invites_Sum_Fields>;
  var_pop: Maybe<User_Group_Invites_Var_Pop_Fields>;
  var_samp: Maybe<User_Group_Invites_Var_Samp_Fields>;
  variance: Maybe<User_Group_Invites_Variance_Fields>;
};


/** aggregate fields of "user_group_invites" */
export type User_Group_Invites_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_group_invites" */
export type User_Group_Invites_Aggregate_Order_By = {
  avg: InputMaybe<User_Group_Invites_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<User_Group_Invites_Max_Order_By>;
  min: InputMaybe<User_Group_Invites_Min_Order_By>;
  stddev: InputMaybe<User_Group_Invites_Stddev_Order_By>;
  stddev_pop: InputMaybe<User_Group_Invites_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<User_Group_Invites_Stddev_Samp_Order_By>;
  sum: InputMaybe<User_Group_Invites_Sum_Order_By>;
  var_pop: InputMaybe<User_Group_Invites_Var_Pop_Order_By>;
  var_samp: InputMaybe<User_Group_Invites_Var_Samp_Order_By>;
  variance: InputMaybe<User_Group_Invites_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_group_invites" */
export type User_Group_Invites_Arr_Rel_Insert_Input = {
  data: Array<User_Group_Invites_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<User_Group_Invites_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Group_Invites_Avg_Fields = {
  __typename?: 'user_group_invites_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "user_group_invites" */
export type User_Group_Invites_Avg_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_group_invites". All fields are combined with a logical 'AND'. */
export type User_Group_Invites_Bool_Exp = {
  _and: InputMaybe<Array<User_Group_Invites_Bool_Exp>>;
  _not: InputMaybe<User_Group_Invites_Bool_Exp>;
  _or: InputMaybe<Array<User_Group_Invites_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by: InputMaybe<Users_Public_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  user_group: InputMaybe<User_Groups_Bool_Exp>;
  user_group_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_group_invites" */
export enum User_Group_Invites_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserGroupInvitesPkey = 'user_group_invites_pkey'
}

/** input type for incrementing numeric columns in table "user_group_invites" */
export type User_Group_Invites_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_group_invites" */
export type User_Group_Invites_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user_group: InputMaybe<User_Groups_Obj_Rel_Insert_Input>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type User_Group_Invites_Max_Fields = {
  __typename?: 'user_group_invites_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "user_group_invites" */
export type User_Group_Invites_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Group_Invites_Min_Fields = {
  __typename?: 'user_group_invites_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "user_group_invites" */
export type User_Group_Invites_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_group_invites" */
export type User_Group_Invites_Mutation_Response = {
  __typename?: 'user_group_invites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Group_Invites>;
};

/** on_conflict condition type for table "user_group_invites" */
export type User_Group_Invites_On_Conflict = {
  constraint: User_Group_Invites_Constraint;
  update_columns: Array<User_Group_Invites_Update_Column>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};

/** Ordering options when selecting data from "user_group_invites". */
export type User_Group_Invites_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Users_Public_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group: InputMaybe<User_Groups_Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_group_invites */
export type User_Group_Invites_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_group_invites" */
export enum User_Group_Invites_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UserGroupId = 'user_group_id'
}

/** input type for updating data in table "user_group_invites" */
export type User_Group_Invites_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type User_Group_Invites_Stddev_Fields = {
  __typename?: 'user_group_invites_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "user_group_invites" */
export type User_Group_Invites_Stddev_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Group_Invites_Stddev_Pop_Fields = {
  __typename?: 'user_group_invites_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "user_group_invites" */
export type User_Group_Invites_Stddev_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Group_Invites_Stddev_Samp_Fields = {
  __typename?: 'user_group_invites_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "user_group_invites" */
export type User_Group_Invites_Stddev_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_group_invites" */
export type User_Group_Invites_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Group_Invites_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Group_Invites_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type User_Group_Invites_Sum_Fields = {
  __typename?: 'user_group_invites_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "user_group_invites" */
export type User_Group_Invites_Sum_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** update columns of table "user_group_invites" */
export enum User_Group_Invites_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UserGroupId = 'user_group_id'
}

export type User_Group_Invites_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<User_Group_Invites_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<User_Group_Invites_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Group_Invites_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Group_Invites_Var_Pop_Fields = {
  __typename?: 'user_group_invites_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "user_group_invites" */
export type User_Group_Invites_Var_Pop_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Group_Invites_Var_Samp_Fields = {
  __typename?: 'user_group_invites_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "user_group_invites" */
export type User_Group_Invites_Var_Samp_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Group_Invites_Variance_Fields = {
  __typename?: 'user_group_invites_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "user_group_invites" */
export type User_Group_Invites_Variance_Order_By = {
  created_by_user_id: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
};

/** columns and relationships of "user_group_members" */
export type User_Group_Members = {
  __typename?: 'user_group_members';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  /** An object relationship */
  user: Maybe<Users_Public>;
  /** An object relationship */
  user_group: User_Groups;
  user_group_id: Scalars['Int'];
  user_id: Scalars['Int'];
};

/** aggregated selection of "user_group_members" */
export type User_Group_Members_Aggregate = {
  __typename?: 'user_group_members_aggregate';
  aggregate: Maybe<User_Group_Members_Aggregate_Fields>;
  nodes: Array<User_Group_Members>;
};

export type User_Group_Members_Aggregate_Bool_Exp = {
  count: InputMaybe<User_Group_Members_Aggregate_Bool_Exp_Count>;
};

export type User_Group_Members_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<User_Group_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<User_Group_Members_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_group_members" */
export type User_Group_Members_Aggregate_Fields = {
  __typename?: 'user_group_members_aggregate_fields';
  avg: Maybe<User_Group_Members_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<User_Group_Members_Max_Fields>;
  min: Maybe<User_Group_Members_Min_Fields>;
  stddev: Maybe<User_Group_Members_Stddev_Fields>;
  stddev_pop: Maybe<User_Group_Members_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Group_Members_Stddev_Samp_Fields>;
  sum: Maybe<User_Group_Members_Sum_Fields>;
  var_pop: Maybe<User_Group_Members_Var_Pop_Fields>;
  var_samp: Maybe<User_Group_Members_Var_Samp_Fields>;
  variance: Maybe<User_Group_Members_Variance_Fields>;
};


/** aggregate fields of "user_group_members" */
export type User_Group_Members_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<User_Group_Members_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_group_members" */
export type User_Group_Members_Aggregate_Order_By = {
  avg: InputMaybe<User_Group_Members_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<User_Group_Members_Max_Order_By>;
  min: InputMaybe<User_Group_Members_Min_Order_By>;
  stddev: InputMaybe<User_Group_Members_Stddev_Order_By>;
  stddev_pop: InputMaybe<User_Group_Members_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<User_Group_Members_Stddev_Samp_Order_By>;
  sum: InputMaybe<User_Group_Members_Sum_Order_By>;
  var_pop: InputMaybe<User_Group_Members_Var_Pop_Order_By>;
  var_samp: InputMaybe<User_Group_Members_Var_Samp_Order_By>;
  variance: InputMaybe<User_Group_Members_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_group_members" */
export type User_Group_Members_Arr_Rel_Insert_Input = {
  data: Array<User_Group_Members_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<User_Group_Members_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Group_Members_Avg_Fields = {
  __typename?: 'user_group_members_avg_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "user_group_members" */
export type User_Group_Members_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_group_members". All fields are combined with a logical 'AND'. */
export type User_Group_Members_Bool_Exp = {
  _and: InputMaybe<Array<User_Group_Members_Bool_Exp>>;
  _not: InputMaybe<User_Group_Members_Bool_Exp>;
  _or: InputMaybe<Array<User_Group_Members_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  user: InputMaybe<Users_Public_Bool_Exp>;
  user_group: InputMaybe<User_Groups_Bool_Exp>;
  user_group_id: InputMaybe<Int_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_group_members" */
export enum User_Group_Members_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserGroupMembersPkey = 'user_group_members_pkey'
}

/** input type for incrementing numeric columns in table "user_group_members" */
export type User_Group_Members_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_group_members" */
export type User_Group_Members_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  user: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  user_group: InputMaybe<User_Groups_Obj_Rel_Insert_Input>;
  user_group_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type User_Group_Members_Max_Fields = {
  __typename?: 'user_group_members_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "user_group_members" */
export type User_Group_Members_Max_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Group_Members_Min_Fields = {
  __typename?: 'user_group_members_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "user_group_members" */
export type User_Group_Members_Min_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_group_members" */
export type User_Group_Members_Mutation_Response = {
  __typename?: 'user_group_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Group_Members>;
};

/** on_conflict condition type for table "user_group_members" */
export type User_Group_Members_On_Conflict = {
  constraint: User_Group_Members_Constraint;
  update_columns: Array<User_Group_Members_Update_Column>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};

/** Ordering options when selecting data from "user_group_members". */
export type User_Group_Members_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  user: InputMaybe<Users_Public_Order_By>;
  user_group: InputMaybe<User_Groups_Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_group_members */
export type User_Group_Members_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_group_members" */
export enum User_Group_Members_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UserGroupId = 'user_group_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_group_members" */
export type User_Group_Members_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type User_Group_Members_Stddev_Fields = {
  __typename?: 'user_group_members_stddev_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "user_group_members" */
export type User_Group_Members_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Group_Members_Stddev_Pop_Fields = {
  __typename?: 'user_group_members_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "user_group_members" */
export type User_Group_Members_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Group_Members_Stddev_Samp_Fields = {
  __typename?: 'user_group_members_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "user_group_members" */
export type User_Group_Members_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_group_members" */
export type User_Group_Members_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Group_Members_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Group_Members_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  user_group_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type User_Group_Members_Sum_Fields = {
  __typename?: 'user_group_members_sum_fields';
  id: Maybe<Scalars['Int']>;
  user_group_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "user_group_members" */
export type User_Group_Members_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** update columns of table "user_group_members" */
export enum User_Group_Members_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UserGroupId = 'user_group_id',
  /** column name */
  UserId = 'user_id'
}

export type User_Group_Members_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<User_Group_Members_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<User_Group_Members_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Group_Members_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Group_Members_Var_Pop_Fields = {
  __typename?: 'user_group_members_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "user_group_members" */
export type User_Group_Members_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Group_Members_Var_Samp_Fields = {
  __typename?: 'user_group_members_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "user_group_members" */
export type User_Group_Members_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Group_Members_Variance_Fields = {
  __typename?: 'user_group_members_variance_fields';
  id: Maybe<Scalars['Float']>;
  user_group_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "user_group_members" */
export type User_Group_Members_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  user_group_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** columns and relationships of "user_groups" */
export type User_Groups = {
  __typename?: 'user_groups';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  created_by: Maybe<Users_Public>;
  created_by_user_id: Scalars['Int'];
  description: Maybe<Scalars['String']>;
  discord: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An array relationship */
  list_user_groups: Array<List_User_Groups>;
  /** An aggregate relationship */
  list_user_groups_aggregate: List_User_Groups_Aggregate;
  name: Scalars['String'];
  /** An array relationship */
  notes: Array<Notes>;
  /** An aggregate relationship */
  notes_aggregate: Notes_Aggregate;
  public: Maybe<Scalars['Boolean']>;
  telegram: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  user_group_invites: Array<User_Group_Invites>;
  /** An aggregate relationship */
  user_group_invites_aggregate: User_Group_Invites_Aggregate;
  /** An array relationship */
  user_group_members: Array<User_Group_Members>;
  /** An aggregate relationship */
  user_group_members_aggregate: User_Group_Members_Aggregate;
};


/** columns and relationships of "user_groups" */
export type User_GroupsList_User_GroupsArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsList_User_Groups_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_User_Groups_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_User_Groups_Order_By>>;
  where: InputMaybe<List_User_Groups_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsNotesArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsNotes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Notes_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Notes_Order_By>>;
  where: InputMaybe<Notes_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsUser_Group_InvitesArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsUser_Group_Invites_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Invites_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Invites_Order_By>>;
  where: InputMaybe<User_Group_Invites_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsUser_Group_MembersArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


/** columns and relationships of "user_groups" */
export type User_GroupsUser_Group_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};

/** aggregated selection of "user_groups" */
export type User_Groups_Aggregate = {
  __typename?: 'user_groups_aggregate';
  aggregate: Maybe<User_Groups_Aggregate_Fields>;
  nodes: Array<User_Groups>;
};

/** aggregate fields of "user_groups" */
export type User_Groups_Aggregate_Fields = {
  __typename?: 'user_groups_aggregate_fields';
  avg: Maybe<User_Groups_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<User_Groups_Max_Fields>;
  min: Maybe<User_Groups_Min_Fields>;
  stddev: Maybe<User_Groups_Stddev_Fields>;
  stddev_pop: Maybe<User_Groups_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Groups_Stddev_Samp_Fields>;
  sum: Maybe<User_Groups_Sum_Fields>;
  var_pop: Maybe<User_Groups_Var_Pop_Fields>;
  var_samp: Maybe<User_Groups_Var_Samp_Fields>;
  variance: Maybe<User_Groups_Variance_Fields>;
};


/** aggregate fields of "user_groups" */
export type User_Groups_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<User_Groups_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Groups_Avg_Fields = {
  __typename?: 'user_groups_avg_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_groups". All fields are combined with a logical 'AND'. */
export type User_Groups_Bool_Exp = {
  _and: InputMaybe<Array<User_Groups_Bool_Exp>>;
  _not: InputMaybe<User_Groups_Bool_Exp>;
  _or: InputMaybe<Array<User_Groups_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by: InputMaybe<Users_Public_Bool_Exp>;
  created_by_user_id: InputMaybe<Int_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  discord: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list_user_groups: InputMaybe<List_User_Groups_Bool_Exp>;
  list_user_groups_aggregate: InputMaybe<List_User_Groups_Aggregate_Bool_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  notes: InputMaybe<Notes_Bool_Exp>;
  notes_aggregate: InputMaybe<Notes_Aggregate_Bool_Exp>;
  public: InputMaybe<Boolean_Comparison_Exp>;
  telegram: InputMaybe<String_Comparison_Exp>;
  twitter: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  user_group_invites: InputMaybe<User_Group_Invites_Bool_Exp>;
  user_group_invites_aggregate: InputMaybe<User_Group_Invites_Aggregate_Bool_Exp>;
  user_group_members: InputMaybe<User_Group_Members_Bool_Exp>;
  user_group_members_aggregate: InputMaybe<User_Group_Members_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "user_groups" */
export enum User_Groups_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserGroupsPkey = 'user_groups_pkey'
}

/** input type for incrementing numeric columns in table "user_groups" */
export type User_Groups_Inc_Input = {
  created_by_user_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_groups" */
export type User_Groups_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by: InputMaybe<Users_Public_Obj_Rel_Insert_Input>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  discord: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  list_user_groups: InputMaybe<List_User_Groups_Arr_Rel_Insert_Input>;
  name: InputMaybe<Scalars['String']>;
  notes: InputMaybe<Notes_Arr_Rel_Insert_Input>;
  public: InputMaybe<Scalars['Boolean']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_group_invites: InputMaybe<User_Group_Invites_Arr_Rel_Insert_Input>;
  user_group_members: InputMaybe<User_Group_Members_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type User_Groups_Max_Fields = {
  __typename?: 'user_groups_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  description: Maybe<Scalars['String']>;
  discord: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type User_Groups_Min_Fields = {
  __typename?: 'user_groups_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  created_by_user_id: Maybe<Scalars['Int']>;
  description: Maybe<Scalars['String']>;
  discord: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  name: Maybe<Scalars['String']>;
  telegram: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_groups" */
export type User_Groups_Mutation_Response = {
  __typename?: 'user_groups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Groups>;
};

/** input type for inserting object relation for remote table "user_groups" */
export type User_Groups_Obj_Rel_Insert_Input = {
  data: User_Groups_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<User_Groups_On_Conflict>;
};

/** on_conflict condition type for table "user_groups" */
export type User_Groups_On_Conflict = {
  constraint: User_Groups_Constraint;
  update_columns: Array<User_Groups_Update_Column>;
  where: InputMaybe<User_Groups_Bool_Exp>;
};

/** Ordering options when selecting data from "user_groups". */
export type User_Groups_Order_By = {
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Users_Public_Order_By>;
  created_by_user_id: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  discord: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_user_groups_aggregate: InputMaybe<List_User_Groups_Aggregate_Order_By>;
  name: InputMaybe<Order_By>;
  notes_aggregate: InputMaybe<Notes_Aggregate_Order_By>;
  public: InputMaybe<Order_By>;
  telegram: InputMaybe<Order_By>;
  twitter: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_group_invites_aggregate: InputMaybe<User_Group_Invites_Aggregate_Order_By>;
  user_group_members_aggregate: InputMaybe<User_Group_Members_Aggregate_Order_By>;
};

/** primary key columns input for table: user_groups */
export type User_Groups_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_groups" */
export enum User_Groups_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Description = 'description',
  /** column name */
  Discord = 'discord',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "user_groups" */
export type User_Groups_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  discord: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  public: InputMaybe<Scalars['Boolean']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type User_Groups_Stddev_Fields = {
  __typename?: 'user_groups_stddev_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Groups_Stddev_Pop_Fields = {
  __typename?: 'user_groups_stddev_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Groups_Stddev_Samp_Fields = {
  __typename?: 'user_groups_stddev_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_groups" */
export type User_Groups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Groups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Groups_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  created_by_user_id: InputMaybe<Scalars['Int']>;
  description: InputMaybe<Scalars['String']>;
  discord: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  public: InputMaybe<Scalars['Boolean']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type User_Groups_Sum_Fields = {
  __typename?: 'user_groups_sum_fields';
  created_by_user_id: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "user_groups" */
export enum User_Groups_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByUserId = 'created_by_user_id',
  /** column name */
  Description = 'description',
  /** column name */
  Discord = 'discord',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type User_Groups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<User_Groups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<User_Groups_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Groups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Groups_Var_Pop_Fields = {
  __typename?: 'user_groups_var_pop_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Groups_Var_Samp_Fields = {
  __typename?: 'user_groups_var_samp_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Groups_Variance_Fields = {
  __typename?: 'user_groups_variance_fields';
  created_by_user_id: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
};

/** Store various tokens for user which we can invalidate by deleting them */
export type User_Tokens = {
  __typename?: 'user_tokens';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  token: Scalars['String'];
  type: Scalars['String'];
  user_id: Scalars['Int'];
};

/** aggregated selection of "user_tokens" */
export type User_Tokens_Aggregate = {
  __typename?: 'user_tokens_aggregate';
  aggregate: Maybe<User_Tokens_Aggregate_Fields>;
  nodes: Array<User_Tokens>;
};

/** aggregate fields of "user_tokens" */
export type User_Tokens_Aggregate_Fields = {
  __typename?: 'user_tokens_aggregate_fields';
  avg: Maybe<User_Tokens_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<User_Tokens_Max_Fields>;
  min: Maybe<User_Tokens_Min_Fields>;
  stddev: Maybe<User_Tokens_Stddev_Fields>;
  stddev_pop: Maybe<User_Tokens_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Tokens_Stddev_Samp_Fields>;
  sum: Maybe<User_Tokens_Sum_Fields>;
  var_pop: Maybe<User_Tokens_Var_Pop_Fields>;
  var_samp: Maybe<User_Tokens_Var_Samp_Fields>;
  variance: Maybe<User_Tokens_Variance_Fields>;
};


/** aggregate fields of "user_tokens" */
export type User_Tokens_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<User_Tokens_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Tokens_Avg_Fields = {
  __typename?: 'user_tokens_avg_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_tokens". All fields are combined with a logical 'AND'. */
export type User_Tokens_Bool_Exp = {
  _and: InputMaybe<Array<User_Tokens_Bool_Exp>>;
  _not: InputMaybe<User_Tokens_Bool_Exp>;
  _or: InputMaybe<Array<User_Tokens_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  token: InputMaybe<String_Comparison_Exp>;
  type: InputMaybe<String_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_tokens" */
export enum User_Tokens_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserTokensPkey = 'user_tokens_pkey'
}

/** input type for incrementing numeric columns in table "user_tokens" */
export type User_Tokens_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_tokens" */
export type User_Tokens_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  token: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type User_Tokens_Max_Fields = {
  __typename?: 'user_tokens_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  token: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type User_Tokens_Min_Fields = {
  __typename?: 'user_tokens_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['Int']>;
  token: Maybe<Scalars['String']>;
  type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "user_tokens" */
export type User_Tokens_Mutation_Response = {
  __typename?: 'user_tokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Tokens>;
};

/** on_conflict condition type for table "user_tokens" */
export type User_Tokens_On_Conflict = {
  constraint: User_Tokens_Constraint;
  update_columns: Array<User_Tokens_Update_Column>;
  where: InputMaybe<User_Tokens_Bool_Exp>;
};

/** Ordering options when selecting data from "user_tokens". */
export type User_Tokens_Order_By = {
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  token: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_tokens */
export type User_Tokens_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_tokens" */
export enum User_Tokens_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Token = 'token',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_tokens" */
export type User_Tokens_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  token: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type User_Tokens_Stddev_Fields = {
  __typename?: 'user_tokens_stddev_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Tokens_Stddev_Pop_Fields = {
  __typename?: 'user_tokens_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Tokens_Stddev_Samp_Fields = {
  __typename?: 'user_tokens_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_tokens" */
export type User_Tokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Tokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Tokens_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['Int']>;
  token: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type User_Tokens_Sum_Fields = {
  __typename?: 'user_tokens_sum_fields';
  id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "user_tokens" */
export enum User_Tokens_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Token = 'token',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id'
}

export type User_Tokens_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<User_Tokens_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<User_Tokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Tokens_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Tokens_Var_Pop_Fields = {
  __typename?: 'user_tokens_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Tokens_Var_Samp_Fields = {
  __typename?: 'user_tokens_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Tokens_Variance_Fields = {
  __typename?: 'user_tokens_variance_fields';
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "user_transactions" */
export type User_Transactions = {
  __typename?: 'user_transactions';
  amount: Scalars['Int'];
  created_at: Scalars['timestamp'];
  created_by: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  note: Maybe<Scalars['String']>;
  user_id: Scalars['Int'];
};

/** aggregated selection of "user_transactions" */
export type User_Transactions_Aggregate = {
  __typename?: 'user_transactions_aggregate';
  aggregate: Maybe<User_Transactions_Aggregate_Fields>;
  nodes: Array<User_Transactions>;
};

/** aggregate fields of "user_transactions" */
export type User_Transactions_Aggregate_Fields = {
  __typename?: 'user_transactions_aggregate_fields';
  avg: Maybe<User_Transactions_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<User_Transactions_Max_Fields>;
  min: Maybe<User_Transactions_Min_Fields>;
  stddev: Maybe<User_Transactions_Stddev_Fields>;
  stddev_pop: Maybe<User_Transactions_Stddev_Pop_Fields>;
  stddev_samp: Maybe<User_Transactions_Stddev_Samp_Fields>;
  sum: Maybe<User_Transactions_Sum_Fields>;
  var_pop: Maybe<User_Transactions_Var_Pop_Fields>;
  var_samp: Maybe<User_Transactions_Var_Samp_Fields>;
  variance: Maybe<User_Transactions_Variance_Fields>;
};


/** aggregate fields of "user_transactions" */
export type User_Transactions_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<User_Transactions_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Transactions_Avg_Fields = {
  __typename?: 'user_transactions_avg_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_transactions". All fields are combined with a logical 'AND'. */
export type User_Transactions_Bool_Exp = {
  _and: InputMaybe<Array<User_Transactions_Bool_Exp>>;
  _not: InputMaybe<User_Transactions_Bool_Exp>;
  _or: InputMaybe<Array<User_Transactions_Bool_Exp>>;
  amount: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamp_Comparison_Exp>;
  created_by: InputMaybe<Int_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  note: InputMaybe<String_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_transactions" */
export enum User_Transactions_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserTransactionsPkey = 'user_transactions_pkey'
}

/** input type for incrementing numeric columns in table "user_transactions" */
export type User_Transactions_Inc_Input = {
  amount: InputMaybe<Scalars['Int']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_transactions" */
export type User_Transactions_Insert_Input = {
  amount: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type User_Transactions_Max_Fields = {
  __typename?: 'user_transactions_max_fields';
  amount: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type User_Transactions_Min_Fields = {
  __typename?: 'user_transactions_min_fields';
  amount: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamp']>;
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  note: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "user_transactions" */
export type User_Transactions_Mutation_Response = {
  __typename?: 'user_transactions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Transactions>;
};

/** on_conflict condition type for table "user_transactions" */
export type User_Transactions_On_Conflict = {
  constraint: User_Transactions_Constraint;
  update_columns: Array<User_Transactions_Update_Column>;
  where: InputMaybe<User_Transactions_Bool_Exp>;
};

/** Ordering options when selecting data from "user_transactions". */
export type User_Transactions_Order_By = {
  amount: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  created_by: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  note: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_transactions */
export type User_Transactions_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_transactions" */
export enum User_Transactions_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_transactions" */
export type User_Transactions_Set_Input = {
  amount: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type User_Transactions_Stddev_Fields = {
  __typename?: 'user_transactions_stddev_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Transactions_Stddev_Pop_Fields = {
  __typename?: 'user_transactions_stddev_pop_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Transactions_Stddev_Samp_Fields = {
  __typename?: 'user_transactions_stddev_samp_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_transactions" */
export type User_Transactions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Transactions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Transactions_Stream_Cursor_Value_Input = {
  amount: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamp']>;
  created_by: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  note: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type User_Transactions_Sum_Fields = {
  __typename?: 'user_transactions_sum_fields';
  amount: Maybe<Scalars['Int']>;
  created_by: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "user_transactions" */
export enum User_Transactions_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UserId = 'user_id'
}

export type User_Transactions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<User_Transactions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<User_Transactions_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Transactions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Transactions_Var_Pop_Fields = {
  __typename?: 'user_transactions_var_pop_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Transactions_Var_Samp_Fields = {
  __typename?: 'user_transactions_var_samp_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Transactions_Variance_Fields = {
  __typename?: 'user_transactions_variance_fields';
  amount: Maybe<Scalars['Float']>;
  created_by: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  active: Scalars['Boolean'];
  additional_emails: Scalars['jsonb'];
  auth0_linkedin_id: Maybe<Scalars['String']>;
  auth0_user_pass_id: Maybe<Scalars['String']>;
  /** An object relationship */
  billing_org: Maybe<Billing_Org>;
  billing_org_id: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamptz'];
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  feature_flags: Scalars['jsonb'];
  id: Scalars['Int'];
  is_auth0_verified: Maybe<Scalars['Boolean']>;
  last_transaction_expiration: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  list_members: Array<List_Members>;
  /** An aggregate relationship */
  list_members_aggregate: List_Members_Aggregate;
  onboarding_information: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  organization_companies: Array<Companies_Edit_Access>;
  /** An aggregate relationship */
  organization_companies_aggregate: Companies_Edit_Access_Aggregate;
  /** An array relationship */
  organization_vc_firms: Array<Vc_Firms_Edit_Access>;
  /** An aggregate relationship */
  organization_vc_firms_aggregate: Vc_Firms_Edit_Access_Aggregate;
  /** An object relationship */
  person: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  preferences: Scalars['jsonb'];
  reference_id: Scalars['String'];
  reference_user_id: Maybe<Scalars['Int']>;
  role: Maybe<Scalars['String']>;
  use_credits_system: Scalars['Boolean'];
};


/** columns and relationships of "users" */
export type UsersAdditional_EmailsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersFeature_FlagsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersList_MembersArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersList_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersOnboarding_InformationArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "users" */
export type UsersOrganization_CompaniesArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersOrganization_Companies_AggregateArgs = {
  distinct_on: InputMaybe<Array<Companies_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Companies_Edit_Access_Order_By>>;
  where: InputMaybe<Companies_Edit_Access_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersOrganization_Vc_FirmsArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersOrganization_Vc_Firms_AggregateArgs = {
  distinct_on: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Vc_Firms_Edit_Access_Order_By>>;
  where: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersPreferencesArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  avg: Maybe<Users_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Users_Max_Fields>;
  min: Maybe<Users_Min_Fields>;
  stddev: Maybe<Users_Stddev_Fields>;
  stddev_pop: Maybe<Users_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Users_Stddev_Samp_Fields>;
  sum: Maybe<Users_Sum_Fields>;
  var_pop: Maybe<Users_Var_Pop_Fields>;
  var_samp: Maybe<Users_Var_Samp_Fields>;
  variance: Maybe<Users_Variance_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Users_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Users_Append_Input = {
  additional_emails: InputMaybe<Scalars['jsonb']>;
  feature_flags: InputMaybe<Scalars['jsonb']>;
  onboarding_information: InputMaybe<Scalars['jsonb']>;
  preferences: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Users_Avg_Fields = {
  __typename?: 'users_avg_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and: InputMaybe<Array<Users_Bool_Exp>>;
  _not: InputMaybe<Users_Bool_Exp>;
  _or: InputMaybe<Array<Users_Bool_Exp>>;
  active: InputMaybe<Boolean_Comparison_Exp>;
  additional_emails: InputMaybe<Jsonb_Comparison_Exp>;
  auth0_linkedin_id: InputMaybe<String_Comparison_Exp>;
  auth0_user_pass_id: InputMaybe<String_Comparison_Exp>;
  billing_org: InputMaybe<Billing_Org_Bool_Exp>;
  billing_org_id: InputMaybe<Int_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  credits: InputMaybe<Numeric_Comparison_Exp>;
  display_name: InputMaybe<String_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  feature_flags: InputMaybe<Jsonb_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  is_auth0_verified: InputMaybe<Boolean_Comparison_Exp>;
  last_transaction_expiration: InputMaybe<Timestamptz_Comparison_Exp>;
  list_members: InputMaybe<List_Members_Bool_Exp>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Bool_Exp>;
  onboarding_information: InputMaybe<Jsonb_Comparison_Exp>;
  organization_companies: InputMaybe<Companies_Edit_Access_Bool_Exp>;
  organization_companies_aggregate: InputMaybe<Companies_Edit_Access_Aggregate_Bool_Exp>;
  organization_vc_firms: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
  organization_vc_firms_aggregate: InputMaybe<Vc_Firms_Edit_Access_Aggregate_Bool_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  preferences: InputMaybe<Jsonb_Comparison_Exp>;
  reference_id: InputMaybe<String_Comparison_Exp>;
  reference_user_id: InputMaybe<Int_Comparison_Exp>;
  role: InputMaybe<String_Comparison_Exp>;
  use_credits_system: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "person_id" */
  UsersPersonIdKey = 'users_person_id_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Users_Delete_At_Path_Input = {
  additional_emails: InputMaybe<Array<Scalars['String']>>;
  feature_flags: InputMaybe<Array<Scalars['String']>>;
  onboarding_information: InputMaybe<Array<Scalars['String']>>;
  preferences: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Users_Delete_Elem_Input = {
  additional_emails: InputMaybe<Scalars['Int']>;
  feature_flags: InputMaybe<Scalars['Int']>;
  onboarding_information: InputMaybe<Scalars['Int']>;
  preferences: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Users_Delete_Key_Input = {
  additional_emails: InputMaybe<Scalars['String']>;
  feature_flags: InputMaybe<Scalars['String']>;
  onboarding_information: InputMaybe<Scalars['String']>;
  preferences: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "users" */
export type Users_Inc_Input = {
  billing_org_id: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
  reference_user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  active: InputMaybe<Scalars['Boolean']>;
  additional_emails: InputMaybe<Scalars['jsonb']>;
  auth0_linkedin_id: InputMaybe<Scalars['String']>;
  auth0_user_pass_id: InputMaybe<Scalars['String']>;
  billing_org: InputMaybe<Billing_Org_Obj_Rel_Insert_Input>;
  billing_org_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  feature_flags: InputMaybe<Scalars['jsonb']>;
  id: InputMaybe<Scalars['Int']>;
  is_auth0_verified: InputMaybe<Scalars['Boolean']>;
  last_transaction_expiration: InputMaybe<Scalars['timestamptz']>;
  list_members: InputMaybe<List_Members_Arr_Rel_Insert_Input>;
  onboarding_information: InputMaybe<Scalars['jsonb']>;
  organization_companies: InputMaybe<Companies_Edit_Access_Arr_Rel_Insert_Input>;
  organization_vc_firms: InputMaybe<Vc_Firms_Edit_Access_Arr_Rel_Insert_Input>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  preferences: InputMaybe<Scalars['jsonb']>;
  reference_id: InputMaybe<Scalars['String']>;
  reference_user_id: InputMaybe<Scalars['Int']>;
  role: InputMaybe<Scalars['String']>;
  use_credits_system: InputMaybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  auth0_linkedin_id: Maybe<Scalars['String']>;
  auth0_user_pass_id: Maybe<Scalars['String']>;
  billing_org_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  last_transaction_expiration: Maybe<Scalars['timestamptz']>;
  person_id: Maybe<Scalars['Int']>;
  reference_id: Maybe<Scalars['String']>;
  reference_user_id: Maybe<Scalars['Int']>;
  role: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  auth0_linkedin_id: Maybe<Scalars['String']>;
  auth0_user_pass_id: Maybe<Scalars['String']>;
  billing_org_id: Maybe<Scalars['Int']>;
  created_at: Maybe<Scalars['timestamptz']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  external_id: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  last_transaction_expiration: Maybe<Scalars['timestamptz']>;
  person_id: Maybe<Scalars['Int']>;
  reference_id: Maybe<Scalars['String']>;
  reference_user_id: Maybe<Scalars['Int']>;
  role: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns: Array<Users_Update_Column>;
  where: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  active: InputMaybe<Order_By>;
  additional_emails: InputMaybe<Order_By>;
  auth0_linkedin_id: InputMaybe<Order_By>;
  auth0_user_pass_id: InputMaybe<Order_By>;
  billing_org: InputMaybe<Billing_Org_Order_By>;
  billing_org_id: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  credits: InputMaybe<Order_By>;
  display_name: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  feature_flags: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  is_auth0_verified: InputMaybe<Order_By>;
  last_transaction_expiration: InputMaybe<Order_By>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Order_By>;
  onboarding_information: InputMaybe<Order_By>;
  organization_companies_aggregate: InputMaybe<Companies_Edit_Access_Aggregate_Order_By>;
  organization_vc_firms_aggregate: InputMaybe<Vc_Firms_Edit_Access_Aggregate_Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  preferences: InputMaybe<Order_By>;
  reference_id: InputMaybe<Order_By>;
  reference_user_id: InputMaybe<Order_By>;
  role: InputMaybe<Order_By>;
  use_credits_system: InputMaybe<Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Users_Prepend_Input = {
  additional_emails: InputMaybe<Scalars['jsonb']>;
  feature_flags: InputMaybe<Scalars['jsonb']>;
  onboarding_information: InputMaybe<Scalars['jsonb']>;
  preferences: InputMaybe<Scalars['jsonb']>;
};

/** columns and relationships of "users_public" */
export type Users_Public = {
  __typename?: 'users_public';
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  /** An array relationship */
  list_members: Array<List_Members>;
  /** An aggregate relationship */
  list_members_aggregate: List_Members_Aggregate;
  /** An object relationship */
  person: Maybe<People>;
  person_id: Maybe<Scalars['Int']>;
  /** An array relationship */
  user_group_members: Array<User_Group_Members>;
  /** An aggregate relationship */
  user_group_members_aggregate: User_Group_Members_Aggregate;
};


/** columns and relationships of "users_public" */
export type Users_PublicList_MembersArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "users_public" */
export type Users_PublicList_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<List_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<List_Members_Order_By>>;
  where: InputMaybe<List_Members_Bool_Exp>;
};


/** columns and relationships of "users_public" */
export type Users_PublicUser_Group_MembersArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};


/** columns and relationships of "users_public" */
export type Users_PublicUser_Group_Members_AggregateArgs = {
  distinct_on: InputMaybe<Array<User_Group_Members_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<User_Group_Members_Order_By>>;
  where: InputMaybe<User_Group_Members_Bool_Exp>;
};

/** aggregated selection of "users_public" */
export type Users_Public_Aggregate = {
  __typename?: 'users_public_aggregate';
  aggregate: Maybe<Users_Public_Aggregate_Fields>;
  nodes: Array<Users_Public>;
};

/** aggregate fields of "users_public" */
export type Users_Public_Aggregate_Fields = {
  __typename?: 'users_public_aggregate_fields';
  avg: Maybe<Users_Public_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Users_Public_Max_Fields>;
  min: Maybe<Users_Public_Min_Fields>;
  stddev: Maybe<Users_Public_Stddev_Fields>;
  stddev_pop: Maybe<Users_Public_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Users_Public_Stddev_Samp_Fields>;
  sum: Maybe<Users_Public_Sum_Fields>;
  var_pop: Maybe<Users_Public_Var_Pop_Fields>;
  var_samp: Maybe<Users_Public_Var_Samp_Fields>;
  variance: Maybe<Users_Public_Variance_Fields>;
};


/** aggregate fields of "users_public" */
export type Users_Public_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Users_Public_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Users_Public_Avg_Fields = {
  __typename?: 'users_public_avg_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "users_public". All fields are combined with a logical 'AND'. */
export type Users_Public_Bool_Exp = {
  _and: InputMaybe<Array<Users_Public_Bool_Exp>>;
  _not: InputMaybe<Users_Public_Bool_Exp>;
  _or: InputMaybe<Array<Users_Public_Bool_Exp>>;
  display_name: InputMaybe<String_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  list_members: InputMaybe<List_Members_Bool_Exp>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Bool_Exp>;
  person: InputMaybe<People_Bool_Exp>;
  person_id: InputMaybe<Int_Comparison_Exp>;
  user_group_members: InputMaybe<User_Group_Members_Bool_Exp>;
  user_group_members_aggregate: InputMaybe<User_Group_Members_Aggregate_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "users_public" */
export type Users_Public_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "users_public" */
export type Users_Public_Insert_Input = {
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  list_members: InputMaybe<List_Members_Arr_Rel_Insert_Input>;
  person: InputMaybe<People_Obj_Rel_Insert_Input>;
  person_id: InputMaybe<Scalars['Int']>;
  user_group_members: InputMaybe<User_Group_Members_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Public_Max_Fields = {
  __typename?: 'users_public_max_fields';
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Users_Public_Min_Fields = {
  __typename?: 'users_public_min_fields';
  display_name: Maybe<Scalars['String']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "users_public" */
export type Users_Public_Mutation_Response = {
  __typename?: 'users_public_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users_Public>;
};

/** input type for inserting object relation for remote table "users_public" */
export type Users_Public_Obj_Rel_Insert_Input = {
  data: Users_Public_Insert_Input;
};

/** Ordering options when selecting data from "users_public". */
export type Users_Public_Order_By = {
  display_name: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  list_members_aggregate: InputMaybe<List_Members_Aggregate_Order_By>;
  person: InputMaybe<People_Order_By>;
  person_id: InputMaybe<Order_By>;
  user_group_members_aggregate: InputMaybe<User_Group_Members_Aggregate_Order_By>;
};

/** select columns of table "users_public" */
export enum Users_Public_Select_Column {
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'person_id'
}

/** input type for updating data in table "users_public" */
export type Users_Public_Set_Input = {
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Users_Public_Stddev_Fields = {
  __typename?: 'users_public_stddev_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Users_Public_Stddev_Pop_Fields = {
  __typename?: 'users_public_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Users_Public_Stddev_Samp_Fields = {
  __typename?: 'users_public_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "users_public" */
export type Users_Public_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Public_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Public_Stream_Cursor_Value_Input = {
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  person_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Users_Public_Sum_Fields = {
  __typename?: 'users_public_sum_fields';
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
};

export type Users_Public_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Users_Public_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Users_Public_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Public_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Users_Public_Var_Pop_Fields = {
  __typename?: 'users_public_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Users_Public_Var_Samp_Fields = {
  __typename?: 'users_public_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Users_Public_Variance_Fields = {
  __typename?: 'users_public_variance_fields';
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AdditionalEmails = 'additional_emails',
  /** column name */
  Auth0LinkedinId = 'auth0_linkedin_id',
  /** column name */
  Auth0UserPassId = 'auth0_user_pass_id',
  /** column name */
  BillingOrgId = 'billing_org_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  FeatureFlags = 'feature_flags',
  /** column name */
  Id = 'id',
  /** column name */
  IsAuth0Verified = 'is_auth0_verified',
  /** column name */
  LastTransactionExpiration = 'last_transaction_expiration',
  /** column name */
  OnboardingInformation = 'onboarding_information',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  ReferenceId = 'reference_id',
  /** column name */
  ReferenceUserId = 'reference_user_id',
  /** column name */
  Role = 'role',
  /** column name */
  UseCreditsSystem = 'use_credits_system'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  active: InputMaybe<Scalars['Boolean']>;
  additional_emails: InputMaybe<Scalars['jsonb']>;
  auth0_linkedin_id: InputMaybe<Scalars['String']>;
  auth0_user_pass_id: InputMaybe<Scalars['String']>;
  billing_org_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  feature_flags: InputMaybe<Scalars['jsonb']>;
  id: InputMaybe<Scalars['Int']>;
  is_auth0_verified: InputMaybe<Scalars['Boolean']>;
  last_transaction_expiration: InputMaybe<Scalars['timestamptz']>;
  onboarding_information: InputMaybe<Scalars['jsonb']>;
  person_id: InputMaybe<Scalars['Int']>;
  preferences: InputMaybe<Scalars['jsonb']>;
  reference_id: InputMaybe<Scalars['String']>;
  reference_user_id: InputMaybe<Scalars['Int']>;
  role: InputMaybe<Scalars['String']>;
  use_credits_system: InputMaybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type Users_Stddev_Fields = {
  __typename?: 'users_stddev_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Users_Stddev_Pop_Fields = {
  __typename?: 'users_stddev_pop_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Users_Stddev_Samp_Fields = {
  __typename?: 'users_stddev_samp_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  active: InputMaybe<Scalars['Boolean']>;
  additional_emails: InputMaybe<Scalars['jsonb']>;
  auth0_linkedin_id: InputMaybe<Scalars['String']>;
  auth0_user_pass_id: InputMaybe<Scalars['String']>;
  billing_org_id: InputMaybe<Scalars['Int']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  display_name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  external_id: InputMaybe<Scalars['String']>;
  feature_flags: InputMaybe<Scalars['jsonb']>;
  id: InputMaybe<Scalars['Int']>;
  is_auth0_verified: InputMaybe<Scalars['Boolean']>;
  last_transaction_expiration: InputMaybe<Scalars['timestamptz']>;
  onboarding_information: InputMaybe<Scalars['jsonb']>;
  person_id: InputMaybe<Scalars['Int']>;
  preferences: InputMaybe<Scalars['jsonb']>;
  reference_id: InputMaybe<Scalars['String']>;
  reference_user_id: InputMaybe<Scalars['Int']>;
  role: InputMaybe<Scalars['String']>;
  use_credits_system: InputMaybe<Scalars['Boolean']>;
};

/** aggregate sum on columns */
export type Users_Sum_Fields = {
  __typename?: 'users_sum_fields';
  billing_org_id: Maybe<Scalars['Int']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Int']>;
  person_id: Maybe<Scalars['Int']>;
  reference_user_id: Maybe<Scalars['Int']>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AdditionalEmails = 'additional_emails',
  /** column name */
  Auth0LinkedinId = 'auth0_linkedin_id',
  /** column name */
  Auth0UserPassId = 'auth0_user_pass_id',
  /** column name */
  BillingOrgId = 'billing_org_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  FeatureFlags = 'feature_flags',
  /** column name */
  Id = 'id',
  /** column name */
  IsAuth0Verified = 'is_auth0_verified',
  /** column name */
  LastTransactionExpiration = 'last_transaction_expiration',
  /** column name */
  OnboardingInformation = 'onboarding_information',
  /** column name */
  PersonId = 'person_id',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  ReferenceId = 'reference_id',
  /** column name */
  ReferenceUserId = 'reference_user_id',
  /** column name */
  Role = 'role',
  /** column name */
  UseCreditsSystem = 'use_credits_system'
}

export type Users_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Users_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Users_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Users_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Users_Var_Pop_Fields = {
  __typename?: 'users_var_pop_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Users_Var_Samp_Fields = {
  __typename?: 'users_var_samp_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Users_Variance_Fields = {
  __typename?: 'users_variance_fields';
  billing_org_id: Maybe<Scalars['Float']>;
  /** A computed field, executes function "user_credits" */
  credits: Maybe<Scalars['numeric']>;
  id: Maybe<Scalars['Float']>;
  person_id: Maybe<Scalars['Float']>;
  reference_user_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "vc_firms" */
export type Vc_Firms = {
  __typename?: 'vc_firms';
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Scalars['Int'];
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Scalars['Int'];
  external_id: Maybe<Scalars['String']>;
  /** An array relationship */
  follows: Array<Follows_Vc_Firms>;
  /** An aggregate relationship */
  follows_aggregate: Follows_Vc_Firms_Aggregate;
  /** An array relationship */
  from_links: Array<Resource_Links>;
  /** An aggregate relationship */
  from_links_aggregate: Resource_Links_Aggregate;
  geopoint: Maybe<Scalars['geography']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  investment_amount_total: Maybe<Scalars['bigint']>;
  /** An array relationship */
  investments: Array<Investments>;
  /** An aggregate relationship */
  investments_aggregate: Investments_Aggregate;
  /** An array relationship */
  investors: Array<Investors>;
  /** An aggregate relationship */
  investors_aggregate: Investors_Aggregate;
  latest_investment: Maybe<Scalars['date']>;
  latitude: Maybe<Scalars['float8']>;
  library: Maybe<Scalars['jsonb']>;
  linkedin: Maybe<Scalars['String']>;
  location_json: Maybe<Scalars['jsonb']>;
  logo: Maybe<Scalars['jsonb']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  /** An array relationship */
  news_links: Array<News_Organizations>;
  /** An aggregate relationship */
  news_links_aggregate: News_Organizations_Aggregate;
  num_of_exits: Maybe<Scalars['Int']>;
  num_of_investments: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  sentiment: Maybe<Scalars['jsonb']>;
  slug: Scalars['String'];
  status: Scalars['String'];
  status_tags: Maybe<Scalars['jsonb']>;
  tags: Maybe<Scalars['jsonb']>;
  team_size: Maybe<Scalars['Int']>;
  telegram: Maybe<Scalars['String']>;
  /** An array relationship */
  to_links: Array<Resource_Links>;
  /** An aggregate relationship */
  to_links_aggregate: Resource_Links_Aggregate;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  web3_address: Maybe<Scalars['jsonb']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsFollowsArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsFollows_AggregateArgs = {
  distinct_on: InputMaybe<Array<Follows_Vc_Firms_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Follows_Vc_Firms_Order_By>>;
  where: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsFrom_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsFrom_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsInvestmentsArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsInvestments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investments_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investments_Order_By>>;
  where: InputMaybe<Investments_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsInvestorsArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsInvestors_AggregateArgs = {
  distinct_on: InputMaybe<Array<Investors_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Investors_Order_By>>;
  where: InputMaybe<Investors_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsLibraryArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsLocation_JsonArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsLogoArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsNews_LinksArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsNews_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<News_Organizations_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<News_Organizations_Order_By>>;
  where: InputMaybe<News_Organizations_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsSentimentArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsStatus_TagsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsTagsArgs = {
  path: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsTo_LinksArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsTo_Links_AggregateArgs = {
  distinct_on: InputMaybe<Array<Resource_Links_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Resource_Links_Order_By>>;
  where: InputMaybe<Resource_Links_Bool_Exp>;
};


/** columns and relationships of "vc_firms" */
export type Vc_FirmsWeb3_AddressArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "vc_firms" */
export type Vc_Firms_Aggregate = {
  __typename?: 'vc_firms_aggregate';
  aggregate: Maybe<Vc_Firms_Aggregate_Fields>;
  nodes: Array<Vc_Firms>;
};

/** aggregate fields of "vc_firms" */
export type Vc_Firms_Aggregate_Fields = {
  __typename?: 'vc_firms_aggregate_fields';
  avg: Maybe<Vc_Firms_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Vc_Firms_Max_Fields>;
  min: Maybe<Vc_Firms_Min_Fields>;
  stddev: Maybe<Vc_Firms_Stddev_Fields>;
  stddev_pop: Maybe<Vc_Firms_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Vc_Firms_Stddev_Samp_Fields>;
  sum: Maybe<Vc_Firms_Sum_Fields>;
  var_pop: Maybe<Vc_Firms_Var_Pop_Fields>;
  var_samp: Maybe<Vc_Firms_Var_Samp_Fields>;
  variance: Maybe<Vc_Firms_Variance_Fields>;
};


/** aggregate fields of "vc_firms" */
export type Vc_Firms_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Vc_Firms_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Vc_Firms_Append_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Vc_Firms_Avg_Fields = {
  __typename?: 'vc_firms_avg_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "vc_firms". All fields are combined with a logical 'AND'. */
export type Vc_Firms_Bool_Exp = {
  _and: InputMaybe<Array<Vc_Firms_Bool_Exp>>;
  _not: InputMaybe<Vc_Firms_Bool_Exp>;
  _or: InputMaybe<Array<Vc_Firms_Bool_Exp>>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  data_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  datapoints_count: InputMaybe<Int_Comparison_Exp>;
  discord: InputMaybe<String_Comparison_Exp>;
  domain_enriched_at: InputMaybe<Timestamptz_Comparison_Exp>;
  email_domain: InputMaybe<String_Comparison_Exp>;
  enrichment_priority: InputMaybe<Int_Comparison_Exp>;
  external_id: InputMaybe<String_Comparison_Exp>;
  follows: InputMaybe<Follows_Vc_Firms_Bool_Exp>;
  follows_aggregate: InputMaybe<Follows_Vc_Firms_Aggregate_Bool_Exp>;
  from_links: InputMaybe<Resource_Links_Bool_Exp>;
  from_links_aggregate: InputMaybe<Resource_Links_Aggregate_Bool_Exp>;
  geopoint: InputMaybe<Geography_Comparison_Exp>;
  github: InputMaybe<String_Comparison_Exp>;
  glassdoor: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  investment_amount_total: InputMaybe<Bigint_Comparison_Exp>;
  investments: InputMaybe<Investments_Bool_Exp>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Bool_Exp>;
  investors: InputMaybe<Investors_Bool_Exp>;
  investors_aggregate: InputMaybe<Investors_Aggregate_Bool_Exp>;
  latest_investment: InputMaybe<Date_Comparison_Exp>;
  latitude: InputMaybe<Float8_Comparison_Exp>;
  library: InputMaybe<Jsonb_Comparison_Exp>;
  linkedin: InputMaybe<String_Comparison_Exp>;
  location_json: InputMaybe<Jsonb_Comparison_Exp>;
  logo: InputMaybe<Jsonb_Comparison_Exp>;
  longitude: InputMaybe<Float8_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  news_links: InputMaybe<News_Organizations_Bool_Exp>;
  news_links_aggregate: InputMaybe<News_Organizations_Aggregate_Bool_Exp>;
  num_of_exits: InputMaybe<Int_Comparison_Exp>;
  num_of_investments: InputMaybe<Int_Comparison_Exp>;
  num_of_views: InputMaybe<Int_Comparison_Exp>;
  overview: InputMaybe<String_Comparison_Exp>;
  sentiment: InputMaybe<Jsonb_Comparison_Exp>;
  slug: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<String_Comparison_Exp>;
  status_tags: InputMaybe<Jsonb_Comparison_Exp>;
  tags: InputMaybe<Jsonb_Comparison_Exp>;
  team_size: InputMaybe<Int_Comparison_Exp>;
  telegram: InputMaybe<String_Comparison_Exp>;
  to_links: InputMaybe<Resource_Links_Bool_Exp>;
  to_links_aggregate: InputMaybe<Resource_Links_Aggregate_Bool_Exp>;
  twitter: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  web3_address: InputMaybe<Jsonb_Comparison_Exp>;
  web_domain: InputMaybe<String_Comparison_Exp>;
  website: InputMaybe<String_Comparison_Exp>;
  year_founded: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "vc_firms" */
export enum Vc_Firms_Constraint {
  /** unique or primary key constraint on columns "external_id" */
  VcFirmsExternalIdKey = 'vc_firms_external_id_key',
  /** unique or primary key constraint on columns "id" */
  VcFirmsPkey = 'vc_firms_pkey',
  /** unique or primary key constraint on columns "slug" */
  VcFirmsSlugIdx = 'vc_firms_slug_idx',
  /** unique or primary key constraint on columns "slug" */
  VcFirmsSlugKey = 'vc_firms_slug_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Vc_Firms_Delete_At_Path_Input = {
  library: InputMaybe<Array<Scalars['String']>>;
  location_json: InputMaybe<Array<Scalars['String']>>;
  logo: InputMaybe<Array<Scalars['String']>>;
  sentiment: InputMaybe<Array<Scalars['String']>>;
  status_tags: InputMaybe<Array<Scalars['String']>>;
  tags: InputMaybe<Array<Scalars['String']>>;
  web3_address: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Vc_Firms_Delete_Elem_Input = {
  library: InputMaybe<Scalars['Int']>;
  location_json: InputMaybe<Scalars['Int']>;
  logo: InputMaybe<Scalars['Int']>;
  sentiment: InputMaybe<Scalars['Int']>;
  status_tags: InputMaybe<Scalars['Int']>;
  tags: InputMaybe<Scalars['Int']>;
  web3_address: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Vc_Firms_Delete_Key_Input = {
  library: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['String']>;
  logo: InputMaybe<Scalars['String']>;
  sentiment: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['String']>;
  tags: InputMaybe<Scalars['String']>;
  web3_address: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access = {
  __typename?: 'vc_firms_edit_access';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
  /** An object relationship */
  vc_firm: Maybe<Vc_Firms>;
};

/** aggregated selection of "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Aggregate = {
  __typename?: 'vc_firms_edit_access_aggregate';
  aggregate: Maybe<Vc_Firms_Edit_Access_Aggregate_Fields>;
  nodes: Array<Vc_Firms_Edit_Access>;
};

export type Vc_Firms_Edit_Access_Aggregate_Bool_Exp = {
  count: InputMaybe<Vc_Firms_Edit_Access_Aggregate_Bool_Exp_Count>;
};

export type Vc_Firms_Edit_Access_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Aggregate_Fields = {
  __typename?: 'vc_firms_edit_access_aggregate_fields';
  avg: Maybe<Vc_Firms_Edit_Access_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Vc_Firms_Edit_Access_Max_Fields>;
  min: Maybe<Vc_Firms_Edit_Access_Min_Fields>;
  stddev: Maybe<Vc_Firms_Edit_Access_Stddev_Fields>;
  stddev_pop: Maybe<Vc_Firms_Edit_Access_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Vc_Firms_Edit_Access_Stddev_Samp_Fields>;
  sum: Maybe<Vc_Firms_Edit_Access_Sum_Fields>;
  var_pop: Maybe<Vc_Firms_Edit_Access_Var_Pop_Fields>;
  var_samp: Maybe<Vc_Firms_Edit_Access_Var_Samp_Fields>;
  variance: Maybe<Vc_Firms_Edit_Access_Variance_Fields>;
};


/** aggregate fields of "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Vc_Firms_Edit_Access_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Aggregate_Order_By = {
  avg: InputMaybe<Vc_Firms_Edit_Access_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Vc_Firms_Edit_Access_Max_Order_By>;
  min: InputMaybe<Vc_Firms_Edit_Access_Min_Order_By>;
  stddev: InputMaybe<Vc_Firms_Edit_Access_Stddev_Order_By>;
  stddev_pop: InputMaybe<Vc_Firms_Edit_Access_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Vc_Firms_Edit_Access_Stddev_Samp_Order_By>;
  sum: InputMaybe<Vc_Firms_Edit_Access_Sum_Order_By>;
  var_pop: InputMaybe<Vc_Firms_Edit_Access_Var_Pop_Order_By>;
  var_samp: InputMaybe<Vc_Firms_Edit_Access_Var_Samp_Order_By>;
  variance: InputMaybe<Vc_Firms_Edit_Access_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Arr_Rel_Insert_Input = {
  data: Array<Vc_Firms_Edit_Access_Insert_Input>;
};

/** aggregate avg on columns */
export type Vc_Firms_Edit_Access_Avg_Fields = {
  __typename?: 'vc_firms_edit_access_avg_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Avg_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "vc_firms_edit_access". All fields are combined with a logical 'AND'. */
export type Vc_Firms_Edit_Access_Bool_Exp = {
  _and: InputMaybe<Array<Vc_Firms_Edit_Access_Bool_Exp>>;
  _not: InputMaybe<Vc_Firms_Edit_Access_Bool_Exp>;
  _or: InputMaybe<Array<Vc_Firms_Edit_Access_Bool_Exp>>;
  id: InputMaybe<Int_Comparison_Exp>;
  resource_id: InputMaybe<Int_Comparison_Exp>;
  resource_type: InputMaybe<String_Comparison_Exp>;
  user_id: InputMaybe<Int_Comparison_Exp>;
  vc_firm: InputMaybe<Vc_Firms_Bool_Exp>;
};

/** input type for incrementing numeric columns in table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Insert_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
  vc_firm: InputMaybe<Vc_Firms_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Vc_Firms_Edit_Access_Max_Fields = {
  __typename?: 'vc_firms_edit_access_max_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Max_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Vc_Firms_Edit_Access_Min_Fields = {
  __typename?: 'vc_firms_edit_access_min_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  resource_type: Maybe<Scalars['String']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Min_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Mutation_Response = {
  __typename?: 'vc_firms_edit_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vc_Firms_Edit_Access>;
};

/** Ordering options when selecting data from "vc_firms_edit_access". */
export type Vc_Firms_Edit_Access_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  resource_type: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
  vc_firm: InputMaybe<Vc_Firms_Order_By>;
};

/** select columns of table "vc_firms_edit_access" */
export enum Vc_Firms_Edit_Access_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  ResourceType = 'resource_type',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Set_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Vc_Firms_Edit_Access_Stddev_Fields = {
  __typename?: 'vc_firms_edit_access_stddev_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Stddev_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Vc_Firms_Edit_Access_Stddev_Pop_Fields = {
  __typename?: 'vc_firms_edit_access_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Stddev_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Vc_Firms_Edit_Access_Stddev_Samp_Fields = {
  __typename?: 'vc_firms_edit_access_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Stddev_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vc_Firms_Edit_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vc_Firms_Edit_Access_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['Int']>;
  resource_id: InputMaybe<Scalars['Int']>;
  resource_type: InputMaybe<Scalars['String']>;
  user_id: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Vc_Firms_Edit_Access_Sum_Fields = {
  __typename?: 'vc_firms_edit_access_sum_fields';
  id: Maybe<Scalars['Int']>;
  resource_id: Maybe<Scalars['Int']>;
  user_id: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Sum_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

export type Vc_Firms_Edit_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Vc_Firms_Edit_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Vc_Firms_Edit_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vc_Firms_Edit_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vc_Firms_Edit_Access_Var_Pop_Fields = {
  __typename?: 'vc_firms_edit_access_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Var_Pop_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Vc_Firms_Edit_Access_Var_Samp_Fields = {
  __typename?: 'vc_firms_edit_access_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Var_Samp_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Vc_Firms_Edit_Access_Variance_Fields = {
  __typename?: 'vc_firms_edit_access_variance_fields';
  id: Maybe<Scalars['Float']>;
  resource_id: Maybe<Scalars['Float']>;
  user_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "vc_firms_edit_access" */
export type Vc_Firms_Edit_Access_Variance_Order_By = {
  id: InputMaybe<Order_By>;
  resource_id: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** input type for incrementing numeric columns in table "vc_firms" */
export type Vc_Firms_Inc_Input = {
  datapoints_count: InputMaybe<Scalars['Int']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  id: InputMaybe<Scalars['Int']>;
  investment_amount_total: InputMaybe<Scalars['bigint']>;
  latitude: InputMaybe<Scalars['float8']>;
  longitude: InputMaybe<Scalars['float8']>;
  num_of_exits: InputMaybe<Scalars['Int']>;
  num_of_investments: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  team_size: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "vc_firms" */
export type Vc_Firms_Insert_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  follows: InputMaybe<Follows_Vc_Firms_Arr_Rel_Insert_Input>;
  from_links: InputMaybe<Resource_Links_Arr_Rel_Insert_Input>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investment_amount_total: InputMaybe<Scalars['bigint']>;
  investments: InputMaybe<Investments_Arr_Rel_Insert_Input>;
  investors: InputMaybe<Investors_Arr_Rel_Insert_Input>;
  latest_investment: InputMaybe<Scalars['date']>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  news_links: InputMaybe<News_Organizations_Arr_Rel_Insert_Input>;
  num_of_exits: InputMaybe<Scalars['Int']>;
  num_of_investments: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  team_size: InputMaybe<Scalars['Int']>;
  telegram: InputMaybe<Scalars['String']>;
  to_links: InputMaybe<Resource_Links_Arr_Rel_Insert_Input>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Vc_Firms_Max_Fields = {
  __typename?: 'vc_firms_max_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Maybe<Scalars['Int']>;
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  investment_amount_total: Maybe<Scalars['bigint']>;
  latest_investment: Maybe<Scalars['date']>;
  latitude: Maybe<Scalars['float8']>;
  linkedin: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  num_of_exits: Maybe<Scalars['Int']>;
  num_of_investments: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  team_size: Maybe<Scalars['Int']>;
  telegram: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Vc_Firms_Min_Fields = {
  __typename?: 'vc_firms_min_fields';
  created_at: Maybe<Scalars['timestamptz']>;
  data_enriched_at: Maybe<Scalars['timestamptz']>;
  datapoints_count: Maybe<Scalars['Int']>;
  discord: Maybe<Scalars['String']>;
  domain_enriched_at: Maybe<Scalars['timestamptz']>;
  email_domain: Maybe<Scalars['String']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  external_id: Maybe<Scalars['String']>;
  github: Maybe<Scalars['String']>;
  glassdoor: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  investment_amount_total: Maybe<Scalars['bigint']>;
  latest_investment: Maybe<Scalars['date']>;
  latitude: Maybe<Scalars['float8']>;
  linkedin: Maybe<Scalars['String']>;
  longitude: Maybe<Scalars['float8']>;
  name: Maybe<Scalars['String']>;
  num_of_exits: Maybe<Scalars['Int']>;
  num_of_investments: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
  overview: Maybe<Scalars['String']>;
  slug: Maybe<Scalars['String']>;
  status: Maybe<Scalars['String']>;
  team_size: Maybe<Scalars['Int']>;
  telegram: Maybe<Scalars['String']>;
  twitter: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  web_domain: Maybe<Scalars['String']>;
  website: Maybe<Scalars['String']>;
  year_founded: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "vc_firms" */
export type Vc_Firms_Mutation_Response = {
  __typename?: 'vc_firms_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vc_Firms>;
};

/** input type for inserting object relation for remote table "vc_firms" */
export type Vc_Firms_Obj_Rel_Insert_Input = {
  data: Vc_Firms_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Vc_Firms_On_Conflict>;
};

/** on_conflict condition type for table "vc_firms" */
export type Vc_Firms_On_Conflict = {
  constraint: Vc_Firms_Constraint;
  update_columns: Array<Vc_Firms_Update_Column>;
  where: InputMaybe<Vc_Firms_Bool_Exp>;
};

/** Ordering options when selecting data from "vc_firms". */
export type Vc_Firms_Order_By = {
  created_at: InputMaybe<Order_By>;
  data_enriched_at: InputMaybe<Order_By>;
  datapoints_count: InputMaybe<Order_By>;
  discord: InputMaybe<Order_By>;
  domain_enriched_at: InputMaybe<Order_By>;
  email_domain: InputMaybe<Order_By>;
  enrichment_priority: InputMaybe<Order_By>;
  external_id: InputMaybe<Order_By>;
  follows_aggregate: InputMaybe<Follows_Vc_Firms_Aggregate_Order_By>;
  from_links_aggregate: InputMaybe<Resource_Links_Aggregate_Order_By>;
  geopoint: InputMaybe<Order_By>;
  github: InputMaybe<Order_By>;
  glassdoor: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  investment_amount_total: InputMaybe<Order_By>;
  investments_aggregate: InputMaybe<Investments_Aggregate_Order_By>;
  investors_aggregate: InputMaybe<Investors_Aggregate_Order_By>;
  latest_investment: InputMaybe<Order_By>;
  latitude: InputMaybe<Order_By>;
  library: InputMaybe<Order_By>;
  linkedin: InputMaybe<Order_By>;
  location_json: InputMaybe<Order_By>;
  logo: InputMaybe<Order_By>;
  longitude: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  news_links_aggregate: InputMaybe<News_Organizations_Aggregate_Order_By>;
  num_of_exits: InputMaybe<Order_By>;
  num_of_investments: InputMaybe<Order_By>;
  num_of_views: InputMaybe<Order_By>;
  overview: InputMaybe<Order_By>;
  sentiment: InputMaybe<Order_By>;
  slug: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  status_tags: InputMaybe<Order_By>;
  tags: InputMaybe<Order_By>;
  team_size: InputMaybe<Order_By>;
  telegram: InputMaybe<Order_By>;
  to_links_aggregate: InputMaybe<Resource_Links_Aggregate_Order_By>;
  twitter: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  web3_address: InputMaybe<Order_By>;
  web_domain: InputMaybe<Order_By>;
  website: InputMaybe<Order_By>;
  year_founded: InputMaybe<Order_By>;
};

/** primary key columns input for table: vc_firms */
export type Vc_Firms_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Vc_Firms_Prepend_Input = {
  library: InputMaybe<Scalars['jsonb']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "vc_firms" */
export enum Vc_Firms_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  Discord = 'discord',
  /** column name */
  DomainEnrichedAt = 'domain_enriched_at',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Glassdoor = 'glassdoor',
  /** column name */
  Id = 'id',
  /** column name */
  InvestmentAmountTotal = 'investment_amount_total',
  /** column name */
  LatestInvestment = 'latest_investment',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Library = 'library',
  /** column name */
  Linkedin = 'linkedin',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Logo = 'logo',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  NumOfExits = 'num_of_exits',
  /** column name */
  NumOfInvestments = 'num_of_investments',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  Sentiment = 'sentiment',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusTags = 'status_tags',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamSize = 'team_size',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebDomain = 'web_domain',
  /** column name */
  Website = 'website',
  /** column name */
  YearFounded = 'year_founded'
}

/** input type for updating data in table "vc_firms" */
export type Vc_Firms_Set_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investment_amount_total: InputMaybe<Scalars['bigint']>;
  latest_investment: InputMaybe<Scalars['date']>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  num_of_exits: InputMaybe<Scalars['Int']>;
  num_of_investments: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  team_size: InputMaybe<Scalars['Int']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Vc_Firms_Stddev_Fields = {
  __typename?: 'vc_firms_stddev_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Vc_Firms_Stddev_Pop_Fields = {
  __typename?: 'vc_firms_stddev_pop_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Vc_Firms_Stddev_Samp_Fields = {
  __typename?: 'vc_firms_stddev_samp_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "vc_firms" */
export type Vc_Firms_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vc_Firms_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vc_Firms_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['timestamptz']>;
  data_enriched_at: InputMaybe<Scalars['timestamptz']>;
  datapoints_count: InputMaybe<Scalars['Int']>;
  discord: InputMaybe<Scalars['String']>;
  domain_enriched_at: InputMaybe<Scalars['timestamptz']>;
  email_domain: InputMaybe<Scalars['String']>;
  enrichment_priority: InputMaybe<Scalars['Int']>;
  external_id: InputMaybe<Scalars['String']>;
  geopoint: InputMaybe<Scalars['geography']>;
  github: InputMaybe<Scalars['String']>;
  glassdoor: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  investment_amount_total: InputMaybe<Scalars['bigint']>;
  latest_investment: InputMaybe<Scalars['date']>;
  latitude: InputMaybe<Scalars['float8']>;
  library: InputMaybe<Scalars['jsonb']>;
  linkedin: InputMaybe<Scalars['String']>;
  location_json: InputMaybe<Scalars['jsonb']>;
  logo: InputMaybe<Scalars['jsonb']>;
  longitude: InputMaybe<Scalars['float8']>;
  name: InputMaybe<Scalars['String']>;
  num_of_exits: InputMaybe<Scalars['Int']>;
  num_of_investments: InputMaybe<Scalars['Int']>;
  num_of_views: InputMaybe<Scalars['Int']>;
  overview: InputMaybe<Scalars['String']>;
  sentiment: InputMaybe<Scalars['jsonb']>;
  slug: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  status_tags: InputMaybe<Scalars['jsonb']>;
  tags: InputMaybe<Scalars['jsonb']>;
  team_size: InputMaybe<Scalars['Int']>;
  telegram: InputMaybe<Scalars['String']>;
  twitter: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  web3_address: InputMaybe<Scalars['jsonb']>;
  web_domain: InputMaybe<Scalars['String']>;
  website: InputMaybe<Scalars['String']>;
  year_founded: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Vc_Firms_Sum_Fields = {
  __typename?: 'vc_firms_sum_fields';
  datapoints_count: Maybe<Scalars['Int']>;
  enrichment_priority: Maybe<Scalars['Int']>;
  id: Maybe<Scalars['Int']>;
  investment_amount_total: Maybe<Scalars['bigint']>;
  latitude: Maybe<Scalars['float8']>;
  longitude: Maybe<Scalars['float8']>;
  num_of_exits: Maybe<Scalars['Int']>;
  num_of_investments: Maybe<Scalars['Int']>;
  num_of_views: Maybe<Scalars['Int']>;
  team_size: Maybe<Scalars['Int']>;
};

/** update columns of table "vc_firms" */
export enum Vc_Firms_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataEnrichedAt = 'data_enriched_at',
  /** column name */
  DatapointsCount = 'datapoints_count',
  /** column name */
  Discord = 'discord',
  /** column name */
  DomainEnrichedAt = 'domain_enriched_at',
  /** column name */
  EmailDomain = 'email_domain',
  /** column name */
  EnrichmentPriority = 'enrichment_priority',
  /** column name */
  ExternalId = 'external_id',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Github = 'github',
  /** column name */
  Glassdoor = 'glassdoor',
  /** column name */
  Id = 'id',
  /** column name */
  InvestmentAmountTotal = 'investment_amount_total',
  /** column name */
  LatestInvestment = 'latest_investment',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Library = 'library',
  /** column name */
  Linkedin = 'linkedin',
  /** column name */
  LocationJson = 'location_json',
  /** column name */
  Logo = 'logo',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  NumOfExits = 'num_of_exits',
  /** column name */
  NumOfInvestments = 'num_of_investments',
  /** column name */
  NumOfViews = 'num_of_views',
  /** column name */
  Overview = 'overview',
  /** column name */
  Sentiment = 'sentiment',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusTags = 'status_tags',
  /** column name */
  Tags = 'tags',
  /** column name */
  TeamSize = 'team_size',
  /** column name */
  Telegram = 'telegram',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Web3Address = 'web3_address',
  /** column name */
  WebDomain = 'web_domain',
  /** column name */
  Website = 'website',
  /** column name */
  YearFounded = 'year_founded'
}

export type Vc_Firms_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Vc_Firms_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Vc_Firms_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Vc_Firms_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Vc_Firms_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Vc_Firms_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Vc_Firms_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Vc_Firms_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vc_Firms_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vc_Firms_Var_Pop_Fields = {
  __typename?: 'vc_firms_var_pop_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Vc_Firms_Var_Samp_Fields = {
  __typename?: 'vc_firms_var_samp_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Vc_Firms_Variance_Fields = {
  __typename?: 'vc_firms_variance_fields';
  datapoints_count: Maybe<Scalars['Float']>;
  enrichment_priority: Maybe<Scalars['Float']>;
  id: Maybe<Scalars['Float']>;
  investment_amount_total: Maybe<Scalars['Float']>;
  latitude: Maybe<Scalars['Float']>;
  longitude: Maybe<Scalars['Float']>;
  num_of_exits: Maybe<Scalars['Float']>;
  num_of_investments: Maybe<Scalars['Float']>;
  num_of_views: Maybe<Scalars['Float']>;
  team_size: Maybe<Scalars['Float']>;
};

/** List of waitlist emailIds */
export type Waitlist_Emails = {
  __typename?: 'waitlist_emails';
  created_at: Scalars['date'];
  email: Scalars['String'];
  id: Scalars['Int'];
  updated_at: Scalars['date'];
};

/** aggregated selection of "waitlist_emails" */
export type Waitlist_Emails_Aggregate = {
  __typename?: 'waitlist_emails_aggregate';
  aggregate: Maybe<Waitlist_Emails_Aggregate_Fields>;
  nodes: Array<Waitlist_Emails>;
};

/** aggregate fields of "waitlist_emails" */
export type Waitlist_Emails_Aggregate_Fields = {
  __typename?: 'waitlist_emails_aggregate_fields';
  avg: Maybe<Waitlist_Emails_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Waitlist_Emails_Max_Fields>;
  min: Maybe<Waitlist_Emails_Min_Fields>;
  stddev: Maybe<Waitlist_Emails_Stddev_Fields>;
  stddev_pop: Maybe<Waitlist_Emails_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Waitlist_Emails_Stddev_Samp_Fields>;
  sum: Maybe<Waitlist_Emails_Sum_Fields>;
  var_pop: Maybe<Waitlist_Emails_Var_Pop_Fields>;
  var_samp: Maybe<Waitlist_Emails_Var_Samp_Fields>;
  variance: Maybe<Waitlist_Emails_Variance_Fields>;
};


/** aggregate fields of "waitlist_emails" */
export type Waitlist_Emails_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Waitlist_Emails_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Waitlist_Emails_Avg_Fields = {
  __typename?: 'waitlist_emails_avg_fields';
  id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "waitlist_emails". All fields are combined with a logical 'AND'. */
export type Waitlist_Emails_Bool_Exp = {
  _and: InputMaybe<Array<Waitlist_Emails_Bool_Exp>>;
  _not: InputMaybe<Waitlist_Emails_Bool_Exp>;
  _or: InputMaybe<Array<Waitlist_Emails_Bool_Exp>>;
  created_at: InputMaybe<Date_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<Int_Comparison_Exp>;
  updated_at: InputMaybe<Date_Comparison_Exp>;
};

/** unique or primary key constraints on table "waitlist_emails" */
export enum Waitlist_Emails_Constraint {
  /** unique or primary key constraint on columns "email" */
  WaitlistEmailsEmailKey = 'waitlist_emails_email_key',
  /** unique or primary key constraint on columns "id" */
  WaitlistEmailsPkey = 'waitlist_emails_pkey'
}

/** input type for incrementing numeric columns in table "waitlist_emails" */
export type Waitlist_Emails_Inc_Input = {
  id: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "waitlist_emails" */
export type Waitlist_Emails_Insert_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate max on columns */
export type Waitlist_Emails_Max_Fields = {
  __typename?: 'waitlist_emails_max_fields';
  created_at: Maybe<Scalars['date']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['date']>;
};

/** aggregate min on columns */
export type Waitlist_Emails_Min_Fields = {
  __typename?: 'waitlist_emails_min_fields';
  created_at: Maybe<Scalars['date']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['Int']>;
  updated_at: Maybe<Scalars['date']>;
};

/** response of any mutation on the table "waitlist_emails" */
export type Waitlist_Emails_Mutation_Response = {
  __typename?: 'waitlist_emails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Waitlist_Emails>;
};

/** on_conflict condition type for table "waitlist_emails" */
export type Waitlist_Emails_On_Conflict = {
  constraint: Waitlist_Emails_Constraint;
  update_columns: Array<Waitlist_Emails_Update_Column>;
  where: InputMaybe<Waitlist_Emails_Bool_Exp>;
};

/** Ordering options when selecting data from "waitlist_emails". */
export type Waitlist_Emails_Order_By = {
  created_at: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
};

/** primary key columns input for table: waitlist_emails */
export type Waitlist_Emails_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "waitlist_emails" */
export enum Waitlist_Emails_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "waitlist_emails" */
export type Waitlist_Emails_Set_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate stddev on columns */
export type Waitlist_Emails_Stddev_Fields = {
  __typename?: 'waitlist_emails_stddev_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Waitlist_Emails_Stddev_Pop_Fields = {
  __typename?: 'waitlist_emails_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Waitlist_Emails_Stddev_Samp_Fields = {
  __typename?: 'waitlist_emails_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "waitlist_emails" */
export type Waitlist_Emails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Waitlist_Emails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Waitlist_Emails_Stream_Cursor_Value_Input = {
  created_at: InputMaybe<Scalars['date']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['Int']>;
  updated_at: InputMaybe<Scalars['date']>;
};

/** aggregate sum on columns */
export type Waitlist_Emails_Sum_Fields = {
  __typename?: 'waitlist_emails_sum_fields';
  id: Maybe<Scalars['Int']>;
};

/** update columns of table "waitlist_emails" */
export enum Waitlist_Emails_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Waitlist_Emails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Waitlist_Emails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Waitlist_Emails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Waitlist_Emails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Waitlist_Emails_Var_Pop_Fields = {
  __typename?: 'waitlist_emails_var_pop_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Waitlist_Emails_Var_Samp_Fields = {
  __typename?: 'waitlist_emails_var_samp_fields';
  id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Waitlist_Emails_Variance_Fields = {
  __typename?: 'waitlist_emails_variance_fields';
  id: Maybe<Scalars['Float']>;
};

export type InsertActionMutationVariables = Exact<{
  object: Actions_Insert_Input;
}>;


export type InsertActionMutation = { __typename?: 'mutation_root', insert_actions_one: { __typename?: 'actions', id: number } | null };

export type GetDeleteDataActionsQueryVariables = Exact<{
  resourceType: Scalars['String'];
  date: InputMaybe<Scalars['timestamptz']>;
}>;


export type GetDeleteDataActionsQuery = { __typename?: 'query_root', actions: Array<{ __typename?: 'actions', resource_id: number | null }> };

export type GetAllowedEmailByEmailOrDomainQueryVariables = Exact<{
  email: InputMaybe<Scalars['String']>;
  domain: InputMaybe<Scalars['String']>;
}>;


export type GetAllowedEmailByEmailOrDomainQuery = { __typename?: 'query_root', allowed_emails: Array<{ __typename?: 'allowed_emails', id: number, email: string, person_id: number | null }> };

export type GetLastSyncQueryVariables = Exact<{ [key: string]: never; }>;


export type GetLastSyncQuery = { __typename?: 'query_root', application_meta: Array<{ __typename?: 'application_meta', id: number, key: string, value: any }> };

export type UpdateApplicationMetaValueMutationVariables = Exact<{
  value: InputMaybe<Scalars['timestamptz']>;
  key: Scalars['String'];
}>;


export type UpdateApplicationMetaValueMutation = { __typename?: 'mutation_root', update_application_meta: { __typename?: 'application_meta_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'application_meta', id: number, key: string, value: any }> } | null };

export type UpdateApplicationMetaErrorMutationVariables = Exact<{
  error: InputMaybe<Scalars['String']>;
  key: Scalars['String'];
}>;


export type UpdateApplicationMetaErrorMutation = { __typename?: 'mutation_root', update_application_meta: { __typename?: 'application_meta_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'application_meta', id: number, key: string, value: any }> } | null };

export type InsertBillingOrgMutationVariables = Exact<{
  customer_id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['String']>;
  plan: InputMaybe<Scalars['String']>;
}>;


export type InsertBillingOrgMutation = { __typename?: 'mutation_root', insert_billing_org_one: { __typename?: 'billing_org', id: number } | null };

export type GetBillingOrgByCustomerIdQueryVariables = Exact<{
  customerId: Scalars['String'];
}>;


export type GetBillingOrgByCustomerIdQuery = { __typename?: 'query_root', billing_org: Array<{ __typename?: 'billing_org', customer_id: string, id: number, plan: string, status: string, user_limit: number }> };

export type GetBillingOrgByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetBillingOrgByIdQuery = { __typename?: 'query_root', billing_org: Array<{ __typename?: 'billing_org', customer_id: string, id: number, plan: string, status: string, user_limit: number }> };

export type UpdateBillingOrgMutationVariables = Exact<{
  id: Scalars['Int'];
  status: Scalars['String'];
}>;


export type UpdateBillingOrgMutation = { __typename?: 'mutation_root', update_billing_org_by_pk: { __typename?: 'billing_org', id: number, status: string } | null };

export type UpdateBillingOrgCustomerIdMutationVariables = Exact<{
  id: Scalars['Int'];
  customerId: Scalars['String'];
  status: Scalars['String'];
}>;


export type UpdateBillingOrgCustomerIdMutation = { __typename?: 'mutation_root', update_billing_org_by_pk: { __typename?: 'billing_org', id: number, customer_id: string } | null };

export type GetAllCoinsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllCoinsQuery = { __typename?: 'query_root', coins: Array<{ __typename?: 'coins', ticker: string, name: string, id: number }> };

export type GetCompanyBySlugQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetCompanyBySlugQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null, layer: string | null, overview: string | null, investor_amount: any | null, white_paper: string | null, total_employees: any | null, year_founded: string | null, website: string | null, market_verified: string | null, company_linkedin: string | null, careers_page: string | null, velocity_linkedin: string | null, velocity_token: string | null, tags: any | null, date_added: any | null, ico_start: any | null, ico_end: any | null, audit_file: string | null, sentiment: any | null, web3_address: any | null, twitter: string | null, discord: string | null, telegram: string | null, github: string | null, location_json: any | null, glassdoor: string | null, status_tags: any | null, library: any | null, coin: { __typename?: 'coins', id: number, ticker: string } | null, teamMembers: Array<{ __typename?: 'team_members', id: number, function: string | null, start_date: any | null, end_date: any | null, founder: boolean | null, title: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null, linkedin: string | null, personal_email: string | null, work_email: string | null } | null }>, investment_rounds: Array<{ __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, valuation: any | null, investments: Array<{ __typename?: 'investments', id: number, amount: any | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null } | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null } | null }> }>, to_links: Array<{ __typename?: 'resource_links', id: number, link_type: string, from_company: { __typename?: 'companies', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, status_tags: any | null, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> } | null, from_vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> } | null }>, from_links: Array<{ __typename?: 'resource_links', id: number, link_type: string, to_company: { __typename?: 'companies', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, total_employees: any | null, investor_amount: any | null, year_founded: string | null, status_tags: any | null, investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null }, investment_rounds: Array<{ __typename?: 'investment_rounds', round: string | null, round_date: any | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> } | null, to_vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, year_founded: string | null, investment_amount_total: any | null, num_of_investments: number | null, logo: any | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> } | null }>, news_links: Array<{ __typename?: 'news_organizations', id: number, news: { __typename?: 'news', id: number, date: any | null, text: string, link: string | null, kind: string | null, status: string | null, source: any | null, organizations: Array<{ __typename?: 'news_organizations', id: number, type: string | null, company_id: number | null, vc_firm_id: number | null }> } | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> }> };

export type GetCompaniesQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Companies_Order_By> | Companies_Order_By>;
  where: Companies_Bool_Exp;
}>;


export type GetCompaniesQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, slug: string, logo: any | null, name: string | null, tags: any | null, location_json: any | null, status_tags: any | null, total_employees: any | null, investor_amount: any | null, year_founded: string | null, overview: string | null, website: string | null, twitter: string | null, company_linkedin: string | null, github: string | null, discord: string | null, coin: { __typename?: 'coins', ticker: string } | null, investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null }, investment_rounds: Array<{ __typename?: 'investment_rounds', round: string | null, round_date: any | null, amount: any | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> }>, companies_aggregate: { __typename?: 'companies_aggregate', aggregate: { __typename?: 'companies_aggregate_fields', count: number } | null } };

export type GetCompaniesRecentQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  where: Companies_Bool_Exp;
}>;


export type GetCompaniesRecentQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, name: string | null, slug: string, layer: string | null, tags: any | null, logo: any | null, overview: string | null, total_employees: any | null, investor_amount: any | null, year_founded: string | null, date_added: any | null, sentiment: any | null, status_tags: any | null, investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null }, investment_rounds: Array<{ __typename?: 'investment_rounds', id: number, amount: any | null, round: string | null, round_date: any | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> }> };

export type GetRelevantCompaniesQueryVariables = Exact<{
  where: Companies_Bool_Exp;
  limit: InputMaybe<Scalars['Int']>;
}>;


export type GetRelevantCompaniesQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, logo: any | null, name: string | null, slug: string, sentiment: any | null }> };

export type GetSentimentByCompanyIdQueryVariables = Exact<{
  companyId: Scalars['Int'];
}>;


export type GetSentimentByCompanyIdQuery = { __typename?: 'query_root', companies_by_pk: { __typename?: 'companies', sentiment: any | null, slug: string } | null };

export type UpdateSentimentByCompanyIdMutationVariables = Exact<{
  companyId: Scalars['Int'];
  sentiment: Scalars['jsonb'];
}>;


export type UpdateSentimentByCompanyIdMutation = { __typename?: 'mutation_root', update_companies_by_pk: { __typename?: 'companies', sentiment: any | null } | null };

export type GetCompaniesByDateQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetCompaniesByDateQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, name: string | null, overview: string | null, tags: any | null, logo: any | null, slug: string, aliases: string | null, coin: { __typename?: 'coins', ticker: string, name: string } | null }> };

export type UpdateCompanyByPkMutationVariables = Exact<{
  companyId: Scalars['Int'];
  data: InputMaybe<Companies_Set_Input>;
}>;


export type UpdateCompanyByPkMutation = { __typename?: 'mutation_root', update_companies_by_pk: { __typename?: 'companies', id: number } | null };

export type GetCompanyByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetCompanyByIdQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, name: string | null, status: string }> };

export type GetCompanyInsightByLocationQueryVariables = Exact<{
  where: Companies_Bool_Exp;
}>;


export type GetCompanyInsightByLocationQuery = { __typename?: 'query_root', companies_aggregate: { __typename?: 'companies_aggregate', aggregate: { __typename?: 'companies_aggregate_fields', count: number } | null } };

export type GetPersonalizedCompaniesQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Companies_Order_By> | Companies_Order_By>;
  where: Companies_Bool_Exp;
}>;


export type GetPersonalizedCompaniesQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, slug: string, logo: any | null, name: string | null, tags: any | null, location_json: any | null, status_tags: any | null, total_employees: any | null, investor_amount: any | null, year_founded: string | null, overview: string | null, website: string | null, twitter: string | null, company_linkedin: string | null, github: string | null, discord: string | null, coin: { __typename?: 'coins', ticker: string } | null, investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null }, investment_rounds: Array<{ __typename?: 'investment_rounds', round: string | null, round_date: any | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> }>, companies_aggregate: { __typename?: 'companies_aggregate', aggregate: { __typename?: 'companies_aggregate_fields', count: number } | null } };

export type InsertCompaniesMutationVariables = Exact<{
  objects: Array<Companies_Insert_Input> | Companies_Insert_Input;
}>;


export type InsertCompaniesMutation = { __typename?: 'mutation_root', insert_companies: { __typename?: 'companies_mutation_response', returning: Array<{ __typename?: 'companies', id: number, status: string, slug: string, enrichment_priority: number, website: string | null, company_linkedin: string | null }> } | null };

export type GetCompaniesByTagsAndLocationQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  where: Companies_Bool_Exp;
}>;


export type GetCompaniesByTagsAndLocationQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number }> };

export type InsertDataDiscardMutationVariables = Exact<{
  input: Array<Data_Discard_Insert_Input> | Data_Discard_Insert_Input;
}>;


export type InsertDataDiscardMutation = { __typename?: 'mutation_root', insert_data_discard: { __typename?: 'data_discard_mutation_response', returning: Array<{ __typename?: 'data_discard', id: any, created_at: any, resource: string, resource_id: number, field: string, value: any, accuracy_weight: number }> } | null };

export type GetDataFieldByPathQueryVariables = Exact<{
  path: Scalars['String'];
}>;


export type GetDataFieldByPathQuery = { __typename?: 'query_root', data_fields: Array<{ __typename?: 'data_fields', name: string, resource: string, weight: number, regex_transform: string | null, description: string | null, regex_test: string | null, is_valid_identifier: boolean, restricted_admin: boolean, data_type: string | null }> };

export type GetDataPartnerByApiKeyQueryVariables = Exact<{
  apiKey: Scalars['String'];
}>;


export type GetDataPartnerByApiKeyQuery = { __typename?: 'query_root', data_partners: Array<{ __typename?: 'data_partners', id: number, name: string, api_key: string }> };

export type InsertDataRawMutationVariables = Exact<{
  input: Array<Data_Raw_Insert_Input> | Data_Raw_Insert_Input;
}>;


export type InsertDataRawMutation = { __typename?: 'mutation_root', insert_data_raw: { __typename?: 'data_raw_mutation_response', returning: Array<{ __typename?: 'data_raw', id: any, created_at: any, resource: string, resource_id: number, field: string, value: any, accuracy_weight: number }> } | null };

export type MarkDataRawAsInactiveMutationVariables = Exact<{
  resourceType: Scalars['String'];
  resourceId: Scalars['Int'];
}>;


export type MarkDataRawAsInactiveMutation = { __typename?: 'mutation_root', update_data_raw: { __typename?: 'data_raw_mutation_response', affected_rows: number } | null };

export type GetDisabledEmailByEmailOrDomainQueryVariables = Exact<{
  email: InputMaybe<Scalars['String']>;
  domain: InputMaybe<Scalars['String']>;
}>;


export type GetDisabledEmailByEmailOrDomainQuery = { __typename?: 'query_root', disabled_emails: Array<{ __typename?: 'disabled_emails', id: number, email: string }> };

export type GetEventsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Events_Order_By> | Events_Order_By>;
  where: Events_Bool_Exp;
}>;


export type GetEventsQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'events', id: number, name: string, slug: string, banner: any | null, overview: string | null, notes: string | null, location_json: any | null, venue_name: string | null, link: string | null, size: string | null, price: any | null, types: any | null, start_date: any | null, start_time: any | null, end_date: any | null, end_time: any | null, timezone: string | null, twitter: string | null, facebook: string | null, instagram: string | null, discord: string | null, telegram: string | null, is_featured: boolean | null, created_at: any, library: any | null, parent_event_id: number | null, event_person: Array<{ __typename?: 'event_person', id: number, type: string, created_at: any, person_id: number }> }>, events_aggregate: { __typename?: 'events_aggregate', aggregate: { __typename?: 'events_aggregate_fields', count: number } | null } };

export type GetEventQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetEventQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'events', id: number, name: string, slug: string, banner: any | null, overview: string | null, notes: string | null, location_json: any | null, venue_name: string | null, link: string | null, size: string | null, price: any | null, types: any | null, start_date: any | null, start_time: any | null, end_date: any | null, end_time: any | null, timezone: string | null, twitter: string | null, facebook: string | null, instagram: string | null, discord: string | null, telegram: string | null, is_featured: boolean | null, attachments: any, created_at: any, library: any | null, event_person: Array<{ __typename?: 'event_person', id: number, type: string, created_at: any, person: { __typename?: 'people', id: number, slug: string, name: string | null, type: string | null, picture: any | null, linkedin: string | null, personal_email: string | null, work_email: string | null, status: string, investors: Array<{ __typename?: 'investors', id: number, title: string | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null } | null }>, team_members: Array<{ __typename?: 'team_members', id: number, founder: boolean | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null } | null }> } | null }>, event_organization: Array<{ __typename?: 'event_organization', id: number, type: string | null, sponsor_type: string | null, created_at: any, company: { __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null, status: string } | null, vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null, status: string } | null }>, parent_event: { __typename?: 'events', id: number, slug: string, name: string } | null }> };

export type GetEventsByDateQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetEventsByDateQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'events', id: number, name: string, slug: string, overview: string | null, banner: any | null, location_json: any | null, start_date: any | null, end_date: any | null }> };

export type InsertEventAttendeeMutationVariables = Exact<{
  object: Event_Person_Insert_Input;
}>;


export type InsertEventAttendeeMutation = { __typename?: 'mutation_root', insert_event_person_one: { __typename?: 'event_person', id: number, event_id: number, person_id: number, type: string } | null };

export type FindEventAttendeeQueryVariables = Exact<{
  event_id: Scalars['Int'];
  person_id: Scalars['Int'];
}>;


export type FindEventAttendeeQuery = { __typename?: 'query_root', event_person: Array<{ __typename?: 'event_person', id: number }> };

export type GetSubEventsQueryVariables = Exact<{
  parent_event_id: Scalars['Int'];
}>;


export type GetSubEventsQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'events', id: number, name: string, slug: string, banner: any | null, overview: string | null, notes: string | null, location_json: any | null, venue_name: string | null, link: string | null, size: string | null, price: any | null, types: any | null, start_date: any | null, start_time: any | null, end_date: any | null, end_time: any | null, timezone: string | null, is_featured: boolean | null, created_at: any }> };

export type GetEventOrganizationByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetEventOrganizationByIdQuery = { __typename?: 'query_root', event_organization: Array<{ __typename?: 'event_organization', id: number, company_id: number | null, vc_firm_id: number | null, type: string | null, event: { __typename?: 'events', id: number, name: string, slug: string, status: string } | null }> };

export type GetEventInsightByLocationQueryVariables = Exact<{
  where: Events_Bool_Exp;
}>;


export type GetEventInsightByLocationQuery = { __typename?: 'query_root', events_aggregate: { __typename?: 'events_aggregate', aggregate: { __typename?: 'events_aggregate_fields', count: number } | null } };

export type GetFollowsByUserQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type GetFollowsByUserQuery = { __typename?: 'query_root', list_members: Array<{ __typename?: 'list_members', list: { __typename?: 'lists', name: string, description: string | null, id: number, public: boolean | null, created_by_id: number, created_at: any | null, updated_at: any | null, total_no_of_resources: number | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null } | null } | null, follows_companies: Array<{ __typename?: 'follows_companies', resource_id: number | null }>, follows_vcfirms: Array<{ __typename?: 'follows_vc_firms', resource_id: number | null }>, follows_people: Array<{ __typename?: 'follows_people', resource_id: number | null }> } }> };

export type GetCompaniesByListIdQueryVariables = Exact<{
  list_id?: InputMaybe<Scalars['Int']>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
}>;


export type GetCompaniesByListIdQuery = { __typename?: 'query_root', follows_companies: Array<{ __typename?: 'follows_companies', id: number | null, company: { __typename?: 'companies', id: number, name: string | null, website: string | null, logo: any | null, sentiment: any | null, location_json: any | null, twitter: string | null, year_founded: string | null, total_employees: any | null, overview: string | null, tags: any | null, slug: string, coin: { __typename?: 'coins', ticker: string, name: string } | null, teamMembers: Array<{ __typename?: 'team_members', id: number, founder: boolean | null, person: { __typename?: 'people', id: number, slug: string, name: string | null } | null }>, investment_rounds: Array<{ __typename?: 'investment_rounds', amount: any | null, round_date: any | null, round: string | null }> } | null }>, follows_companies_aggregate: { __typename?: 'follows_companies_aggregate', aggregate: { __typename?: 'follows_companies_aggregate_fields', count: number } | null } };

export type GetVcFirmsByListIdQueryVariables = Exact<{
  list_id?: InputMaybe<Scalars['Int']>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
}>;


export type GetVcFirmsByListIdQuery = { __typename?: 'query_root', follows_vc_firms: Array<{ __typename?: 'follows_vc_firms', id: number | null, vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, website: string | null, num_of_investments: number | null, latest_investment: any | null, sentiment: any | null, logo: any | null, slug: string, location_json: any | null, year_founded: string | null, overview: string | null, tags: any | null, investors: Array<{ __typename?: 'investors', id: number, founder: boolean | null, person: { __typename?: 'people', id: number, slug: string, name: string | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, amount: any | null, round_date: any | null, round: string | null } | null }> } | null }>, follows_vc_firms_aggregate: { __typename?: 'follows_vc_firms_aggregate', aggregate: { __typename?: 'follows_vc_firms_aggregate_fields', count: number } | null } };

export type UpsertFollowsMutationVariables = Exact<{
  listId: InputMaybe<Scalars['Int']>;
  resourceId: InputMaybe<Scalars['Int']>;
  resourceType: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['Int']>;
}>;


export type UpsertFollowsMutation = { __typename?: 'mutation_root', insert_follows_one: { __typename?: 'follows', id: number } | null };

export type DeleteFollowsMutationVariables = Exact<{
  where: Follows_Bool_Exp;
}>;


export type DeleteFollowsMutation = { __typename?: 'mutation_root', delete_follows: { __typename?: 'follows_mutation_response', returning: Array<{ __typename?: 'follows', id: number }> } | null };

export type GetFollowByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetFollowByIdQuery = { __typename?: 'query_root', follows: Array<{ __typename?: 'follows', id: number, created_by_user_id: number, resource_type: string, resource_id: number, list_id: number | null }> };

export type GetFollowsByResourceQueryVariables = Exact<{
  resourceId: Scalars['Int'];
  resourceType: Scalars['String'];
}>;


export type GetFollowsByResourceQuery = { __typename?: 'query_root', follows: Array<{ __typename?: 'follows', id: number, list_id: number | null, list: { __typename?: 'lists', list_members: Array<{ __typename?: 'list_members', id: number, user_id: number }> } | null }> };

export type GetPeopleByListIdQueryVariables = Exact<{
  list_id?: InputMaybe<Scalars['Int']>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
}>;


export type GetPeopleByListIdQuery = { __typename?: 'query_root', follows_people: Array<{ __typename?: 'follows_people', id: number | null, person: { __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string, type: string | null, personal_email: string | null, work_email: string | null, city: string | null, country: string | null, website_url: string | null, github: string | null, twitter_url: string | null, linkedin: string | null } | null }>, follows_people_aggregate: { __typename?: 'follows_people_aggregate', aggregate: { __typename?: 'follows_people_aggregate_fields', count: number } | null } };

export type CheckFollowExistsQueryVariables = Exact<{
  where: Follows_Bool_Exp;
}>;


export type CheckFollowExistsQuery = { __typename?: 'query_root', follows: Array<{ __typename?: 'follows', id: number }> };

export type GetGroupsOfUserQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type GetGroupsOfUserQuery = { __typename?: 'query_root', user_group_members: Array<{ __typename?: 'user_group_members', id: number, user_id: number, user_group_id: number, user: { __typename?: 'users_public', id: number | null, email: string | null, display_name: string | null } | null, user_group: { __typename?: 'user_groups', id: number, name: string, description: string | null, telegram: string | null, twitter: string | null, discord: string | null, public: boolean | null, created_at: any, updated_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null } }> };

export type GetGroupsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  where: User_Groups_Bool_Exp;
}>;


export type GetGroupsQuery = { __typename?: 'query_root', user_groups: Array<{ __typename?: 'user_groups', id: number, name: string, description: string | null, telegram: string | null, twitter: string | null, discord: string | null, public: boolean | null, created_by_user_id: number, created_at: any, updated_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null } | null } | null, notes: Array<{ __typename?: 'notes', id: number, notes: string }>, user_group_members: Array<{ __typename?: 'user_group_members', id: number, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, picture: any | null } | null } | null }>, user_group_invites: Array<{ __typename?: 'user_group_invites', id: number, email: string, created_at: any, created_by_user_id: number | null }>, list_user_groups: Array<{ __typename?: 'list_user_groups', id: number, list_id: number }> }>, user_groups_aggregate: { __typename?: 'user_groups_aggregate', aggregate: { __typename?: 'user_groups_aggregate_fields', count: number } | null } };

export type GetGroupQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetGroupQuery = { __typename?: 'query_root', user_groups: Array<{ __typename?: 'user_groups', id: number, name: string, description: string | null, telegram: string | null, twitter: string | null, discord: string | null, public: boolean | null, created_by_user_id: number, created_at: any, updated_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null, user_group_members: Array<{ __typename?: 'user_group_members', id: number, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, picture: any | null } | null } | null }>, user_group_invites: Array<{ __typename?: 'user_group_invites', id: number, email: string, created_at: any, created_by_user_id: number | null }> }> };

export type InsertUserGroupMutationVariables = Exact<{
  object: User_Groups_Insert_Input;
}>;


export type InsertUserGroupMutation = { __typename?: 'mutation_root', insert_user_groups_one: { __typename?: 'user_groups', id: number, name: string, description: string | null, twitter: string | null, telegram: string | null, discord: string | null, created_at: any, updated_at: any | null, created_by_user_id: number } | null };

export type UpdateUserGroupMutationVariables = Exact<{
  id: Scalars['Int'];
  changes: User_Groups_Set_Input;
}>;


export type UpdateUserGroupMutation = { __typename?: 'mutation_root', update_user_groups: { __typename?: 'user_groups_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_groups', id: number, name: string, description: string | null, twitter: string | null, telegram: string | null, discord: string | null, created_at: any, updated_at: any | null, created_by_user_id: number, notes: Array<{ __typename?: 'notes', id: number, notes: string }>, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null }> } | null };

export type DeleteUserGroupMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteUserGroupMutation = { __typename?: 'mutation_root', delete_user_groups: { __typename?: 'user_groups_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_groups', id: number }> } | null };

export type DeleteUserGroupInvitesByGroupIdMutationVariables = Exact<{
  groupId: Scalars['Int'];
}>;


export type DeleteUserGroupInvitesByGroupIdMutation = { __typename?: 'mutation_root', delete_user_group_invites: { __typename?: 'user_group_invites_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_group_invites', id: number }> } | null };

export type DeleteUserGroupMembersByGroupIdMutationVariables = Exact<{
  groupId: Scalars['Int'];
}>;


export type DeleteUserGroupMembersByGroupIdMutation = { __typename?: 'mutation_root', delete_user_group_members: { __typename?: 'user_group_members_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_group_members', id: number }> } | null };

export type GetUserGroupByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserGroupByIdQuery = { __typename?: 'query_root', user_groups: Array<{ __typename?: 'user_groups', id: number, name: string, created_by_user_id: number, created_at: any }> };

export type GetUserGroupMemberByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserGroupMemberByIdQuery = { __typename?: 'query_root', user_group_members: Array<{ __typename?: 'user_group_members', id: number, user_id: number, user_group_id: number, user: { __typename?: 'users_public', id: number | null, email: string | null } | null }> };

export type GetUserGroupMemberByGroupIdQueryVariables = Exact<{
  user_group_id: Scalars['Int'];
}>;


export type GetUserGroupMemberByGroupIdQuery = { __typename?: 'query_root', user_group_members: Array<{ __typename?: 'user_group_members', id: number, user_group_id: number, user_id: number, user_group: { __typename?: 'user_groups', id: number, name: string, description: string | null }, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null }> };

export type GetUserGroupInviteByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserGroupInviteByIdQuery = { __typename?: 'query_root', user_group_invites: Array<{ __typename?: 'user_group_invites', id: number, email: string, user_group_id: number, created_by_user_id: number | null }> };

export type InsertUserGroupMembersMutationVariables = Exact<{
  object: User_Group_Members_Insert_Input;
}>;


export type InsertUserGroupMembersMutation = { __typename?: 'mutation_root', insert_user_group_members_one: { __typename?: 'user_group_members', id: number, user_id: number, user_group_id: number, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, picture: any | null } | null } | null, user_group: { __typename?: 'user_groups', id: number, name: string } } | null };

export type GetUserGroupInvitesByEmailQueryVariables = Exact<{
  email: Scalars['String'];
}>;


export type GetUserGroupInvitesByEmailQuery = { __typename?: 'query_root', user_group_invites: Array<{ __typename?: 'user_group_invites', id: number, user_group_id: number }> };

export type GetUserGroupInvitesByEmailAndGroupIdQueryVariables = Exact<{
  email: Scalars['String'];
  user_group_id: Scalars['Int'];
}>;


export type GetUserGroupInvitesByEmailAndGroupIdQuery = { __typename?: 'query_root', user_group_invites: Array<{ __typename?: 'user_group_invites', id: number, email: string, user_group_id: number, created_by_user_id: number | null }> };

export type GetUserGroupMembersByUserIdAndGroupIdQueryVariables = Exact<{
  user_id: Scalars['Int'];
  user_group_id: Scalars['Int'];
}>;


export type GetUserGroupMembersByUserIdAndGroupIdQuery = { __typename?: 'query_root', user_group_members: Array<{ __typename?: 'user_group_members', id: number, user_id: number, user_group_id: number }> };

export type DeleteUserGroupInviteByIdMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteUserGroupInviteByIdMutation = { __typename?: 'mutation_root', delete_user_group_invites: { __typename?: 'user_group_invites_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_group_invites', id: number }> } | null };

export type DeleteUserGroupMemberByIdMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteUserGroupMemberByIdMutation = { __typename?: 'mutation_root', delete_user_group_members: { __typename?: 'user_group_members_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'user_group_members', id: number }> } | null };

export type InsertUserGroupInvitesMutationVariables = Exact<{
  object: User_Group_Invites_Insert_Input;
}>;


export type InsertUserGroupInvitesMutation = { __typename?: 'mutation_root', insert_user_group_invites_one: { __typename?: 'user_group_invites', id: number, email: string, user_group_id: number, created_by_user_id: number | null } | null };

export type UpsertInvestmentRoundMutationVariables = Exact<{
  data: Investment_Rounds_Insert_Input;
}>;


export type UpsertInvestmentRoundMutation = { __typename?: 'mutation_root', insert_investment_rounds_one: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, valuation: any | null, currency: string | null } | null };

export type GetInvestmentRoundByRoundIdQueryVariables = Exact<{
  round_id: Scalars['Int'];
}>;


export type GetInvestmentRoundByRoundIdQuery = { __typename?: 'query_root', investment_rounds: Array<{ __typename?: 'investment_rounds', id: number, company_id: number | null }> };

export type GetInvestmentRoundByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetInvestmentRoundByIdQuery = { __typename?: 'query_root', investment_rounds: Array<{ __typename?: 'investment_rounds', id: number, round: string | null, company_id: number | null, status: string, company: { __typename?: 'companies', id: number, name: string | null, slug: string } | null }> };

export type GetInvestmentInsightByLocationQueryVariables = Exact<{
  where: Investment_Rounds_Bool_Exp;
}>;


export type GetInvestmentInsightByLocationQuery = { __typename?: 'query_root', investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null } };

export type UpsertInvestmentsMutationVariables = Exact<{
  data: Array<Investments_Insert_Input> | Investments_Insert_Input;
}>;


export type UpsertInvestmentsMutation = { __typename?: 'mutation_root', insert_investments: { __typename?: 'investments_mutation_response', returning: Array<{ __typename?: 'investments', id: number, round_id: number | null, person_id: number | null, vc_firm_id: number | null, amount: any | null }> } | null };

export type DeleteInvestmentMutationVariables = Exact<{
  investmentId: Scalars['Int'];
}>;


export type DeleteInvestmentMutation = { __typename?: 'mutation_root', delete_investments_by_pk: { __typename?: 'investments', id: number } | null };

export type GetInvestmentByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetInvestmentByIdQuery = { __typename?: 'query_root', investments: Array<{ __typename?: 'investments', id: number, vc_firm_id: number | null, round_id: number | null, status: string }> };

export type InsertInvestorMutationVariables = Exact<{
  personId: InputMaybe<Scalars['Int']>;
  vcFirmId: InputMaybe<Scalars['Int']>;
}>;


export type InsertInvestorMutation = { __typename?: 'mutation_root', insert_investors_one: { __typename?: 'investors', id: number } | null };

export type GetInvestorByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetInvestorByIdQuery = { __typename?: 'query_root', investors: Array<{ __typename?: 'investors', id: number, vc_firm_id: number | null, person_id: number | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, status: string } | null }> };

export type GetInvestorByPersonIdQueryVariables = Exact<{
  personId: Scalars['Int'];
}>;


export type GetInvestorByPersonIdQuery = { __typename?: 'query_root', investors: Array<{ __typename?: 'investors', id: number, vc_firm_id: number | null, person_id: number | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, status: string } | null, vc_firm: { __typename?: 'vc_firms', name: string | null } | null }> };

export type GetInvestorMailingListQueryVariables = Exact<{
  personId: Scalars['Int'];
}>;


export type GetInvestorMailingListQuery = { __typename?: 'query_root', investors: Array<{ __typename?: 'investors', id: number, vc_firm: { __typename?: 'vc_firms', investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', company: { __typename?: 'companies', id: number, name: string | null, logo: any | null, slug: string, teamMembers: Array<{ __typename?: 'team_members', id: number, person_id: number | null }>, teamMembers_aggregate: { __typename?: 'team_members_aggregate', aggregate: { __typename?: 'team_members_aggregate_fields', count: number } | null } } | null } | null }> } | null }> };

export type GetAdminInvestorMailingListQueryVariables = Exact<{
  personId: Scalars['Int'];
  companyIds: InputMaybe<Array<Scalars['Int']> | Scalars['Int']>;
}>;


export type GetAdminInvestorMailingListQuery = { __typename?: 'query_root', investors: Array<{ __typename?: 'investors', id: number, vc_firm: { __typename?: 'vc_firms', investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', company: { __typename?: 'companies', id: number, teamMembers: Array<{ __typename?: 'team_members', id: number, email_address: string | null, person_id: number | null, person: { __typename?: 'people', name: string | null } | null }>, teamMembers_aggregate: { __typename?: 'team_members_aggregate', aggregate: { __typename?: 'team_members_aggregate_fields', count: number } | null } } | null } | null }> } | null }> };

export type GetInvitedPeopleByUserIdQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetInvitedPeopleByUserIdQuery = { __typename?: 'query_root', invited_people: Array<{ __typename?: 'invited_people', id: number, person_id: number, inviter_user_id: number, created_at: any }> };

export type InsertInvitedPeopleMutationVariables = Exact<{
  personId: Scalars['Int'];
  userId: Scalars['Int'];
}>;


export type InsertInvitedPeopleMutation = { __typename?: 'mutation_root', insert_invited_people_one: { __typename?: 'invited_people', id: number, person_id: number, inviter_user_id: number, created_at: any } | null };

export type InsertLeadsMutationVariables = Exact<{
  object: Leads_Insert_Input;
}>;


export type InsertLeadsMutation = { __typename?: 'mutation_root', insert_leads_one: { __typename?: 'leads', id: number } | null };

export type InsertLeadsSegmentationMutationVariables = Exact<{
  object: Leads_Segmentation_Insert_Input;
}>;


export type InsertLeadsSegmentationMutation = { __typename?: 'mutation_root', insert_leads_segmentation_one: { __typename?: 'leads_segmentation', id: number } | null };

export type GetListUserGroupsQueryVariables = Exact<{
  where: List_User_Groups_Bool_Exp;
}>;


export type GetListUserGroupsQuery = { __typename?: 'query_root', list_user_groups: Array<{ __typename?: 'list_user_groups', id: number, list_id: number, user_group_id: number, list: { __typename?: 'lists', id: number, name: string, description: string | null, public: boolean | null, created_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null } | null, user_group: { __typename?: 'user_groups', id: number, name: string } | null }> };

export type GetListMembersQueryVariables = Exact<{
  where: List_Members_Bool_Exp;
}>;


export type GetListMembersQuery = { __typename?: 'query_root', list_members: Array<{ __typename?: 'list_members', id: number, member_type: string, list_id: number, user_id: number, list: { __typename?: 'lists', id: number, name: string, public: boolean | null, created_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null }, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null }> };

export type GetListUserGroupsByListIdQueryVariables = Exact<{
  listId: Scalars['Int'];
}>;


export type GetListUserGroupsByListIdQuery = { __typename?: 'query_root', list_user_groups: Array<{ __typename?: 'list_user_groups', id: number, list_id: number, user_group_id: number }> };

export type InsertListUserGroupsMutationVariables = Exact<{
  object: List_User_Groups_Insert_Input;
}>;


export type InsertListUserGroupsMutation = { __typename?: 'mutation_root', insert_list_user_groups_one: { __typename?: 'list_user_groups', id: number, list_id: number, user_group_id: number } | null };

export type GetListUserGroupsByListIdAndGroupIdQueryVariables = Exact<{
  list_id: Scalars['Int'];
  user_group_id: Scalars['Int'];
}>;


export type GetListUserGroupsByListIdAndGroupIdQuery = { __typename?: 'query_root', list_user_groups: Array<{ __typename?: 'list_user_groups', id: number, list_id: number, user_group_id: number }> };

export type UpsertListMutationVariables = Exact<{
  userId: InputMaybe<Scalars['Int']>;
  name: InputMaybe<Scalars['String']>;
  public?: InputMaybe<Scalars['Boolean']>;
}>;


export type UpsertListMutation = { __typename?: 'mutation_root', insert_lists_one: { __typename?: 'lists', id: number } | null };

export type UpsertMembershipMutationVariables = Exact<{
  userId: Scalars['Int'];
  listId: Scalars['Int'];
}>;


export type UpsertMembershipMutation = { __typename?: 'mutation_root', insert_list_members_one: { __typename?: 'list_members', id: number } | null };

export type GetListByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetListByIdQuery = { __typename?: 'query_root', lists: Array<{ __typename?: 'lists', id: number, name: string, created_by_id: number }> };

export type DeleteListMembersMutationVariables = Exact<{
  where: List_Members_Bool_Exp;
}>;


export type DeleteListMembersMutation = { __typename?: 'mutation_root', delete_list_members: { __typename?: 'list_members_mutation_response', returning: Array<{ __typename?: 'list_members', id: number }> } | null };

export type DeleteListsMutationVariables = Exact<{
  where: Lists_Bool_Exp;
}>;


export type DeleteListsMutation = { __typename?: 'mutation_root', delete_lists: { __typename?: 'lists_mutation_response', returning: Array<{ __typename?: 'lists', id: number }> } | null };

export type DeleteListUserGroupsMutationVariables = Exact<{
  where: List_User_Groups_Bool_Exp;
}>;


export type DeleteListUserGroupsMutation = { __typename?: 'mutation_root', delete_list_user_groups: { __typename?: 'list_user_groups_mutation_response', returning: Array<{ __typename?: 'list_user_groups', id: number }> } | null };

export type InsertListMembersMutationVariables = Exact<{
  object: List_Members_Insert_Input;
}>;


export type InsertListMembersMutation = { __typename?: 'mutation_root', insert_list_members_one: { __typename?: 'list_members', id: number, member_type: string, list_id: number, user_id: number, list: { __typename?: 'lists', id: number, name: string, created_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null }, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null } | null } | null };

export type UpdateListByIdMutationVariables = Exact<{
  listId: Scalars['Int'];
  changes: Lists_Set_Input;
}>;


export type UpdateListByIdMutation = { __typename?: 'mutation_root', update_lists: { __typename?: 'lists_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'lists', id: number, name: string }> } | null };

export type TriggerListUpdatedAtMutationVariables = Exact<{
  id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
}>;


export type TriggerListUpdatedAtMutation = { __typename?: 'mutation_root', update_lists: { __typename?: 'lists_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'lists', id: number }> } | null };

export type GetListsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Lists_Order_By> | Lists_Order_By>;
  where: Lists_Bool_Exp;
}>;


export type GetListsQuery = { __typename?: 'query_root', lists: Array<{ __typename?: 'lists', id: number, name: string, description: string | null, total_no_of_resources: number | null, public: boolean | null, created_at: any | null, updated_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null } | null } | null, list_members: Array<{ __typename?: 'list_members', id: number, member_type: string, user_id: number, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null } | null } | null }> }>, lists_aggregate: { __typename?: 'lists_aggregate', aggregate: { __typename?: 'lists_aggregate_fields', count: number } | null } };

export type GetListQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetListQuery = { __typename?: 'query_root', lists: Array<{ __typename?: 'lists', id: number, name: string, description: string | null, total_no_of_resources: number | null, public: boolean | null, created_at: any | null, updated_at: any | null, created_by: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null } | null } | null, list_members: Array<{ __typename?: 'list_members', id: number, member_type: string, user_id: number, user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null } | null } | null }> }> };

export type GetNewsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<News_Order_By> | News_Order_By>;
  where: News_Bool_Exp;
}>;


export type GetNewsQuery = { __typename?: 'query_root', news: Array<{ __typename?: 'news', id: number, date: any | null, kind: string | null, link: string | null, source: any | null, created_at: any, status: string | null, text: string, metadata: any | null, updated_at: any, organizations: Array<{ __typename?: 'news_organizations', type: string | null, company: { __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null, tags: any | null } | null, vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', company: { __typename?: 'companies', tags: any | null } | null } | null }> } | null }> }>, news_aggregate: { __typename?: 'news_aggregate', aggregate: { __typename?: 'news_aggregate_fields', count: number } | null } };

export type GetNewsArticlesQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order: Order_By;
  where: News_Bool_Exp;
}>;


export type GetNewsArticlesQuery = { __typename?: 'query_root', news: Array<{ __typename?: 'news', id: number, date: any | null, kind: string | null, link: string | null, source: any | null, created_at: any, status: string | null, text: string, metadata: any | null, updated_at: any, organizations: Array<{ __typename?: 'news_organizations', type: string | null, company: { __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null } | null, vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null } | null }> }>, news_aggregate: { __typename?: 'news_aggregate', aggregate: { __typename?: 'news_aggregate_fields', count: number } | null } };

export type GetNewsByDateQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetNewsByDateQuery = { __typename?: 'query_root', news: Array<{ __typename?: 'news', id: number, date: any | null, link: string | null, text: string, source: any | null }> };

export type GetNotesQueryVariables = Exact<{
  where: Notes_Bool_Exp;
}>;


export type GetNotesQuery = { __typename?: 'query_root', notes: Array<{ __typename?: 'notes', id: number, notes: string, created_by: number, created_at: any, updated_at: any | null, user_group_id: number | null, audience: string | null, resource_type: string | null, resource_id: number | null, user_group: { __typename?: 'user_groups', id: number, name: string } | null, created_by_user: { __typename?: 'users_public', id: number | null, display_name: string | null, person: { __typename?: 'people', slug: string, name: string | null, picture: any | null } | null } | null, likes: Array<{ __typename?: 'likes', id: number, created_at: any, created_by_user_id: number, created_by_user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null } | null } | null }>, comments: Array<{ __typename?: 'comments', id: number, content: string, created_at: any, created_by_user_id: number, created_by_user: { __typename?: 'users_public', id: number | null, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null } | null } | null }> }> };

export type GetNoteByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetNoteByIdQuery = { __typename?: 'query_root', notes: Array<{ __typename?: 'notes', id: number, notes: string, created_by: number, created_at: any, resource_type: string | null, resource_id: number | null, user_group_id: number | null, user_group: { __typename?: 'user_groups', id: number, name: string } | null }> };

export type DeleteNotesByGroupIdMutationVariables = Exact<{
  groupId: Scalars['Int'];
}>;


export type DeleteNotesByGroupIdMutation = { __typename?: 'mutation_root', delete_notes: { __typename?: 'notes_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'notes', id: number }> } | null };

export type InsertNoteMutationVariables = Exact<{
  object: Notes_Insert_Input;
}>;


export type InsertNoteMutation = { __typename?: 'mutation_root', insert_notes_one: { __typename?: 'notes', id: number, notes: string, created_by: number, created_at: any, resource_type: string | null, resource_id: number | null, user_group_id: number | null, user_group: { __typename?: 'user_groups', id: number, name: string } | null } | null };

export type UpdateNoteMutationVariables = Exact<{
  id: Scalars['Int'];
  notes: Scalars['String'];
}>;


export type UpdateNoteMutation = { __typename?: 'mutation_root', update_notes: { __typename?: 'notes_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'notes', id: number, notes: string, created_by: number, created_at: any, resource_type: string | null, resource_id: number | null, user_group_id: number | null, user_group: { __typename?: 'user_groups', id: number, name: string } | null }> } | null };

export type DeleteNoteByIdMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteNoteByIdMutation = { __typename?: 'mutation_root', delete_notes: { __typename?: 'notes_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'notes', id: number }> } | null };

export type InsertLikesMutationVariables = Exact<{
  object: Likes_Insert_Input;
}>;


export type InsertLikesMutation = { __typename?: 'mutation_root', insert_likes_one: { __typename?: 'likes', id: number } | null };

export type DeleteLikesMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteLikesMutation = { __typename?: 'mutation_root', delete_likes: { __typename?: 'likes_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'likes', id: number }> } | null };

export type InsertCommentsMutationVariables = Exact<{
  object: Comments_Insert_Input;
}>;


export type InsertCommentsMutation = { __typename?: 'mutation_root', insert_comments_one: { __typename?: 'comments', id: number } | null };

export type DeleteCommentOneMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteCommentOneMutation = { __typename?: 'mutation_root', delete_comments: { __typename?: 'comments_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'comments', id: number }> } | null };

export type DeleteLikesByNoteIdMutationVariables = Exact<{
  note_id: Scalars['Int'];
}>;


export type DeleteLikesByNoteIdMutation = { __typename?: 'mutation_root', delete_likes: { __typename?: 'likes_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'likes', id: number }> } | null };

export type DeleteCommentsByNoteIdMutationVariables = Exact<{
  note_id: Scalars['Int'];
}>;


export type DeleteCommentsByNoteIdMutation = { __typename?: 'mutation_root', delete_comments: { __typename?: 'comments_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'comments', id: number }> } | null };

export type FindNoteLikesOneQueryVariables = Exact<{
  note_id: Scalars['Int'];
  user_id: Scalars['Int'];
}>;


export type FindNoteLikesOneQuery = { __typename?: 'query_root', likes: Array<{ __typename?: 'likes', id: number }> };

export type FindCommentByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type FindCommentByIdQuery = { __typename?: 'query_root', comments: Array<{ __typename?: 'comments', id: number, created_by_user_id: number }> };

export type GetNotificationsForUserQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  user: Scalars['Int'];
}>;


export type GetNotificationsForUserQuery = { __typename?: 'query_root', notifications: Array<{ __typename?: 'notifications', id: number, read: boolean, created_at: any, event_type: string, message: string | null, read_at: any | null, follow_resource_type: string, notification_resource_type: string, company: { __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null } | null, vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null } | null, notification_actions: Array<{ __typename?: 'notification_actions', id: number, action_id: number, action: { __typename?: 'actions', id: number, properties: any } | null }> }>, notifications_aggregate: { __typename?: 'notifications_aggregate', aggregate: { __typename?: 'notifications_aggregate_fields', count: number } | null } };

export type InsertNotificationsMutationVariables = Exact<{
  object: Notifications_Insert_Input;
}>;


export type InsertNotificationsMutation = { __typename?: 'mutation_root', insert_notifications_one: { __typename?: 'notifications', id: number, target_user_id: number, event_type: string, follow_resource_type: string, notification_resource_type: string, company_id: number | null, vc_firm_id: number | null, message: string | null, read_at: any | null, created_at: any, updated_at: any, read: boolean } | null };

export type MarkNotificationsAsReadMutationVariables = Exact<{
  where: Notifications_Bool_Exp;
}>;


export type MarkNotificationsAsReadMutation = { __typename?: 'mutation_root', update_notifications: { __typename?: 'notifications_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'notifications', id: number }> } | null };

export type InsertNotificationActionsMutationVariables = Exact<{
  object: Notification_Actions_Insert_Input;
}>;


export type InsertNotificationActionsMutation = { __typename?: 'mutation_root', insert_notification_actions_one: { __typename?: 'notification_actions', id: number } | null };

export type GetUnreadNotificationsQueryVariables = Exact<{
  user_id: Scalars['Int'];
}>;


export type GetUnreadNotificationsQuery = { __typename?: 'query_root', notifications_aggregate: { __typename?: 'notifications_aggregate', aggregate: { __typename?: 'notifications_aggregate_fields', count: number } | null } };

export type GetPersonQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetPersonQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, library: any | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, web3_address: any | null, twitter_url: string | null, discord: string | null, telegram: string | null, github: string | null, location_json: any | null, facebook_url: string | null, website_url: string | null, about: string | null, email: any | null, investors: Array<{ __typename?: 'investors', id: number, end_date: any | null, start_date: any | null, function: string | null, title: string | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null, tags: any | null } | null }>, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null, tags: any | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, tags: any | null } | null, investments: Array<{ __typename?: 'investments', id: number, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null } | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null } | null }> } | null }>, news_links: Array<{ __typename?: 'news_person', id: number, news: { __typename?: 'news', id: number, date: any | null, text: string, link: string | null, kind: string | null, source: any | null, status: string | null, people: Array<{ __typename?: 'news_person', id: number, type: string | null, person_id: number | null }> } | null }>, user: { __typename?: 'users_public', id: number | null } | null, follows: Array<{ __typename?: 'follows_people', id: number | null, list_id: number | null }>, people_computed_data: { __typename?: 'people_computed_data', title: string | null, tags: any | null, person_id: number, location_json: any | null, geopoint: any | null, id: number } | null }> };

export type PeopleFragmentFragment = { __typename?: 'people', id: number, created_at: any, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, location_json: any | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, investors: Array<{ __typename?: 'investors', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, follows: Array<{ __typename?: 'follows_people', id: number | null, list_id: number | null }>, people_computed_data: { __typename?: 'people_computed_data', title: string | null, tags: any | null, person_id: number, location_json: any | null, geopoint: any | null, id: number } | null };

export type GetPeopleByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetPeopleByIdQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, created_at: any, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, location_json: any | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, investors: Array<{ __typename?: 'investors', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, follows: Array<{ __typename?: 'follows_people', id: number | null, list_id: number | null }>, people_computed_data: { __typename?: 'people_computed_data', title: string | null, tags: any | null, person_id: number, location_json: any | null, geopoint: any | null, id: number } | null }> };

export type GetPeopleQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<People_Order_By> | People_Order_By>;
  where: People_Bool_Exp;
}>;


export type GetPeopleQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, created_at: any, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, location_json: any | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, investors: Array<{ __typename?: 'investors', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, location_json: any | null, tags: any | null, website: string | null } | null }>, follows: Array<{ __typename?: 'follows_people', id: number | null, list_id: number | null }>, people_computed_data: { __typename?: 'people_computed_data', title: string | null, tags: any | null, person_id: number, location_json: any | null, geopoint: any | null, id: number } | null }>, people_aggregate: { __typename?: 'people_aggregate', aggregate: { __typename?: 'people_aggregate_fields', count: number } | null } };

export type GetAllPersonsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllPersonsQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null }> };

export type SearchPeopleQueryVariables = Exact<{
  query: InputMaybe<Scalars['String']>;
  searchText: InputMaybe<Scalars['jsonb']>;
}>;


export type SearchPeopleQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, display_name: string | null, email: string | null, person: { __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string } | null }> };

export type GetPeopleByDateQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetPeopleByDateQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, work_email: string | null, personal_email: string | null, picture: any | null, slug: string }> };

export type GetDraftPeopleQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetDraftPeopleQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number }> };

export type UpdatePeopleByPkMutationVariables = Exact<{
  set: InputMaybe<People_Set_Input>;
  id: Scalars['Int'];
}>;


export type UpdatePeopleByPkMutation = { __typename?: 'mutation_root', update_people_by_pk: { __typename?: 'people', id: number, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, location_json: any | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, about: string | null, email: any | null, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null } | null } | null }> } | null };

export type FindPeopleByNameAndEmailQueryVariables = Exact<{
  name: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
}>;


export type FindPeopleByNameAndEmailQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string, user: { __typename?: 'users_public', id: number | null } | null }> };

export type FindPeopleByLinkedinUrlQueryVariables = Exact<{
  linkedin: InputMaybe<Scalars['String']>;
}>;


export type FindPeopleByLinkedinUrlQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string }> };

export type InsertOnboardingClaimProfileMutationVariables = Exact<{
  object: People_Insert_Input;
}>;


export type InsertOnboardingClaimProfileMutation = { __typename?: 'mutation_root', insert_people_one: { __typename?: 'people', id: number, name: string | null, work_email: string | null, linkedin: string | null } | null };

export type FindPeopleByEmailQueryVariables = Exact<{
  query: InputMaybe<Scalars['String']>;
}>;


export type FindPeopleByEmailQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string, work_email: string | null, personal_email: string | null }> };

export type GetSignUpProfileQueryVariables = Exact<{
  email: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
}>;


export type GetSignUpProfileQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, picture: any | null, slug: string, website_url: string | null, linkedin: string | null, twitter_url: string | null, github: string | null, facebook_url: string | null }> };

export type InsertPeopleMutationVariables = Exact<{
  objects: Array<People_Insert_Input> | People_Insert_Input;
}>;


export type InsertPeopleMutation = { __typename?: 'mutation_root', insert_people: { __typename?: 'people_mutation_response', returning: Array<{ __typename?: 'people', id: number, status: string, linkedin: string | null, slug: string, enrichment_priority: number }> } | null };

export type GetPeopleByTagsAndLocationQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  where: People_Bool_Exp;
}>;


export type GetPeopleByTagsAndLocationQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number }> };

export type GetPeopleComputedByPersonIdQueryVariables = Exact<{
  personId: Scalars['Int'];
}>;


export type GetPeopleComputedByPersonIdQuery = { __typename?: 'query_root', people_computed_data: Array<{ __typename?: 'people_computed_data', geopoint: any | null, location_json: any | null, person_id: number }> };

export type InsertResetPasswordMutationVariables = Exact<{
  object: Reset_Passwords_Insert_Input;
}>;


export type InsertResetPasswordMutation = { __typename?: 'mutation_root', insert_reset_passwords_one: { __typename?: 'reset_passwords', id: number, user_id: number, generated_password: string, created_at: any } | null };

export type InsertEditAccessMutationVariables = Exact<{
  userId: InputMaybe<Scalars['Int']>;
  resourceId: InputMaybe<Scalars['Int']>;
  resourceType: InputMaybe<Scalars['String']>;
}>;


export type InsertEditAccessMutation = { __typename?: 'mutation_root', insert_resource_edit_access_one: { __typename?: 'resource_edit_access', id: number, user_id: number, resource_id: number, resource_type: string } | null };

export type GetEventsPathsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
}>;


export type GetEventsPathsQuery = { __typename?: 'query_root', events: Array<{ __typename?: 'events', id: number, name: string, slug: string, updated_at: any }> };

export type GetCompaniesPathsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
}>;


export type GetCompaniesPathsQuery = { __typename?: 'query_root', companies: Array<{ __typename?: 'companies', id: number, name: string | null, slug: string, updated_at: any }> };

export type GetPersonsPathQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
}>;


export type GetPersonsPathQuery = { __typename?: 'query_root', people: Array<{ __typename?: 'people', id: number, name: string | null, slug: string, updated_at: any | null }> };

export type GetVcFirmsPathQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
}>;


export type GetVcFirmsPathQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, slug: string, updated_at: any | null }> };

export type GetSiteMapAggregatesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSiteMapAggregatesQuery = { __typename?: 'query_root', companies_aggregate: { __typename?: 'companies_aggregate', aggregate: { __typename?: 'companies_aggregate_fields', count: number } | null }, events_aggregate: { __typename?: 'events_aggregate', aggregate: { __typename?: 'events_aggregate_fields', count: number } | null }, people_aggregate: { __typename?: 'people_aggregate', aggregate: { __typename?: 'people_aggregate_fields', count: number } | null }, vc_firms_aggregate: { __typename?: 'vc_firms_aggregate', aggregate: { __typename?: 'vc_firms_aggregate_fields', count: number } | null } };

export type UpsertTeamMemberMutationVariables = Exact<{
  data: Team_Members_Insert_Input;
}>;


export type UpsertTeamMemberMutation = { __typename?: 'mutation_root', insert_team_members_one: { __typename?: 'team_members', id: number, function: string | null, person_id: number | null, company_id: number | null, title: string | null, start_date: any | null, end_date: any | null, seniority: string | null } | null };

export type InsertTeamMemberMutationVariables = Exact<{
  personId: InputMaybe<Scalars['Int']>;
  companyId: InputMaybe<Scalars['Int']>;
  vcFirmId: InputMaybe<Scalars['Int']>;
}>;


export type InsertTeamMemberMutation = { __typename?: 'mutation_root', insert_team_members_one: { __typename?: 'team_members', id: number } | null };

export type GetTeamMemberByPersonIdQueryVariables = Exact<{
  person_id: Scalars['Int'];
}>;


export type GetTeamMemberByPersonIdQuery = { __typename?: 'query_root', team_members: Array<{ __typename?: 'team_members', id: number, company_id: number | null }> };

export type GetTeamMemberByCompanyIdsQueryVariables = Exact<{
  company_ids: InputMaybe<Array<Scalars['Int']> | Scalars['Int']>;
}>;


export type GetTeamMemberByCompanyIdsQuery = { __typename?: 'query_root', team_members: Array<{ __typename?: 'team_members', id: number, company_id: number | null, person_id: number | null, company: { __typename?: 'companies', id: number, name: string | null, slug: string, logo: any | null } | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null, personal_email: string | null, work_email: string | null } | null }> };

export type GetTeamMemberByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetTeamMemberByIdQuery = { __typename?: 'query_root', team_members: Array<{ __typename?: 'team_members', id: number, company_id: number | null, person: { __typename?: 'people', id: number, name: string | null, slug: string, picture: any | null, personal_email: string | null, work_email: string | null, status: string } | null }> };

export type GetTeamMembersQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Team_Members_Order_By> | Team_Members_Order_By>;
  where: Team_Members_Bool_Exp;
}>;


export type GetTeamMembersQuery = { __typename?: 'query_root', team_members: Array<{ __typename?: 'team_members', id: number, company_id: number | null, function: string | null, start_date: any | null, end_date: any | null, founder: boolean | null, title: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null, linkedin: string | null, personal_email: string | null, work_email: string | null } | null }>, team_members_aggregate: { __typename?: 'team_members_aggregate', aggregate: { __typename?: 'team_members_aggregate_fields', count: number } | null } };

export type GetInvestorsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Investors_Order_By> | Investors_Order_By>;
  where: Investors_Bool_Exp;
}>;


export type GetInvestorsQuery = { __typename?: 'query_root', investors: Array<{ __typename?: 'investors', id: number, vc_firm_id: number | null, function: string | null, start_date: any | null, end_date: any | null, founder: boolean | null, title: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null, linkedin: string | null, personal_email: string | null, work_email: string | null } | null }>, investors_aggregate: { __typename?: 'investors_aggregate', aggregate: { __typename?: 'investors_aggregate_fields', count: number } | null } };

export type InsertUserTransactionMutationVariables = Exact<{
  object: User_Transactions_Insert_Input;
}>;


export type InsertUserTransactionMutation = { __typename?: 'mutation_root', insert_user_transactions_one: { __typename?: 'user_transactions', user_id: number, amount: number, note: string | null } | null };

export type GetUserProfileQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserProfileQuery = { __typename?: 'query_root', users_by_pk: { __typename?: 'users', id: number, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, preferences: any, billing_org: { __typename?: 'billing_org', status: string } | null, organization_companies: Array<{ __typename?: 'companies_edit_access', id: number | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, organization_vc_firms: Array<{ __typename?: 'vc_firms_edit_access', id: number | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, person: { __typename?: 'people', id: number, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, city: string | null, country: string | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, about: string | null, email: any | null, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null } | null } | null }> } | null } | null };

export type GetUserByPersonIdQueryVariables = Exact<{
  person_id: Scalars['Int'];
}>;


export type GetUserByPersonIdQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, organization_companies: Array<{ __typename?: 'companies_edit_access', id: number | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, organization_vc_firms: Array<{ __typename?: 'vc_firms_edit_access', id: number | null, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, person: { __typename?: 'people', id: number, name: string | null, personal_email: string | null, picture: any | null, slug: string, status: string, type: string | null, work_email: string | null, linkedin: string | null, github: string | null, city: string | null, country: string | null, facebook_url: string | null, twitter_url: string | null, website_url: string | null, about: string | null, email: any | null, team_members: Array<{ __typename?: 'team_members', id: number, end_date: any | null, start_date: any | null, founder: boolean | null, function: string | null, title: string | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null, overview: string | null, location_json: any | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, logo: any | null } | null } | null }> } | null }> };

export type GetUserByPkQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetUserByPkQuery = { __typename?: 'query_root', users_by_pk: { __typename?: 'users', id: number, additional_emails: any, email: string | null } | null };

export type UpdateUserAdditionalEmailsByPkMutationVariables = Exact<{
  userId: Scalars['Int'];
  emails: InputMaybe<Scalars['jsonb']>;
}>;


export type UpdateUserAdditionalEmailsByPkMutation = { __typename?: 'mutation_root', update_users_by_pk: { __typename?: 'users', id: number } | null };

export type GetUserByEmailQueryVariables = Exact<{
  email: InputMaybe<Scalars['String']>;
}>;


export type GetUserByEmailQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, onboarding_information: any | null, feature_flags: any, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> };

export type GetUserByIdQueryVariables = Exact<{
  id: InputMaybe<Scalars['Int']>;
}>;


export type GetUserByIdQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, use_credits_system: boolean, credits: any | null, billing_org_id: number | null, additional_emails: any, onboarding_information: any | null, feature_flags: any, preferences: any, billing_org: { __typename?: 'billing_org', customer_id: string, status: string } | null, person: { __typename?: 'people', name: string | null, picture: any | null } | null }> };

export type UserForTokenFragment = { __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, onboarding_information: any | null, feature_flags: any, preferences: any, active: boolean, billing_org: { __typename?: 'billing_org', customer_id: string, status: string } | null, person: { __typename?: 'people', id: number, name: string | null, picture: any | null } | null };

export type GetUserByIdForTokenQueryVariables = Exact<{
  id: InputMaybe<Scalars['Int']>;
}>;


export type GetUserByIdForTokenQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, onboarding_information: any | null, feature_flags: any, preferences: any, active: boolean, billing_org: { __typename?: 'billing_org', customer_id: string, status: string } | null, person: { __typename?: 'people', id: number, name: string | null, picture: any | null } | null }> };

export type GetUserByEmailForTokenQueryVariables = Exact<{
  email: Scalars['String'];
}>;


export type GetUserByEmailForTokenQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, onboarding_information: any | null, feature_flags: any, preferences: any, active: boolean, billing_org: { __typename?: 'billing_org', customer_id: string, status: string } | null, person: { __typename?: 'people', id: number, name: string | null, picture: any | null } | null }> };

export type UpdateUserBillingOrgMutationVariables = Exact<{
  userId: Scalars['Int'];
  billingOrgId: Scalars['Int'];
}>;


export type UpdateUserBillingOrgMutation = { __typename?: 'mutation_root', update_users_by_pk: { __typename?: 'users', id: number } | null };

export type UpdateUserUseCreditsSystemMutationVariables = Exact<{
  user_id: Scalars['Int'];
  use_credits_system: InputMaybe<Scalars['Boolean']>;
}>;


export type UpdateUserUseCreditsSystemMutation = { __typename?: 'mutation_root', update_users_by_pk: { __typename?: 'users', id: number } | null };

export type UpdateUserExpirationOfLastValidTransactionMutationVariables = Exact<{
  user_id: Scalars['Int'];
  last_transaction_expiration: InputMaybe<Scalars['timestamptz']>;
}>;


export type UpdateUserExpirationOfLastValidTransactionMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number } | null };

export type UpsertUsersMutationVariables = Exact<{
  external_id: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['String']>;
  role: InputMaybe<Scalars['String']>;
  display_name: InputMaybe<Scalars['String']>;
  auth0_linkedin_id: InputMaybe<Scalars['String']>;
  auth0_user_pass_id: InputMaybe<Scalars['String']>;
  reference_user_id: InputMaybe<Scalars['Int']>;
}>;


export type UpsertUsersMutation = { __typename?: 'mutation_root', insert_users: { __typename?: 'users_mutation_response', returning: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type UpdateUserEmailVerifiedStatusMutationVariables = Exact<{
  email: Scalars['String'];
  is_auth0_verified: InputMaybe<Scalars['Boolean']>;
}>;


export type UpdateUserEmailVerifiedStatusMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type UpdateUserAuth0LinkedInIdMutationVariables = Exact<{
  email: Scalars['String'];
  auth0_linkedin_id: InputMaybe<Scalars['String']>;
}>;


export type UpdateUserAuth0LinkedInIdMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, onboarding_information: any | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type UpdateUserAuth0UserPassIdMutationVariables = Exact<{
  email: Scalars['String'];
  auth0_user_pass_id: InputMaybe<Scalars['String']>;
}>;


export type UpdateUserAuth0UserPassIdMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type GetUserByReferenceIdQueryVariables = Exact<{
  reference_id: InputMaybe<Scalars['String']>;
}>;


export type GetUserByReferenceIdQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> };

export type UpdateUserAdditionalEmailsMutationVariables = Exact<{
  id: Scalars['Int'];
  additional_emails: InputMaybe<Scalars['jsonb']>;
}>;


export type UpdateUserAdditionalEmailsMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type GetUserByAdditionalEmailQueryVariables = Exact<{
  email: InputMaybe<Scalars['jsonb']>;
}>;


export type GetUserByAdditionalEmailQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, role: string | null, external_id: string | null, is_auth0_verified: boolean | null, display_name: string | null, auth0_linkedin_id: string | null, auth0_user_pass_id: string | null, reference_id: string, credits: any | null, use_credits_system: boolean, last_transaction_expiration: any | null, billing_org_id: number | null, additional_emails: any, active: boolean, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> };

export type UpdateUserOnboardingInformationMutationVariables = Exact<{
  id: Scalars['Int'];
  onboarding_information: InputMaybe<Scalars['jsonb']>;
}>;


export type UpdateUserOnboardingInformationMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, display_name: string | null, onboarding_information: any | null, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type UpdateUserPersonIdMutationVariables = Exact<{
  id: Scalars['Int'];
  person_id: Scalars['Int'];
}>;


export type UpdateUserPersonIdMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, display_name: string | null, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type GetUserByPersonIdsQueryVariables = Exact<{
  person_ids: InputMaybe<Array<Scalars['Int']> | Scalars['Int']>;
}>;


export type GetUserByPersonIdsQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: number, email: string | null, display_name: string | null, person_id: number | null }> };

export type UpdateUserFeatureFlagsMutationVariables = Exact<{
  id: Scalars['Int'];
  feature_flags: InputMaybe<Scalars['jsonb']>;
}>;


export type UpdateUserFeatureFlagsMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, display_name: string | null, feature_flags: any, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type UpdateUserPreferencesMutationVariables = Exact<{
  id: Scalars['Int'];
  preferences: Scalars['jsonb'];
}>;


export type UpdateUserPreferencesMutation = { __typename?: 'mutation_root', update_users: { __typename?: 'users_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'users', id: number, email: string | null, display_name: string | null, preferences: any, person: { __typename?: 'people', name: string | null, picture: any | null, slug: string, id: number } | null }> } | null };

export type GetVcFirmQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetVcFirmQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null, website: string | null, linkedin: string | null, sentiment: any | null, tags: any | null, overview: string | null, year_founded: string | null, location_json: any | null, twitter: string | null, discord: string | null, github: string | null, telegram: string | null, library: any | null, investors: Array<{ __typename?: 'investors', id: number, function: string | null, start_date: any | null, end_date: any | null, seniority: string | null, founder: boolean | null, title: string | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null, linkedin: string | null, personal_email: string | null, work_email: string | null } | null }>, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null, company: { __typename?: 'companies', id: number, slug: string, name: string | null, tags: any | null, logo: any | null } | null, investments: Array<{ __typename?: 'investments', id: number, vc_firm: { __typename?: 'vc_firms', id: number, slug: string, name: string | null, logo: any | null } | null, person: { __typename?: 'people', id: number, slug: string, name: string | null, picture: any | null } | null }> } | null }>, to_links: Array<{ __typename?: 'resource_links', link_type: string, from_company: { __typename?: 'companies', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> } | null, from_vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> } | null }>, from_links: Array<{ __typename?: 'resource_links', link_type: string, to_company: { __typename?: 'companies', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, overview: string | null, logo: any | null, total_employees: any | null, investor_amount: any | null, year_founded: string | null, investment_rounds_aggregate: { __typename?: 'investment_rounds_aggregate', aggregate: { __typename?: 'investment_rounds_aggregate_fields', count: number } | null }, investment_rounds: Array<{ __typename?: 'investment_rounds', round: string | null, round_date: any | null }>, follows: Array<{ __typename?: 'follows_companies', id: number | null, list_id: number | null }> } | null, to_vc_firm: { __typename?: 'vc_firms', id: number, name: string | null, slug: string, tags: any | null, sentiment: any | null, year_founded: string | null, investment_amount_total: any | null, num_of_investments: number | null, overview: string | null, logo: any | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> } | null }>, news_links: Array<{ __typename?: 'news_organizations', id: number, news: { __typename?: 'news', id: number, date: any | null, text: string, link: string | null, kind: string | null, source: any | null, status: string | null, organizations: Array<{ __typename?: 'news_organizations', id: number, type: string | null, company_id: number | null, vc_firm_id: number | null }> } | null }>, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> }> };

export type GetVcFirmsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Vc_Firms_Order_By> | Vc_Firms_Order_By>;
  where: Vc_Firms_Bool_Exp;
}>;


export type GetVcFirmsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null, location_json: any | null, tags: any | null, overview: string | null, website: string | null, num_of_investments: number | null, year_founded: string | null, sentiment: any | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> }>, vc_firms_aggregate: { __typename?: 'vc_firms_aggregate', aggregate: { __typename?: 'vc_firms_aggregate_fields', count: number } | null } };

export type GetVcFirmsRecentInvestmentsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  where: Vc_Firms_Bool_Exp;
}>;


export type GetVcFirmsRecentInvestmentsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, slug: string, logo: any | null, tags: any | null, latest_investment: any | null, num_of_investments: number | null, sentiment: any | null, overview: string | null, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', id: number, round_date: any | null, round: string | null, amount: any | null } | null }>, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> }> };

export type GetRelevantVcFirmsQueryVariables = Exact<{
  where: Vc_Firms_Bool_Exp;
  limit: InputMaybe<Scalars['Int']>;
}>;


export type GetRelevantVcFirmsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, logo: any | null, name: string | null, slug: string, sentiment: any | null }> };

export type GetAllVcFirmsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllVcFirmsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, logo: any | null, slug: string }> };

export type GetSentimentByVcFirmIdQueryVariables = Exact<{
  vcFirmId: Scalars['Int'];
}>;


export type GetSentimentByVcFirmIdQuery = { __typename?: 'query_root', vc_firms_by_pk: { __typename?: 'vc_firms', sentiment: any | null, slug: string } | null };

export type UpdateSentimentByVcFirmIdMutationVariables = Exact<{
  vcFirmId: Scalars['Int'];
  sentiment: Scalars['jsonb'];
}>;


export type UpdateSentimentByVcFirmIdMutation = { __typename?: 'mutation_root', update_vc_firms_by_pk: { __typename?: 'vc_firms', sentiment: any | null } | null };

export type GetVcFirmsByDateQueryVariables = Exact<{
  date: InputMaybe<Scalars['timestamptz']>;
  library: InputMaybe<Scalars['jsonb']>;
}>;


export type GetVcFirmsByDateQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, logo: any | null, slug: string }> };

export type UpdateVcFirmTagsByPkMutationVariables = Exact<{
  id: Scalars['Int'];
  tags: InputMaybe<Scalars['jsonb']>;
}>;


export type UpdateVcFirmTagsByPkMutation = { __typename?: 'mutation_root', update_vc_firms_by_pk: { __typename?: 'vc_firms', id: number } | null };

export type GetVcFirmsInvestmentsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetVcFirmsInvestmentsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, investments: Array<{ __typename?: 'investments', investment_round: { __typename?: 'investment_rounds', company: { __typename?: 'companies', id: number, tags: any | null } | null } | null }> }> };

export type GetVcFirmByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetVcFirmByIdQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, name: string | null, status: string }> };

export type GetVcFirmInsightByLocationQueryVariables = Exact<{
  where: Vc_Firms_Bool_Exp;
}>;


export type GetVcFirmInsightByLocationQuery = { __typename?: 'query_root', vc_firms_aggregate: { __typename?: 'vc_firms_aggregate', aggregate: { __typename?: 'vc_firms_aggregate_fields', count: number } | null } };

export type GetPersonalizedVcFirmsQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  orderBy: InputMaybe<Array<Vc_Firms_Order_By> | Vc_Firms_Order_By>;
  where: Vc_Firms_Bool_Exp;
}>;


export type GetPersonalizedVcFirmsQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number, slug: string, logo: any | null, name: string | null, num_of_investments: number | null, year_founded: string | null, investment_amount_total: any | null, tags: any | null, location_json: any | null, overview: string | null, website: string | null, linkedin: string | null, twitter: string | null, follows: Array<{ __typename?: 'follows_vc_firms', id: number | null, list_id: number | null }> }>, vc_firms_aggregate: { __typename?: 'vc_firms_aggregate', aggregate: { __typename?: 'vc_firms_aggregate_fields', count: number } | null } };

export type GetVcFirmsByTagsAndLocationQueryVariables = Exact<{
  limit: InputMaybe<Scalars['Int']>;
  where: Vc_Firms_Bool_Exp;
}>;


export type GetVcFirmsByTagsAndLocationQuery = { __typename?: 'query_root', vc_firms: Array<{ __typename?: 'vc_firms', id: number }> };

export type UpsertWaitlistEmailMutationVariables = Exact<{
  email: InputMaybe<Scalars['String']>;
}>;


export type UpsertWaitlistEmailMutation = { __typename?: 'mutation_root', insert_waitlist_emails: { __typename?: 'waitlist_emails_mutation_response', returning: Array<{ __typename?: 'waitlist_emails', id: number, email: string }> } | null };

export const PeopleFragmentFragmentDoc = `
    fragment PeopleFragment on people {
  id
  created_at
  name
  personal_email
  picture
  slug
  status
  type
  work_email
  linkedin
  github
  location_json
  facebook_url
  twitter_url
  website_url
  investors(
    limit: 1
    order_by: {start_date: desc_nulls_last, end_date: desc_nulls_first}
  ) {
    id
    end_date
    start_date
    founder
    function
    title
    vc_firm {
      id
      slug
      name
      logo
      location_json
      tags
      website
    }
  }
  team_members(
    limit: 1
    order_by: {start_date: desc_nulls_last, end_date: desc_nulls_first}
  ) {
    id
    end_date
    start_date
    founder
    function
    title
    company {
      id
      slug
      name
      logo
      location_json
      tags
      website
    }
  }
  follows {
    id
    list_id
  }
  people_computed_data {
    title
    tags
    person_id
    location_json
    geopoint
    id
  }
}
    `;
export const UserForTokenFragmentDoc = `
    fragment UserForToken on users {
  id
  email
  role
  external_id
  is_auth0_verified
  display_name
  auth0_linkedin_id
  auth0_user_pass_id
  reference_id
  credits
  use_credits_system
  last_transaction_expiration
  billing_org_id
  billing_org {
    customer_id
    status
  }
  person {
    id
    name
    picture
  }
  additional_emails
  onboarding_information
  feature_flags
  preferences
  active
}
    `;
export const InsertActionDocument = `
    mutation InsertAction($object: actions_insert_input!) {
  insert_actions_one(object: $object) {
    id
  }
}
    `;
export const useInsertActionMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertActionMutation, TError, InsertActionMutationVariables, TContext>) =>
    useMutation<InsertActionMutation, TError, InsertActionMutationVariables, TContext>(
      ['InsertAction'],
      (variables?: InsertActionMutationVariables) => fetcher<InsertActionMutation, InsertActionMutationVariables>(InsertActionDocument, variables)(),
      options
    );
useInsertActionMutation.fetcher = (variables: InsertActionMutationVariables, options?: RequestInit['headers']) => fetcher<InsertActionMutation, InsertActionMutationVariables>(InsertActionDocument, variables, options);
export const GetDeleteDataActionsDocument = `
    query GetDeleteDataActions($resourceType: String!, $date: timestamptz) {
  actions(
    where: {_and: [{action: {_eq: "Delete Data"}}, {resource: {_eq: $resourceType}}, {created_at: {_gte: $date}}]}
  ) {
    resource_id
  }
}
    `;
export const useGetDeleteDataActionsQuery = <
      TData = GetDeleteDataActionsQuery,
      TError = Error
    >(
      variables: GetDeleteDataActionsQueryVariables,
      options?: UseQueryOptions<GetDeleteDataActionsQuery, TError, TData>
    ) =>
    useQuery<GetDeleteDataActionsQuery, TError, TData>(
      ['GetDeleteDataActions', variables],
      fetcher<GetDeleteDataActionsQuery, GetDeleteDataActionsQueryVariables>(GetDeleteDataActionsDocument, variables),
      options
    );
useGetDeleteDataActionsQuery.document = GetDeleteDataActionsDocument;


useGetDeleteDataActionsQuery.getKey = (variables: GetDeleteDataActionsQueryVariables) => ['GetDeleteDataActions', variables];
;

useGetDeleteDataActionsQuery.fetcher = (variables: GetDeleteDataActionsQueryVariables, options?: RequestInit['headers']) => fetcher<GetDeleteDataActionsQuery, GetDeleteDataActionsQueryVariables>(GetDeleteDataActionsDocument, variables, options);
export const GetAllowedEmailByEmailOrDomainDocument = `
    query GetAllowedEmailByEmailOrDomain($email: String, $domain: String) {
  allowed_emails(
    where: {_or: [{email: {_eq: $email}, match_type: {_eq: "EMAIL"}}, {email: {_eq: $domain}, match_type: {_eq: "DOMAIN"}}]}
    limit: 1
  ) {
    id
    email
    person_id
  }
}
    `;
export const useGetAllowedEmailByEmailOrDomainQuery = <
      TData = GetAllowedEmailByEmailOrDomainQuery,
      TError = Error
    >(
      variables?: GetAllowedEmailByEmailOrDomainQueryVariables,
      options?: UseQueryOptions<GetAllowedEmailByEmailOrDomainQuery, TError, TData>
    ) =>
    useQuery<GetAllowedEmailByEmailOrDomainQuery, TError, TData>(
      variables === undefined ? ['GetAllowedEmailByEmailOrDomain'] : ['GetAllowedEmailByEmailOrDomain', variables],
      fetcher<GetAllowedEmailByEmailOrDomainQuery, GetAllowedEmailByEmailOrDomainQueryVariables>(GetAllowedEmailByEmailOrDomainDocument, variables),
      options
    );
useGetAllowedEmailByEmailOrDomainQuery.document = GetAllowedEmailByEmailOrDomainDocument;


useGetAllowedEmailByEmailOrDomainQuery.getKey = (variables?: GetAllowedEmailByEmailOrDomainQueryVariables) => variables === undefined ? ['GetAllowedEmailByEmailOrDomain'] : ['GetAllowedEmailByEmailOrDomain', variables];
;

useGetAllowedEmailByEmailOrDomainQuery.fetcher = (variables?: GetAllowedEmailByEmailOrDomainQueryVariables, options?: RequestInit['headers']) => fetcher<GetAllowedEmailByEmailOrDomainQuery, GetAllowedEmailByEmailOrDomainQueryVariables>(GetAllowedEmailByEmailOrDomainDocument, variables, options);
export const GetLastSyncDocument = `
    query GetLastSync {
  application_meta(
    where: {key: {_in: ["sync_web3_companies", "sync_web3_vc_firms", "sync_web3_people", "sync_web3_events", "sync_web3_news", "sync_ai_companies", "sync_ai_vc_firms", "sync_ai_people", "sync_ai_events", "sync_ai_news"]}}
  ) {
    id
    key
    value
  }
}
    `;
export const useGetLastSyncQuery = <
      TData = GetLastSyncQuery,
      TError = Error
    >(
      variables?: GetLastSyncQueryVariables,
      options?: UseQueryOptions<GetLastSyncQuery, TError, TData>
    ) =>
    useQuery<GetLastSyncQuery, TError, TData>(
      variables === undefined ? ['GetLastSync'] : ['GetLastSync', variables],
      fetcher<GetLastSyncQuery, GetLastSyncQueryVariables>(GetLastSyncDocument, variables),
      options
    );
useGetLastSyncQuery.document = GetLastSyncDocument;


useGetLastSyncQuery.getKey = (variables?: GetLastSyncQueryVariables) => variables === undefined ? ['GetLastSync'] : ['GetLastSync', variables];
;

useGetLastSyncQuery.fetcher = (variables?: GetLastSyncQueryVariables, options?: RequestInit['headers']) => fetcher<GetLastSyncQuery, GetLastSyncQueryVariables>(GetLastSyncDocument, variables, options);
export const UpdateApplicationMetaValueDocument = `
    mutation UpdateApplicationMetaValue($value: timestamptz, $key: String!) {
  update_application_meta(
    where: {key: {_eq: $key}}
    _set: {value: $value, error: ""}
  ) {
    affected_rows
    returning {
      id
      key
      value
    }
  }
}
    `;
export const useUpdateApplicationMetaValueMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateApplicationMetaValueMutation, TError, UpdateApplicationMetaValueMutationVariables, TContext>) =>
    useMutation<UpdateApplicationMetaValueMutation, TError, UpdateApplicationMetaValueMutationVariables, TContext>(
      ['UpdateApplicationMetaValue'],
      (variables?: UpdateApplicationMetaValueMutationVariables) => fetcher<UpdateApplicationMetaValueMutation, UpdateApplicationMetaValueMutationVariables>(UpdateApplicationMetaValueDocument, variables)(),
      options
    );
useUpdateApplicationMetaValueMutation.fetcher = (variables: UpdateApplicationMetaValueMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateApplicationMetaValueMutation, UpdateApplicationMetaValueMutationVariables>(UpdateApplicationMetaValueDocument, variables, options);
export const UpdateApplicationMetaErrorDocument = `
    mutation UpdateApplicationMetaError($error: String, $key: String!) {
  update_application_meta(where: {key: {_eq: $key}}, _set: {error: $error}) {
    affected_rows
    returning {
      id
      key
      value
    }
  }
}
    `;
export const useUpdateApplicationMetaErrorMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateApplicationMetaErrorMutation, TError, UpdateApplicationMetaErrorMutationVariables, TContext>) =>
    useMutation<UpdateApplicationMetaErrorMutation, TError, UpdateApplicationMetaErrorMutationVariables, TContext>(
      ['UpdateApplicationMetaError'],
      (variables?: UpdateApplicationMetaErrorMutationVariables) => fetcher<UpdateApplicationMetaErrorMutation, UpdateApplicationMetaErrorMutationVariables>(UpdateApplicationMetaErrorDocument, variables)(),
      options
    );
useUpdateApplicationMetaErrorMutation.fetcher = (variables: UpdateApplicationMetaErrorMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateApplicationMetaErrorMutation, UpdateApplicationMetaErrorMutationVariables>(UpdateApplicationMetaErrorDocument, variables, options);
export const InsertBillingOrgDocument = `
    mutation InsertBillingOrg($customer_id: String, $status: String, $plan: String) {
  insert_billing_org_one(
    object: {customer_id: $customer_id, status: $status, plan: $plan, user_limit: 1}
  ) {
    id
  }
}
    `;
export const useInsertBillingOrgMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertBillingOrgMutation, TError, InsertBillingOrgMutationVariables, TContext>) =>
    useMutation<InsertBillingOrgMutation, TError, InsertBillingOrgMutationVariables, TContext>(
      ['InsertBillingOrg'],
      (variables?: InsertBillingOrgMutationVariables) => fetcher<InsertBillingOrgMutation, InsertBillingOrgMutationVariables>(InsertBillingOrgDocument, variables)(),
      options
    );
useInsertBillingOrgMutation.fetcher = (variables?: InsertBillingOrgMutationVariables, options?: RequestInit['headers']) => fetcher<InsertBillingOrgMutation, InsertBillingOrgMutationVariables>(InsertBillingOrgDocument, variables, options);
export const GetBillingOrgByCustomerIdDocument = `
    query GetBillingOrgByCustomerId($customerId: String!) {
  billing_org(where: {customer_id: {_eq: $customerId}}) {
    customer_id
    id
    plan
    status
    user_limit
  }
}
    `;
export const useGetBillingOrgByCustomerIdQuery = <
      TData = GetBillingOrgByCustomerIdQuery,
      TError = Error
    >(
      variables: GetBillingOrgByCustomerIdQueryVariables,
      options?: UseQueryOptions<GetBillingOrgByCustomerIdQuery, TError, TData>
    ) =>
    useQuery<GetBillingOrgByCustomerIdQuery, TError, TData>(
      ['GetBillingOrgByCustomerId', variables],
      fetcher<GetBillingOrgByCustomerIdQuery, GetBillingOrgByCustomerIdQueryVariables>(GetBillingOrgByCustomerIdDocument, variables),
      options
    );
useGetBillingOrgByCustomerIdQuery.document = GetBillingOrgByCustomerIdDocument;


useGetBillingOrgByCustomerIdQuery.getKey = (variables: GetBillingOrgByCustomerIdQueryVariables) => ['GetBillingOrgByCustomerId', variables];
;

useGetBillingOrgByCustomerIdQuery.fetcher = (variables: GetBillingOrgByCustomerIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetBillingOrgByCustomerIdQuery, GetBillingOrgByCustomerIdQueryVariables>(GetBillingOrgByCustomerIdDocument, variables, options);
export const GetBillingOrgByIdDocument = `
    query GetBillingOrgById($id: Int!) {
  billing_org(where: {id: {_eq: $id}}) {
    customer_id
    id
    plan
    status
    user_limit
  }
}
    `;
export const useGetBillingOrgByIdQuery = <
      TData = GetBillingOrgByIdQuery,
      TError = Error
    >(
      variables: GetBillingOrgByIdQueryVariables,
      options?: UseQueryOptions<GetBillingOrgByIdQuery, TError, TData>
    ) =>
    useQuery<GetBillingOrgByIdQuery, TError, TData>(
      ['GetBillingOrgById', variables],
      fetcher<GetBillingOrgByIdQuery, GetBillingOrgByIdQueryVariables>(GetBillingOrgByIdDocument, variables),
      options
    );
useGetBillingOrgByIdQuery.document = GetBillingOrgByIdDocument;


useGetBillingOrgByIdQuery.getKey = (variables: GetBillingOrgByIdQueryVariables) => ['GetBillingOrgById', variables];
;

useGetBillingOrgByIdQuery.fetcher = (variables: GetBillingOrgByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetBillingOrgByIdQuery, GetBillingOrgByIdQueryVariables>(GetBillingOrgByIdDocument, variables, options);
export const UpdateBillingOrgDocument = `
    mutation UpdateBillingOrg($id: Int!, $status: String!) {
  update_billing_org_by_pk(pk_columns: {id: $id}, _set: {status: $status}) {
    id
    status
  }
}
    `;
export const useUpdateBillingOrgMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateBillingOrgMutation, TError, UpdateBillingOrgMutationVariables, TContext>) =>
    useMutation<UpdateBillingOrgMutation, TError, UpdateBillingOrgMutationVariables, TContext>(
      ['UpdateBillingOrg'],
      (variables?: UpdateBillingOrgMutationVariables) => fetcher<UpdateBillingOrgMutation, UpdateBillingOrgMutationVariables>(UpdateBillingOrgDocument, variables)(),
      options
    );
useUpdateBillingOrgMutation.fetcher = (variables: UpdateBillingOrgMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateBillingOrgMutation, UpdateBillingOrgMutationVariables>(UpdateBillingOrgDocument, variables, options);
export const UpdateBillingOrgCustomerIdDocument = `
    mutation UpdateBillingOrgCustomerId($id: Int!, $customerId: String!, $status: String!) {
  update_billing_org_by_pk(
    pk_columns: {id: $id}
    _set: {customer_id: $customerId, status: $status}
  ) {
    id
    customer_id
  }
}
    `;
export const useUpdateBillingOrgCustomerIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateBillingOrgCustomerIdMutation, TError, UpdateBillingOrgCustomerIdMutationVariables, TContext>) =>
    useMutation<UpdateBillingOrgCustomerIdMutation, TError, UpdateBillingOrgCustomerIdMutationVariables, TContext>(
      ['UpdateBillingOrgCustomerId'],
      (variables?: UpdateBillingOrgCustomerIdMutationVariables) => fetcher<UpdateBillingOrgCustomerIdMutation, UpdateBillingOrgCustomerIdMutationVariables>(UpdateBillingOrgCustomerIdDocument, variables)(),
      options
    );
useUpdateBillingOrgCustomerIdMutation.fetcher = (variables: UpdateBillingOrgCustomerIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateBillingOrgCustomerIdMutation, UpdateBillingOrgCustomerIdMutationVariables>(UpdateBillingOrgCustomerIdDocument, variables, options);
export const GetAllCoinsDocument = `
    query GetAllCoins {
  coins {
    ticker
    name
    id
  }
}
    `;
export const useGetAllCoinsQuery = <
      TData = GetAllCoinsQuery,
      TError = Error
    >(
      variables?: GetAllCoinsQueryVariables,
      options?: UseQueryOptions<GetAllCoinsQuery, TError, TData>
    ) =>
    useQuery<GetAllCoinsQuery, TError, TData>(
      variables === undefined ? ['GetAllCoins'] : ['GetAllCoins', variables],
      fetcher<GetAllCoinsQuery, GetAllCoinsQueryVariables>(GetAllCoinsDocument, variables),
      options
    );
useGetAllCoinsQuery.document = GetAllCoinsDocument;


useGetAllCoinsQuery.getKey = (variables?: GetAllCoinsQueryVariables) => variables === undefined ? ['GetAllCoins'] : ['GetAllCoins', variables];
;

useGetAllCoinsQuery.fetcher = (variables?: GetAllCoinsQueryVariables, options?: RequestInit['headers']) => fetcher<GetAllCoinsQuery, GetAllCoinsQueryVariables>(GetAllCoinsDocument, variables, options);
export const GetCompanyBySlugDocument = `
    query GetCompanyBySlug($slug: String!) {
  companies(where: {slug: {_eq: $slug}}) {
    id
    name
    coin {
      id
      ticker
    }
    slug
    logo
    layer
    overview
    investor_amount
    white_paper
    total_employees
    year_founded
    website
    market_verified
    company_linkedin
    careers_page
    velocity_linkedin
    velocity_token
    tags
    date_added
    ico_start
    ico_end
    audit_file
    sentiment
    web3_address
    twitter
    discord
    telegram
    github
    location_json
    glassdoor
    status_tags
    library
    teamMembers {
      id
      person {
        id
        slug
        name
        picture
        linkedin
        personal_email
        work_email
      }
      function
      start_date
      end_date
      founder
      title
    }
    investment_rounds {
      id
      round_date
      round
      amount
      valuation
      investments {
        id
        person {
          id
          slug
          name
          picture
        }
        vc_firm {
          id
          slug
          name
          logo
        }
        amount
      }
    }
    to_links {
      id
      link_type
      from_company {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        status_tags
        follows {
          id
          list_id
        }
      }
      from_vc_firm {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        follows {
          id
          list_id
        }
      }
    }
    from_links {
      id
      link_type
      to_company {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        total_employees
        investor_amount
        year_founded
        investment_rounds_aggregate {
          aggregate {
            count
          }
        }
        investment_rounds(order_by: {round_date: desc}, limit: 1) {
          round
          round_date
        }
        status_tags
        follows {
          id
          list_id
        }
      }
      to_vc_firm {
        id
        name
        slug
        tags
        sentiment
        overview
        year_founded
        investment_amount_total
        num_of_investments
        logo
        follows {
          id
          list_id
        }
      }
    }
    news_links {
      id
      news {
        id
        date
        text
        link
        kind
        status
        organizations {
          id
          type
          company_id
          vc_firm_id
        }
      }
    }
    news_links {
      id
      news {
        id
        date
        text
        link
        kind
        source
        status
        organizations {
          id
          type
          company_id
          vc_firm_id
        }
      }
    }
    follows {
      id
      list_id
    }
  }
}
    `;
export const useGetCompanyBySlugQuery = <
      TData = GetCompanyBySlugQuery,
      TError = Error
    >(
      variables: GetCompanyBySlugQueryVariables,
      options?: UseQueryOptions<GetCompanyBySlugQuery, TError, TData>
    ) =>
    useQuery<GetCompanyBySlugQuery, TError, TData>(
      ['GetCompanyBySlug', variables],
      fetcher<GetCompanyBySlugQuery, GetCompanyBySlugQueryVariables>(GetCompanyBySlugDocument, variables),
      options
    );
useGetCompanyBySlugQuery.document = GetCompanyBySlugDocument;


useGetCompanyBySlugQuery.getKey = (variables: GetCompanyBySlugQueryVariables) => ['GetCompanyBySlug', variables];
;

useGetCompanyBySlugQuery.fetcher = (variables: GetCompanyBySlugQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompanyBySlugQuery, GetCompanyBySlugQueryVariables>(GetCompanyBySlugDocument, variables, options);
export const GetCompaniesDocument = `
    query GetCompanies($limit: Int, $offset: Int, $orderBy: [companies_order_by!], $where: companies_bool_exp!) {
  companies(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    slug
    logo
    name
    coin {
      ticker
    }
    tags
    location_json
    status_tags
    total_employees
    investor_amount
    year_founded
    investment_rounds_aggregate {
      aggregate {
        count
      }
    }
    investment_rounds(limit: 1, order_by: {round_date: desc_nulls_last}) {
      round
      round_date
      amount
    }
    overview
    follows {
      id
      list_id
    }
    website
    twitter
    company_linkedin
    github
    discord
  }
  companies_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetCompaniesQuery = <
      TData = GetCompaniesQuery,
      TError = Error
    >(
      variables: GetCompaniesQueryVariables,
      options?: UseQueryOptions<GetCompaniesQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesQuery, TError, TData>(
      ['GetCompanies', variables],
      fetcher<GetCompaniesQuery, GetCompaniesQueryVariables>(GetCompaniesDocument, variables),
      options
    );
useGetCompaniesQuery.document = GetCompaniesDocument;


useGetCompaniesQuery.getKey = (variables: GetCompaniesQueryVariables) => ['GetCompanies', variables];
;

useGetCompaniesQuery.fetcher = (variables: GetCompaniesQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesQuery, GetCompaniesQueryVariables>(GetCompaniesDocument, variables, options);
export const GetCompaniesRecentDocument = `
    query GetCompaniesRecent($limit: Int, $offset: Int, $where: companies_bool_exp!) {
  companies(
    where: $where
    order_by: {date_added: desc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    layer
    tags
    logo
    overview
    total_employees
    investor_amount
    year_founded
    investment_rounds_aggregate {
      aggregate {
        count
      }
    }
    date_added
    sentiment
    status_tags
    investment_rounds(order_by: {round_date: desc}) {
      id
      amount
      round
      round_date
    }
    follows {
      id
      list_id
    }
  }
}
    `;
export const useGetCompaniesRecentQuery = <
      TData = GetCompaniesRecentQuery,
      TError = Error
    >(
      variables: GetCompaniesRecentQueryVariables,
      options?: UseQueryOptions<GetCompaniesRecentQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesRecentQuery, TError, TData>(
      ['GetCompaniesRecent', variables],
      fetcher<GetCompaniesRecentQuery, GetCompaniesRecentQueryVariables>(GetCompaniesRecentDocument, variables),
      options
    );
useGetCompaniesRecentQuery.document = GetCompaniesRecentDocument;


useGetCompaniesRecentQuery.getKey = (variables: GetCompaniesRecentQueryVariables) => ['GetCompaniesRecent', variables];
;

useGetCompaniesRecentQuery.fetcher = (variables: GetCompaniesRecentQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesRecentQuery, GetCompaniesRecentQueryVariables>(GetCompaniesRecentDocument, variables, options);
export const GetRelevantCompaniesDocument = `
    query GetRelevantCompanies($where: companies_bool_exp!, $limit: Int) {
  companies(where: $where, limit: $limit) {
    id
    logo
    name
    slug
    sentiment
  }
}
    `;
export const useGetRelevantCompaniesQuery = <
      TData = GetRelevantCompaniesQuery,
      TError = Error
    >(
      variables: GetRelevantCompaniesQueryVariables,
      options?: UseQueryOptions<GetRelevantCompaniesQuery, TError, TData>
    ) =>
    useQuery<GetRelevantCompaniesQuery, TError, TData>(
      ['GetRelevantCompanies', variables],
      fetcher<GetRelevantCompaniesQuery, GetRelevantCompaniesQueryVariables>(GetRelevantCompaniesDocument, variables),
      options
    );
useGetRelevantCompaniesQuery.document = GetRelevantCompaniesDocument;


useGetRelevantCompaniesQuery.getKey = (variables: GetRelevantCompaniesQueryVariables) => ['GetRelevantCompanies', variables];
;

useGetRelevantCompaniesQuery.fetcher = (variables: GetRelevantCompaniesQueryVariables, options?: RequestInit['headers']) => fetcher<GetRelevantCompaniesQuery, GetRelevantCompaniesQueryVariables>(GetRelevantCompaniesDocument, variables, options);
export const GetSentimentByCompanyIdDocument = `
    query GetSentimentByCompanyId($companyId: Int!) {
  companies_by_pk(id: $companyId) {
    sentiment
    slug
  }
}
    `;
export const useGetSentimentByCompanyIdQuery = <
      TData = GetSentimentByCompanyIdQuery,
      TError = Error
    >(
      variables: GetSentimentByCompanyIdQueryVariables,
      options?: UseQueryOptions<GetSentimentByCompanyIdQuery, TError, TData>
    ) =>
    useQuery<GetSentimentByCompanyIdQuery, TError, TData>(
      ['GetSentimentByCompanyId', variables],
      fetcher<GetSentimentByCompanyIdQuery, GetSentimentByCompanyIdQueryVariables>(GetSentimentByCompanyIdDocument, variables),
      options
    );
useGetSentimentByCompanyIdQuery.document = GetSentimentByCompanyIdDocument;


useGetSentimentByCompanyIdQuery.getKey = (variables: GetSentimentByCompanyIdQueryVariables) => ['GetSentimentByCompanyId', variables];
;

useGetSentimentByCompanyIdQuery.fetcher = (variables: GetSentimentByCompanyIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetSentimentByCompanyIdQuery, GetSentimentByCompanyIdQueryVariables>(GetSentimentByCompanyIdDocument, variables, options);
export const UpdateSentimentByCompanyIdDocument = `
    mutation UpdateSentimentByCompanyId($companyId: Int!, $sentiment: jsonb!) {
  update_companies_by_pk(
    pk_columns: {id: $companyId}
    _set: {sentiment: $sentiment}
  ) {
    sentiment
  }
}
    `;
export const useUpdateSentimentByCompanyIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateSentimentByCompanyIdMutation, TError, UpdateSentimentByCompanyIdMutationVariables, TContext>) =>
    useMutation<UpdateSentimentByCompanyIdMutation, TError, UpdateSentimentByCompanyIdMutationVariables, TContext>(
      ['UpdateSentimentByCompanyId'],
      (variables?: UpdateSentimentByCompanyIdMutationVariables) => fetcher<UpdateSentimentByCompanyIdMutation, UpdateSentimentByCompanyIdMutationVariables>(UpdateSentimentByCompanyIdDocument, variables)(),
      options
    );
useUpdateSentimentByCompanyIdMutation.fetcher = (variables: UpdateSentimentByCompanyIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateSentimentByCompanyIdMutation, UpdateSentimentByCompanyIdMutationVariables>(UpdateSentimentByCompanyIdDocument, variables, options);
export const GetCompaniesByDateDocument = `
    query GetCompaniesByDate($date: timestamptz, $library: jsonb) {
  companies(
    where: {_and: [{status: {_eq: "published"}}, {updated_at: {_gte: $date}}, {library: {_contains: $library}}]}
  ) {
    id
    name
    overview
    tags
    logo
    slug
    aliases
    coin {
      ticker
      name
    }
  }
}
    `;
export const useGetCompaniesByDateQuery = <
      TData = GetCompaniesByDateQuery,
      TError = Error
    >(
      variables?: GetCompaniesByDateQueryVariables,
      options?: UseQueryOptions<GetCompaniesByDateQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesByDateQuery, TError, TData>(
      variables === undefined ? ['GetCompaniesByDate'] : ['GetCompaniesByDate', variables],
      fetcher<GetCompaniesByDateQuery, GetCompaniesByDateQueryVariables>(GetCompaniesByDateDocument, variables),
      options
    );
useGetCompaniesByDateQuery.document = GetCompaniesByDateDocument;


useGetCompaniesByDateQuery.getKey = (variables?: GetCompaniesByDateQueryVariables) => variables === undefined ? ['GetCompaniesByDate'] : ['GetCompaniesByDate', variables];
;

useGetCompaniesByDateQuery.fetcher = (variables?: GetCompaniesByDateQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesByDateQuery, GetCompaniesByDateQueryVariables>(GetCompaniesByDateDocument, variables, options);
export const UpdateCompanyByPkDocument = `
    mutation UpdateCompanyByPk($companyId: Int!, $data: companies_set_input) {
  update_companies_by_pk(pk_columns: {id: $companyId}, _set: $data) {
    id
  }
}
    `;
export const useUpdateCompanyByPkMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateCompanyByPkMutation, TError, UpdateCompanyByPkMutationVariables, TContext>) =>
    useMutation<UpdateCompanyByPkMutation, TError, UpdateCompanyByPkMutationVariables, TContext>(
      ['UpdateCompanyByPk'],
      (variables?: UpdateCompanyByPkMutationVariables) => fetcher<UpdateCompanyByPkMutation, UpdateCompanyByPkMutationVariables>(UpdateCompanyByPkDocument, variables)(),
      options
    );
useUpdateCompanyByPkMutation.fetcher = (variables: UpdateCompanyByPkMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateCompanyByPkMutation, UpdateCompanyByPkMutationVariables>(UpdateCompanyByPkDocument, variables, options);
export const GetCompanyByIdDocument = `
    query GetCompanyById($id: Int!) {
  companies(where: {id: {_eq: $id}}) {
    id
    name
    status
  }
}
    `;
export const useGetCompanyByIdQuery = <
      TData = GetCompanyByIdQuery,
      TError = Error
    >(
      variables: GetCompanyByIdQueryVariables,
      options?: UseQueryOptions<GetCompanyByIdQuery, TError, TData>
    ) =>
    useQuery<GetCompanyByIdQuery, TError, TData>(
      ['GetCompanyById', variables],
      fetcher<GetCompanyByIdQuery, GetCompanyByIdQueryVariables>(GetCompanyByIdDocument, variables),
      options
    );
useGetCompanyByIdQuery.document = GetCompanyByIdDocument;


useGetCompanyByIdQuery.getKey = (variables: GetCompanyByIdQueryVariables) => ['GetCompanyById', variables];
;

useGetCompanyByIdQuery.fetcher = (variables: GetCompanyByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompanyByIdQuery, GetCompanyByIdQueryVariables>(GetCompanyByIdDocument, variables, options);
export const GetCompanyInsightByLocationDocument = `
    query GetCompanyInsightByLocation($where: companies_bool_exp!) {
  companies_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetCompanyInsightByLocationQuery = <
      TData = GetCompanyInsightByLocationQuery,
      TError = Error
    >(
      variables: GetCompanyInsightByLocationQueryVariables,
      options?: UseQueryOptions<GetCompanyInsightByLocationQuery, TError, TData>
    ) =>
    useQuery<GetCompanyInsightByLocationQuery, TError, TData>(
      ['GetCompanyInsightByLocation', variables],
      fetcher<GetCompanyInsightByLocationQuery, GetCompanyInsightByLocationQueryVariables>(GetCompanyInsightByLocationDocument, variables),
      options
    );
useGetCompanyInsightByLocationQuery.document = GetCompanyInsightByLocationDocument;


useGetCompanyInsightByLocationQuery.getKey = (variables: GetCompanyInsightByLocationQueryVariables) => ['GetCompanyInsightByLocation', variables];
;

useGetCompanyInsightByLocationQuery.fetcher = (variables: GetCompanyInsightByLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompanyInsightByLocationQuery, GetCompanyInsightByLocationQueryVariables>(GetCompanyInsightByLocationDocument, variables, options);
export const GetPersonalizedCompaniesDocument = `
    query GetPersonalizedCompanies($limit: Int, $offset: Int, $orderBy: [companies_order_by!], $where: companies_bool_exp!) {
  companies(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    slug
    logo
    name
    coin {
      ticker
    }
    tags
    location_json
    status_tags
    total_employees
    investor_amount
    year_founded
    investment_rounds_aggregate {
      aggregate {
        count
      }
    }
    investment_rounds(order_by: {round_date: desc}, limit: 1) {
      round
      round_date
    }
    overview
    follows {
      id
      list_id
    }
    website
    twitter
    company_linkedin
    github
    discord
  }
  companies_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetPersonalizedCompaniesQuery = <
      TData = GetPersonalizedCompaniesQuery,
      TError = Error
    >(
      variables: GetPersonalizedCompaniesQueryVariables,
      options?: UseQueryOptions<GetPersonalizedCompaniesQuery, TError, TData>
    ) =>
    useQuery<GetPersonalizedCompaniesQuery, TError, TData>(
      ['GetPersonalizedCompanies', variables],
      fetcher<GetPersonalizedCompaniesQuery, GetPersonalizedCompaniesQueryVariables>(GetPersonalizedCompaniesDocument, variables),
      options
    );
useGetPersonalizedCompaniesQuery.document = GetPersonalizedCompaniesDocument;


useGetPersonalizedCompaniesQuery.getKey = (variables: GetPersonalizedCompaniesQueryVariables) => ['GetPersonalizedCompanies', variables];
;

useGetPersonalizedCompaniesQuery.fetcher = (variables: GetPersonalizedCompaniesQueryVariables, options?: RequestInit['headers']) => fetcher<GetPersonalizedCompaniesQuery, GetPersonalizedCompaniesQueryVariables>(GetPersonalizedCompaniesDocument, variables, options);
export const InsertCompaniesDocument = `
    mutation InsertCompanies($objects: [companies_insert_input!]!) {
  insert_companies(
    objects: $objects
    on_conflict: {constraint: companies_slug_key, update_columns: []}
  ) {
    returning {
      id
      status
      slug
      enrichment_priority
      website
      company_linkedin
    }
  }
}
    `;
export const useInsertCompaniesMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertCompaniesMutation, TError, InsertCompaniesMutationVariables, TContext>) =>
    useMutation<InsertCompaniesMutation, TError, InsertCompaniesMutationVariables, TContext>(
      ['InsertCompanies'],
      (variables?: InsertCompaniesMutationVariables) => fetcher<InsertCompaniesMutation, InsertCompaniesMutationVariables>(InsertCompaniesDocument, variables)(),
      options
    );
useInsertCompaniesMutation.fetcher = (variables: InsertCompaniesMutationVariables, options?: RequestInit['headers']) => fetcher<InsertCompaniesMutation, InsertCompaniesMutationVariables>(InsertCompaniesDocument, variables, options);
export const GetCompaniesByTagsAndLocationDocument = `
    query GetCompaniesByTagsAndLocation($limit: Int, $where: companies_bool_exp!) {
  companies(where: $where, limit: $limit) {
    id
  }
}
    `;
export const useGetCompaniesByTagsAndLocationQuery = <
      TData = GetCompaniesByTagsAndLocationQuery,
      TError = Error
    >(
      variables: GetCompaniesByTagsAndLocationQueryVariables,
      options?: UseQueryOptions<GetCompaniesByTagsAndLocationQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesByTagsAndLocationQuery, TError, TData>(
      ['GetCompaniesByTagsAndLocation', variables],
      fetcher<GetCompaniesByTagsAndLocationQuery, GetCompaniesByTagsAndLocationQueryVariables>(GetCompaniesByTagsAndLocationDocument, variables),
      options
    );
useGetCompaniesByTagsAndLocationQuery.document = GetCompaniesByTagsAndLocationDocument;


useGetCompaniesByTagsAndLocationQuery.getKey = (variables: GetCompaniesByTagsAndLocationQueryVariables) => ['GetCompaniesByTagsAndLocation', variables];
;

useGetCompaniesByTagsAndLocationQuery.fetcher = (variables: GetCompaniesByTagsAndLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesByTagsAndLocationQuery, GetCompaniesByTagsAndLocationQueryVariables>(GetCompaniesByTagsAndLocationDocument, variables, options);
export const InsertDataDiscardDocument = `
    mutation InsertDataDiscard($input: [data_discard_insert_input!]!) {
  insert_data_discard(objects: $input) {
    returning {
      id
      created_at
      resource
      resource_id
      field
      value
      accuracy_weight
    }
  }
}
    `;
export const useInsertDataDiscardMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertDataDiscardMutation, TError, InsertDataDiscardMutationVariables, TContext>) =>
    useMutation<InsertDataDiscardMutation, TError, InsertDataDiscardMutationVariables, TContext>(
      ['InsertDataDiscard'],
      (variables?: InsertDataDiscardMutationVariables) => fetcher<InsertDataDiscardMutation, InsertDataDiscardMutationVariables>(InsertDataDiscardDocument, variables)(),
      options
    );
useInsertDataDiscardMutation.fetcher = (variables: InsertDataDiscardMutationVariables, options?: RequestInit['headers']) => fetcher<InsertDataDiscardMutation, InsertDataDiscardMutationVariables>(InsertDataDiscardDocument, variables, options);
export const GetDataFieldByPathDocument = `
    query GetDataFieldByPath($path: String!) {
  data_fields(where: {path: {_eq: $path}}) {
    name
    resource
    weight
    regex_transform
    description
    regex_test
    is_valid_identifier
    restricted_admin
    data_type
  }
}
    `;
export const useGetDataFieldByPathQuery = <
      TData = GetDataFieldByPathQuery,
      TError = Error
    >(
      variables: GetDataFieldByPathQueryVariables,
      options?: UseQueryOptions<GetDataFieldByPathQuery, TError, TData>
    ) =>
    useQuery<GetDataFieldByPathQuery, TError, TData>(
      ['GetDataFieldByPath', variables],
      fetcher<GetDataFieldByPathQuery, GetDataFieldByPathQueryVariables>(GetDataFieldByPathDocument, variables),
      options
    );
useGetDataFieldByPathQuery.document = GetDataFieldByPathDocument;


useGetDataFieldByPathQuery.getKey = (variables: GetDataFieldByPathQueryVariables) => ['GetDataFieldByPath', variables];
;

useGetDataFieldByPathQuery.fetcher = (variables: GetDataFieldByPathQueryVariables, options?: RequestInit['headers']) => fetcher<GetDataFieldByPathQuery, GetDataFieldByPathQueryVariables>(GetDataFieldByPathDocument, variables, options);
export const GetDataPartnerByApiKeyDocument = `
    query GetDataPartnerByApiKey($apiKey: String!) {
  data_partners(where: {api_key: {_eq: $apiKey}}) {
    id
    name
    api_key
  }
}
    `;
export const useGetDataPartnerByApiKeyQuery = <
      TData = GetDataPartnerByApiKeyQuery,
      TError = Error
    >(
      variables: GetDataPartnerByApiKeyQueryVariables,
      options?: UseQueryOptions<GetDataPartnerByApiKeyQuery, TError, TData>
    ) =>
    useQuery<GetDataPartnerByApiKeyQuery, TError, TData>(
      ['GetDataPartnerByApiKey', variables],
      fetcher<GetDataPartnerByApiKeyQuery, GetDataPartnerByApiKeyQueryVariables>(GetDataPartnerByApiKeyDocument, variables),
      options
    );
useGetDataPartnerByApiKeyQuery.document = GetDataPartnerByApiKeyDocument;


useGetDataPartnerByApiKeyQuery.getKey = (variables: GetDataPartnerByApiKeyQueryVariables) => ['GetDataPartnerByApiKey', variables];
;

useGetDataPartnerByApiKeyQuery.fetcher = (variables: GetDataPartnerByApiKeyQueryVariables, options?: RequestInit['headers']) => fetcher<GetDataPartnerByApiKeyQuery, GetDataPartnerByApiKeyQueryVariables>(GetDataPartnerByApiKeyDocument, variables, options);
export const InsertDataRawDocument = `
    mutation InsertDataRaw($input: [data_raw_insert_input!]!) {
  insert_data_raw(objects: $input) {
    returning {
      id
      created_at
      resource
      resource_id
      field
      value
      accuracy_weight
    }
  }
}
    `;
export const useInsertDataRawMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertDataRawMutation, TError, InsertDataRawMutationVariables, TContext>) =>
    useMutation<InsertDataRawMutation, TError, InsertDataRawMutationVariables, TContext>(
      ['InsertDataRaw'],
      (variables?: InsertDataRawMutationVariables) => fetcher<InsertDataRawMutation, InsertDataRawMutationVariables>(InsertDataRawDocument, variables)(),
      options
    );
useInsertDataRawMutation.fetcher = (variables: InsertDataRawMutationVariables, options?: RequestInit['headers']) => fetcher<InsertDataRawMutation, InsertDataRawMutationVariables>(InsertDataRawDocument, variables, options);
export const MarkDataRawAsInactiveDocument = `
    mutation MarkDataRawAsInactive($resourceType: String!, $resourceId: Int!) {
  update_data_raw(
    _set: {is_active: false}
    where: {_and: [{resource: {_eq: $resourceType}}, {resource_id: {_eq: $resourceId}}]}
  ) {
    affected_rows
  }
}
    `;
export const useMarkDataRawAsInactiveMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<MarkDataRawAsInactiveMutation, TError, MarkDataRawAsInactiveMutationVariables, TContext>) =>
    useMutation<MarkDataRawAsInactiveMutation, TError, MarkDataRawAsInactiveMutationVariables, TContext>(
      ['MarkDataRawAsInactive'],
      (variables?: MarkDataRawAsInactiveMutationVariables) => fetcher<MarkDataRawAsInactiveMutation, MarkDataRawAsInactiveMutationVariables>(MarkDataRawAsInactiveDocument, variables)(),
      options
    );
useMarkDataRawAsInactiveMutation.fetcher = (variables: MarkDataRawAsInactiveMutationVariables, options?: RequestInit['headers']) => fetcher<MarkDataRawAsInactiveMutation, MarkDataRawAsInactiveMutationVariables>(MarkDataRawAsInactiveDocument, variables, options);
export const GetDisabledEmailByEmailOrDomainDocument = `
    query GetDisabledEmailByEmailOrDomain($email: String, $domain: String) {
  disabled_emails(
    where: {_or: [{email: {_eq: $email}, match_type: {_eq: "EMAIL"}}, {email: {_eq: $domain}, match_type: {_eq: "DOMAIN"}}]}
    limit: 1
  ) {
    id
    email
  }
}
    `;
export const useGetDisabledEmailByEmailOrDomainQuery = <
      TData = GetDisabledEmailByEmailOrDomainQuery,
      TError = Error
    >(
      variables?: GetDisabledEmailByEmailOrDomainQueryVariables,
      options?: UseQueryOptions<GetDisabledEmailByEmailOrDomainQuery, TError, TData>
    ) =>
    useQuery<GetDisabledEmailByEmailOrDomainQuery, TError, TData>(
      variables === undefined ? ['GetDisabledEmailByEmailOrDomain'] : ['GetDisabledEmailByEmailOrDomain', variables],
      fetcher<GetDisabledEmailByEmailOrDomainQuery, GetDisabledEmailByEmailOrDomainQueryVariables>(GetDisabledEmailByEmailOrDomainDocument, variables),
      options
    );
useGetDisabledEmailByEmailOrDomainQuery.document = GetDisabledEmailByEmailOrDomainDocument;


useGetDisabledEmailByEmailOrDomainQuery.getKey = (variables?: GetDisabledEmailByEmailOrDomainQueryVariables) => variables === undefined ? ['GetDisabledEmailByEmailOrDomain'] : ['GetDisabledEmailByEmailOrDomain', variables];
;

useGetDisabledEmailByEmailOrDomainQuery.fetcher = (variables?: GetDisabledEmailByEmailOrDomainQueryVariables, options?: RequestInit['headers']) => fetcher<GetDisabledEmailByEmailOrDomainQuery, GetDisabledEmailByEmailOrDomainQueryVariables>(GetDisabledEmailByEmailOrDomainDocument, variables, options);
export const GetEventsDocument = `
    query GetEvents($limit: Int, $offset: Int, $orderBy: [events_order_by!], $where: events_bool_exp!) {
  events(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    name
    slug
    banner
    overview
    notes
    location_json
    venue_name
    link
    size
    price
    types
    start_date
    start_time
    end_date
    end_time
    timezone
    twitter
    facebook
    instagram
    discord
    telegram
    is_featured
    created_at
    library
    event_person {
      id
      type
      created_at
      person_id
    }
    parent_event_id
  }
  events_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetEventsQuery = <
      TData = GetEventsQuery,
      TError = Error
    >(
      variables: GetEventsQueryVariables,
      options?: UseQueryOptions<GetEventsQuery, TError, TData>
    ) =>
    useQuery<GetEventsQuery, TError, TData>(
      ['GetEvents', variables],
      fetcher<GetEventsQuery, GetEventsQueryVariables>(GetEventsDocument, variables),
      options
    );
useGetEventsQuery.document = GetEventsDocument;


useGetEventsQuery.getKey = (variables: GetEventsQueryVariables) => ['GetEvents', variables];
;

useGetEventsQuery.fetcher = (variables: GetEventsQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventsQuery, GetEventsQueryVariables>(GetEventsDocument, variables, options);
export const GetEventDocument = `
    query GetEvent($slug: String!) {
  events(where: {slug: {_eq: $slug}}) {
    id
    name
    slug
    banner
    overview
    notes
    location_json
    venue_name
    link
    size
    price
    types
    start_date
    start_time
    end_date
    end_time
    timezone
    twitter
    facebook
    instagram
    discord
    telegram
    is_featured
    attachments
    created_at
    library
    event_person {
      id
      type
      created_at
      person {
        id
        slug
        name
        type
        picture
        linkedin
        personal_email
        work_email
        status
        investors {
          id
          title
          vc_firm {
            id
            slug
            name
          }
        }
        team_members {
          id
          founder
          title
          company {
            id
            slug
            name
          }
        }
      }
    }
    event_organization {
      id
      type
      sponsor_type
      created_at
      company {
        id
        name
        slug
        logo
        status
      }
      vc_firm {
        id
        name
        slug
        logo
        status
      }
    }
    parent_event {
      id
      slug
      name
    }
  }
}
    `;
export const useGetEventQuery = <
      TData = GetEventQuery,
      TError = Error
    >(
      variables: GetEventQueryVariables,
      options?: UseQueryOptions<GetEventQuery, TError, TData>
    ) =>
    useQuery<GetEventQuery, TError, TData>(
      ['GetEvent', variables],
      fetcher<GetEventQuery, GetEventQueryVariables>(GetEventDocument, variables),
      options
    );
useGetEventQuery.document = GetEventDocument;


useGetEventQuery.getKey = (variables: GetEventQueryVariables) => ['GetEvent', variables];
;

useGetEventQuery.fetcher = (variables: GetEventQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventQuery, GetEventQueryVariables>(GetEventDocument, variables, options);
export const GetEventsByDateDocument = `
    query GetEventsByDate($date: timestamptz, $library: jsonb) {
  events(
    where: {_and: [{status: {_eq: "published"}}, {updated_at: {_gte: $date}}, {library: {_contains: $library}}]}
  ) {
    id
    name
    slug
    overview
    banner
    location_json
    start_date
    end_date
  }
}
    `;
export const useGetEventsByDateQuery = <
      TData = GetEventsByDateQuery,
      TError = Error
    >(
      variables?: GetEventsByDateQueryVariables,
      options?: UseQueryOptions<GetEventsByDateQuery, TError, TData>
    ) =>
    useQuery<GetEventsByDateQuery, TError, TData>(
      variables === undefined ? ['GetEventsByDate'] : ['GetEventsByDate', variables],
      fetcher<GetEventsByDateQuery, GetEventsByDateQueryVariables>(GetEventsByDateDocument, variables),
      options
    );
useGetEventsByDateQuery.document = GetEventsByDateDocument;


useGetEventsByDateQuery.getKey = (variables?: GetEventsByDateQueryVariables) => variables === undefined ? ['GetEventsByDate'] : ['GetEventsByDate', variables];
;

useGetEventsByDateQuery.fetcher = (variables?: GetEventsByDateQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventsByDateQuery, GetEventsByDateQueryVariables>(GetEventsByDateDocument, variables, options);
export const InsertEventAttendeeDocument = `
    mutation InsertEventAttendee($object: event_person_insert_input!) {
  insert_event_person_one(object: $object) {
    id
    event_id
    person_id
    type
  }
}
    `;
export const useInsertEventAttendeeMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertEventAttendeeMutation, TError, InsertEventAttendeeMutationVariables, TContext>) =>
    useMutation<InsertEventAttendeeMutation, TError, InsertEventAttendeeMutationVariables, TContext>(
      ['InsertEventAttendee'],
      (variables?: InsertEventAttendeeMutationVariables) => fetcher<InsertEventAttendeeMutation, InsertEventAttendeeMutationVariables>(InsertEventAttendeeDocument, variables)(),
      options
    );
useInsertEventAttendeeMutation.fetcher = (variables: InsertEventAttendeeMutationVariables, options?: RequestInit['headers']) => fetcher<InsertEventAttendeeMutation, InsertEventAttendeeMutationVariables>(InsertEventAttendeeDocument, variables, options);
export const FindEventAttendeeDocument = `
    query FindEventAttendee($event_id: Int!, $person_id: Int!) {
  event_person(
    where: {_and: [{event_id: {_eq: $event_id}}, {person_id: {_eq: $person_id}}, {type: {_eq: "attendee"}}]}
    limit: 1
  ) {
    id
  }
}
    `;
export const useFindEventAttendeeQuery = <
      TData = FindEventAttendeeQuery,
      TError = Error
    >(
      variables: FindEventAttendeeQueryVariables,
      options?: UseQueryOptions<FindEventAttendeeQuery, TError, TData>
    ) =>
    useQuery<FindEventAttendeeQuery, TError, TData>(
      ['FindEventAttendee', variables],
      fetcher<FindEventAttendeeQuery, FindEventAttendeeQueryVariables>(FindEventAttendeeDocument, variables),
      options
    );
useFindEventAttendeeQuery.document = FindEventAttendeeDocument;


useFindEventAttendeeQuery.getKey = (variables: FindEventAttendeeQueryVariables) => ['FindEventAttendee', variables];
;

useFindEventAttendeeQuery.fetcher = (variables: FindEventAttendeeQueryVariables, options?: RequestInit['headers']) => fetcher<FindEventAttendeeQuery, FindEventAttendeeQueryVariables>(FindEventAttendeeDocument, variables, options);
export const GetSubEventsDocument = `
    query GetSubEvents($parent_event_id: Int!) {
  events(
    where: {parent_event_id: {_eq: $parent_event_id}}
    order_by: {start_date: desc}
    limit: 50
  ) {
    id
    name
    slug
    banner
    overview
    notes
    location_json
    venue_name
    link
    size
    price
    types
    start_date
    start_time
    end_date
    end_time
    timezone
    is_featured
    created_at
  }
}
    `;
export const useGetSubEventsQuery = <
      TData = GetSubEventsQuery,
      TError = Error
    >(
      variables: GetSubEventsQueryVariables,
      options?: UseQueryOptions<GetSubEventsQuery, TError, TData>
    ) =>
    useQuery<GetSubEventsQuery, TError, TData>(
      ['GetSubEvents', variables],
      fetcher<GetSubEventsQuery, GetSubEventsQueryVariables>(GetSubEventsDocument, variables),
      options
    );
useGetSubEventsQuery.document = GetSubEventsDocument;


useGetSubEventsQuery.getKey = (variables: GetSubEventsQueryVariables) => ['GetSubEvents', variables];
;

useGetSubEventsQuery.fetcher = (variables: GetSubEventsQueryVariables, options?: RequestInit['headers']) => fetcher<GetSubEventsQuery, GetSubEventsQueryVariables>(GetSubEventsDocument, variables, options);
export const GetEventOrganizationByIdDocument = `
    query GetEventOrganizationById($id: Int!) {
  event_organization(where: {id: {_eq: $id}}, limit: 1) {
    id
    company_id
    vc_firm_id
    type
    event {
      id
      name
      slug
      status
    }
  }
}
    `;
export const useGetEventOrganizationByIdQuery = <
      TData = GetEventOrganizationByIdQuery,
      TError = Error
    >(
      variables: GetEventOrganizationByIdQueryVariables,
      options?: UseQueryOptions<GetEventOrganizationByIdQuery, TError, TData>
    ) =>
    useQuery<GetEventOrganizationByIdQuery, TError, TData>(
      ['GetEventOrganizationById', variables],
      fetcher<GetEventOrganizationByIdQuery, GetEventOrganizationByIdQueryVariables>(GetEventOrganizationByIdDocument, variables),
      options
    );
useGetEventOrganizationByIdQuery.document = GetEventOrganizationByIdDocument;


useGetEventOrganizationByIdQuery.getKey = (variables: GetEventOrganizationByIdQueryVariables) => ['GetEventOrganizationById', variables];
;

useGetEventOrganizationByIdQuery.fetcher = (variables: GetEventOrganizationByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventOrganizationByIdQuery, GetEventOrganizationByIdQueryVariables>(GetEventOrganizationByIdDocument, variables, options);
export const GetEventInsightByLocationDocument = `
    query GetEventInsightByLocation($where: events_bool_exp!) {
  events_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetEventInsightByLocationQuery = <
      TData = GetEventInsightByLocationQuery,
      TError = Error
    >(
      variables: GetEventInsightByLocationQueryVariables,
      options?: UseQueryOptions<GetEventInsightByLocationQuery, TError, TData>
    ) =>
    useQuery<GetEventInsightByLocationQuery, TError, TData>(
      ['GetEventInsightByLocation', variables],
      fetcher<GetEventInsightByLocationQuery, GetEventInsightByLocationQueryVariables>(GetEventInsightByLocationDocument, variables),
      options
    );
useGetEventInsightByLocationQuery.document = GetEventInsightByLocationDocument;


useGetEventInsightByLocationQuery.getKey = (variables: GetEventInsightByLocationQueryVariables) => ['GetEventInsightByLocation', variables];
;

useGetEventInsightByLocationQuery.fetcher = (variables: GetEventInsightByLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventInsightByLocationQuery, GetEventInsightByLocationQueryVariables>(GetEventInsightByLocationDocument, variables, options);
export const GetFollowsByUserDocument = `
    query GetFollowsByUser($user_id: Int!) {
  list_members(
    where: {user_id: {_eq: $user_id}}
    order_by: {list: {updated_at: desc}}
  ) {
    list {
      name
      description
      id
      public
      created_by_id
      created_by {
        id
        display_name
        email
        person {
          id
          slug
          name
        }
      }
      created_at
      updated_at
      total_no_of_resources
      follows_companies {
        resource_id
      }
      follows_vcfirms {
        resource_id
      }
      follows_people {
        resource_id
      }
    }
  }
}
    `;
export const useGetFollowsByUserQuery = <
      TData = GetFollowsByUserQuery,
      TError = Error
    >(
      variables: GetFollowsByUserQueryVariables,
      options?: UseQueryOptions<GetFollowsByUserQuery, TError, TData>
    ) =>
    useQuery<GetFollowsByUserQuery, TError, TData>(
      ['GetFollowsByUser', variables],
      fetcher<GetFollowsByUserQuery, GetFollowsByUserQueryVariables>(GetFollowsByUserDocument, variables),
      options
    );
useGetFollowsByUserQuery.document = GetFollowsByUserDocument;


useGetFollowsByUserQuery.getKey = (variables: GetFollowsByUserQueryVariables) => ['GetFollowsByUser', variables];
;

useGetFollowsByUserQuery.fetcher = (variables: GetFollowsByUserQueryVariables, options?: RequestInit['headers']) => fetcher<GetFollowsByUserQuery, GetFollowsByUserQueryVariables>(GetFollowsByUserDocument, variables, options);
export const GetCompaniesByListIdDocument = `
    query GetCompaniesByListId($list_id: Int = 0, $limit: Int, $offset: Int, $query: String) {
  follows_companies(
    where: {_and: [{list_id: {_eq: $list_id}}, {company: {_or: [{name: {_ilike: $query}}, {overview: {_ilike: $query}}]}}]}
    limit: $limit
    offset: $offset
  ) {
    id
    company {
      id
      name
      website
      logo
      sentiment
      location_json
      twitter
      year_founded
      total_employees
      overview
      coin {
        ticker
        name
      }
      teamMembers(limit: 10, order_by: {founder: desc_nulls_last}) {
        id
        founder
        person {
          id
          slug
          name
        }
      }
      investment_rounds {
        amount
        round_date
        round
      }
      tags
      slug
    }
  }
  follows_companies_aggregate(
    where: {_and: [{list_id: {_eq: $list_id}}, {company: {_or: [{name: {_ilike: $query}}, {overview: {_ilike: $query}}]}}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetCompaniesByListIdQuery = <
      TData = GetCompaniesByListIdQuery,
      TError = Error
    >(
      variables?: GetCompaniesByListIdQueryVariables,
      options?: UseQueryOptions<GetCompaniesByListIdQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesByListIdQuery, TError, TData>(
      variables === undefined ? ['GetCompaniesByListId'] : ['GetCompaniesByListId', variables],
      fetcher<GetCompaniesByListIdQuery, GetCompaniesByListIdQueryVariables>(GetCompaniesByListIdDocument, variables),
      options
    );
useGetCompaniesByListIdQuery.document = GetCompaniesByListIdDocument;


useGetCompaniesByListIdQuery.getKey = (variables?: GetCompaniesByListIdQueryVariables) => variables === undefined ? ['GetCompaniesByListId'] : ['GetCompaniesByListId', variables];
;

useGetCompaniesByListIdQuery.fetcher = (variables?: GetCompaniesByListIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesByListIdQuery, GetCompaniesByListIdQueryVariables>(GetCompaniesByListIdDocument, variables, options);
export const GetVcFirmsByListIdDocument = `
    query GetVcFirmsByListId($list_id: Int = 0, $limit: Int, $offset: Int, $query: String) {
  follows_vc_firms(
    where: {_and: [{list_id: {_eq: $list_id}}, {vc_firm: {_or: [{name: {_ilike: $query}}, {overview: {_ilike: $query}}]}}]}
    limit: $limit
    offset: $offset
  ) {
    id
    vc_firm {
      id
      name
      website
      num_of_investments
      latest_investment
      sentiment
      logo
      slug
      location_json
      year_founded
      overview
      tags
      investors(limit: 10, order_by: {founder: desc_nulls_last}) {
        id
        founder
        person {
          id
          slug
          name
        }
      }
      investments {
        investment_round {
          id
          amount
          round_date
          round
        }
      }
    }
  }
  follows_vc_firms_aggregate(
    where: {_and: [{list_id: {_eq: $list_id}}, {vc_firm: {_or: [{name: {_ilike: $query}}, {overview: {_ilike: $query}}]}}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetVcFirmsByListIdQuery = <
      TData = GetVcFirmsByListIdQuery,
      TError = Error
    >(
      variables?: GetVcFirmsByListIdQueryVariables,
      options?: UseQueryOptions<GetVcFirmsByListIdQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsByListIdQuery, TError, TData>(
      variables === undefined ? ['GetVcFirmsByListId'] : ['GetVcFirmsByListId', variables],
      fetcher<GetVcFirmsByListIdQuery, GetVcFirmsByListIdQueryVariables>(GetVcFirmsByListIdDocument, variables),
      options
    );
useGetVcFirmsByListIdQuery.document = GetVcFirmsByListIdDocument;


useGetVcFirmsByListIdQuery.getKey = (variables?: GetVcFirmsByListIdQueryVariables) => variables === undefined ? ['GetVcFirmsByListId'] : ['GetVcFirmsByListId', variables];
;

useGetVcFirmsByListIdQuery.fetcher = (variables?: GetVcFirmsByListIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsByListIdQuery, GetVcFirmsByListIdQueryVariables>(GetVcFirmsByListIdDocument, variables, options);
export const UpsertFollowsDocument = `
    mutation UpsertFollows($listId: Int, $resourceId: Int, $resourceType: String, $userId: Int) {
  insert_follows_one(
    object: {list_id: $listId, resource_id: $resourceId, resource_type: $resourceType, created_by_user_id: $userId}
    on_conflict: {constraint: follows_resource_type_resource_id_list_id_key}
  ) {
    id
  }
}
    `;
export const useUpsertFollowsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertFollowsMutation, TError, UpsertFollowsMutationVariables, TContext>) =>
    useMutation<UpsertFollowsMutation, TError, UpsertFollowsMutationVariables, TContext>(
      ['UpsertFollows'],
      (variables?: UpsertFollowsMutationVariables) => fetcher<UpsertFollowsMutation, UpsertFollowsMutationVariables>(UpsertFollowsDocument, variables)(),
      options
    );
useUpsertFollowsMutation.fetcher = (variables?: UpsertFollowsMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertFollowsMutation, UpsertFollowsMutationVariables>(UpsertFollowsDocument, variables, options);
export const DeleteFollowsDocument = `
    mutation DeleteFollows($where: follows_bool_exp!) {
  delete_follows(where: $where) {
    returning {
      id
    }
  }
}
    `;
export const useDeleteFollowsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteFollowsMutation, TError, DeleteFollowsMutationVariables, TContext>) =>
    useMutation<DeleteFollowsMutation, TError, DeleteFollowsMutationVariables, TContext>(
      ['DeleteFollows'],
      (variables?: DeleteFollowsMutationVariables) => fetcher<DeleteFollowsMutation, DeleteFollowsMutationVariables>(DeleteFollowsDocument, variables)(),
      options
    );
useDeleteFollowsMutation.fetcher = (variables: DeleteFollowsMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteFollowsMutation, DeleteFollowsMutationVariables>(DeleteFollowsDocument, variables, options);
export const GetFollowByIdDocument = `
    query GetFollowById($id: Int!) {
  follows(where: {id: {_eq: $id}}, limit: 1) {
    id
    created_by_user_id
    resource_type
    resource_id
    list_id
  }
}
    `;
export const useGetFollowByIdQuery = <
      TData = GetFollowByIdQuery,
      TError = Error
    >(
      variables: GetFollowByIdQueryVariables,
      options?: UseQueryOptions<GetFollowByIdQuery, TError, TData>
    ) =>
    useQuery<GetFollowByIdQuery, TError, TData>(
      ['GetFollowById', variables],
      fetcher<GetFollowByIdQuery, GetFollowByIdQueryVariables>(GetFollowByIdDocument, variables),
      options
    );
useGetFollowByIdQuery.document = GetFollowByIdDocument;


useGetFollowByIdQuery.getKey = (variables: GetFollowByIdQueryVariables) => ['GetFollowById', variables];
;

useGetFollowByIdQuery.fetcher = (variables: GetFollowByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetFollowByIdQuery, GetFollowByIdQueryVariables>(GetFollowByIdDocument, variables, options);
export const GetFollowsByResourceDocument = `
    query GetFollowsByResource($resourceId: Int!, $resourceType: String!) {
  follows(
    where: {_and: [{resource_id: {_eq: $resourceId}}, {resource_type: {_eq: $resourceType}}]}
  ) {
    id
    list_id
    list {
      list_members {
        id
        user_id
      }
    }
  }
}
    `;
export const useGetFollowsByResourceQuery = <
      TData = GetFollowsByResourceQuery,
      TError = Error
    >(
      variables: GetFollowsByResourceQueryVariables,
      options?: UseQueryOptions<GetFollowsByResourceQuery, TError, TData>
    ) =>
    useQuery<GetFollowsByResourceQuery, TError, TData>(
      ['GetFollowsByResource', variables],
      fetcher<GetFollowsByResourceQuery, GetFollowsByResourceQueryVariables>(GetFollowsByResourceDocument, variables),
      options
    );
useGetFollowsByResourceQuery.document = GetFollowsByResourceDocument;


useGetFollowsByResourceQuery.getKey = (variables: GetFollowsByResourceQueryVariables) => ['GetFollowsByResource', variables];
;

useGetFollowsByResourceQuery.fetcher = (variables: GetFollowsByResourceQueryVariables, options?: RequestInit['headers']) => fetcher<GetFollowsByResourceQuery, GetFollowsByResourceQueryVariables>(GetFollowsByResourceDocument, variables, options);
export const GetPeopleByListIdDocument = `
    query GetPeopleByListId($list_id: Int = 0, $limit: Int, $offset: Int, $query: String) {
  follows_people(
    where: {_and: [{list_id: {_eq: $list_id}}, {person: {_or: [{name: {_ilike: $query}}, {personal_email: {_ilike: $query}}, {work_email: {_ilike: $query}}]}}]}
    limit: $limit
    offset: $offset
  ) {
    id
    person {
      id
      name
      picture
      slug
      type
      personal_email
      work_email
      city
      country
      website_url
      github
      twitter_url
      linkedin
    }
  }
  follows_people_aggregate(
    where: {_and: [{list_id: {_eq: $list_id}}, {person: {_or: [{name: {_ilike: $query}}, {personal_email: {_ilike: $query}}, {work_email: {_ilike: $query}}]}}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetPeopleByListIdQuery = <
      TData = GetPeopleByListIdQuery,
      TError = Error
    >(
      variables?: GetPeopleByListIdQueryVariables,
      options?: UseQueryOptions<GetPeopleByListIdQuery, TError, TData>
    ) =>
    useQuery<GetPeopleByListIdQuery, TError, TData>(
      variables === undefined ? ['GetPeopleByListId'] : ['GetPeopleByListId', variables],
      fetcher<GetPeopleByListIdQuery, GetPeopleByListIdQueryVariables>(GetPeopleByListIdDocument, variables),
      options
    );
useGetPeopleByListIdQuery.document = GetPeopleByListIdDocument;


useGetPeopleByListIdQuery.getKey = (variables?: GetPeopleByListIdQueryVariables) => variables === undefined ? ['GetPeopleByListId'] : ['GetPeopleByListId', variables];
;

useGetPeopleByListIdQuery.fetcher = (variables?: GetPeopleByListIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleByListIdQuery, GetPeopleByListIdQueryVariables>(GetPeopleByListIdDocument, variables, options);
export const CheckFollowExistsDocument = `
    query CheckFollowExists($where: follows_bool_exp!) {
  follows(where: $where, limit: 1) {
    id
  }
}
    `;
export const useCheckFollowExistsQuery = <
      TData = CheckFollowExistsQuery,
      TError = Error
    >(
      variables: CheckFollowExistsQueryVariables,
      options?: UseQueryOptions<CheckFollowExistsQuery, TError, TData>
    ) =>
    useQuery<CheckFollowExistsQuery, TError, TData>(
      ['CheckFollowExists', variables],
      fetcher<CheckFollowExistsQuery, CheckFollowExistsQueryVariables>(CheckFollowExistsDocument, variables),
      options
    );
useCheckFollowExistsQuery.document = CheckFollowExistsDocument;


useCheckFollowExistsQuery.getKey = (variables: CheckFollowExistsQueryVariables) => ['CheckFollowExists', variables];
;

useCheckFollowExistsQuery.fetcher = (variables: CheckFollowExistsQueryVariables, options?: RequestInit['headers']) => fetcher<CheckFollowExistsQuery, CheckFollowExistsQueryVariables>(CheckFollowExistsDocument, variables, options);
export const GetGroupsOfUserDocument = `
    query GetGroupsOfUser($user_id: Int!) {
  user_group_members(
    where: {user_id: {_eq: $user_id}}
    order_by: {user_group: {updated_at: desc}}
  ) {
    id
    user_id
    user {
      id
      email
      display_name
    }
    user_group_id
    user_group {
      id
      name
      description
      telegram
      twitter
      discord
      public
      created_by {
        id
        display_name
        email
      }
      created_at
      updated_at
    }
  }
}
    `;
export const useGetGroupsOfUserQuery = <
      TData = GetGroupsOfUserQuery,
      TError = Error
    >(
      variables: GetGroupsOfUserQueryVariables,
      options?: UseQueryOptions<GetGroupsOfUserQuery, TError, TData>
    ) =>
    useQuery<GetGroupsOfUserQuery, TError, TData>(
      ['GetGroupsOfUser', variables],
      fetcher<GetGroupsOfUserQuery, GetGroupsOfUserQueryVariables>(GetGroupsOfUserDocument, variables),
      options
    );
useGetGroupsOfUserQuery.document = GetGroupsOfUserDocument;


useGetGroupsOfUserQuery.getKey = (variables: GetGroupsOfUserQueryVariables) => ['GetGroupsOfUser', variables];
;

useGetGroupsOfUserQuery.fetcher = (variables: GetGroupsOfUserQueryVariables, options?: RequestInit['headers']) => fetcher<GetGroupsOfUserQuery, GetGroupsOfUserQueryVariables>(GetGroupsOfUserDocument, variables, options);
export const GetGroupsDocument = `
    query GetGroups($limit: Int, $offset: Int, $where: user_groups_bool_exp!) {
  user_groups(
    where: $where
    order_by: {created_at: desc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    description
    telegram
    twitter
    discord
    public
    created_by_user_id
    created_by {
      id
      display_name
      email
      person {
        id
        name
        slug
        picture
      }
    }
    notes {
      id
      notes
    }
    created_at
    updated_at
    user_group_members {
      id
      user {
        id
        display_name
        email
        person {
          id
          slug
          picture
        }
      }
    }
    user_group_invites {
      id
      email
      created_at
      created_by_user_id
    }
    list_user_groups {
      id
      list_id
    }
  }
  user_groups_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetGroupsQuery = <
      TData = GetGroupsQuery,
      TError = Error
    >(
      variables: GetGroupsQueryVariables,
      options?: UseQueryOptions<GetGroupsQuery, TError, TData>
    ) =>
    useQuery<GetGroupsQuery, TError, TData>(
      ['GetGroups', variables],
      fetcher<GetGroupsQuery, GetGroupsQueryVariables>(GetGroupsDocument, variables),
      options
    );
useGetGroupsQuery.document = GetGroupsDocument;


useGetGroupsQuery.getKey = (variables: GetGroupsQueryVariables) => ['GetGroups', variables];
;

useGetGroupsQuery.fetcher = (variables: GetGroupsQueryVariables, options?: RequestInit['headers']) => fetcher<GetGroupsQuery, GetGroupsQueryVariables>(GetGroupsDocument, variables, options);
export const GetGroupDocument = `
    query GetGroup($id: Int!) {
  user_groups(where: {id: {_eq: $id}}) {
    id
    name
    description
    telegram
    twitter
    discord
    public
    created_by_user_id
    created_by {
      id
      display_name
      email
    }
    created_at
    updated_at
    user_group_members {
      id
      user {
        id
        display_name
        email
        person {
          id
          slug
          picture
        }
      }
    }
    user_group_invites {
      id
      email
      created_at
      created_by_user_id
    }
  }
}
    `;
export const useGetGroupQuery = <
      TData = GetGroupQuery,
      TError = Error
    >(
      variables: GetGroupQueryVariables,
      options?: UseQueryOptions<GetGroupQuery, TError, TData>
    ) =>
    useQuery<GetGroupQuery, TError, TData>(
      ['GetGroup', variables],
      fetcher<GetGroupQuery, GetGroupQueryVariables>(GetGroupDocument, variables),
      options
    );
useGetGroupQuery.document = GetGroupDocument;


useGetGroupQuery.getKey = (variables: GetGroupQueryVariables) => ['GetGroup', variables];
;

useGetGroupQuery.fetcher = (variables: GetGroupQueryVariables, options?: RequestInit['headers']) => fetcher<GetGroupQuery, GetGroupQueryVariables>(GetGroupDocument, variables, options);
export const InsertUserGroupDocument = `
    mutation InsertUserGroup($object: user_groups_insert_input!) {
  insert_user_groups_one(object: $object) {
    id
    name
    description
    twitter
    telegram
    discord
    created_at
    updated_at
    created_by_user_id
  }
}
    `;
export const useInsertUserGroupMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertUserGroupMutation, TError, InsertUserGroupMutationVariables, TContext>) =>
    useMutation<InsertUserGroupMutation, TError, InsertUserGroupMutationVariables, TContext>(
      ['InsertUserGroup'],
      (variables?: InsertUserGroupMutationVariables) => fetcher<InsertUserGroupMutation, InsertUserGroupMutationVariables>(InsertUserGroupDocument, variables)(),
      options
    );
useInsertUserGroupMutation.fetcher = (variables: InsertUserGroupMutationVariables, options?: RequestInit['headers']) => fetcher<InsertUserGroupMutation, InsertUserGroupMutationVariables>(InsertUserGroupDocument, variables, options);
export const UpdateUserGroupDocument = `
    mutation UpdateUserGroup($id: Int!, $changes: user_groups_set_input!) {
  update_user_groups(where: {id: {_eq: $id}}, _set: $changes) {
    affected_rows
    returning {
      id
      name
      description
      twitter
      telegram
      discord
      notes {
        id
        notes
      }
      created_at
      updated_at
      created_by_user_id
      created_by {
        id
        display_name
        email
      }
    }
  }
}
    `;
export const useUpdateUserGroupMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserGroupMutation, TError, UpdateUserGroupMutationVariables, TContext>) =>
    useMutation<UpdateUserGroupMutation, TError, UpdateUserGroupMutationVariables, TContext>(
      ['UpdateUserGroup'],
      (variables?: UpdateUserGroupMutationVariables) => fetcher<UpdateUserGroupMutation, UpdateUserGroupMutationVariables>(UpdateUserGroupDocument, variables)(),
      options
    );
useUpdateUserGroupMutation.fetcher = (variables: UpdateUserGroupMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserGroupMutation, UpdateUserGroupMutationVariables>(UpdateUserGroupDocument, variables, options);
export const DeleteUserGroupDocument = `
    mutation DeleteUserGroup($id: Int!) {
  delete_user_groups(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteUserGroupMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserGroupMutation, TError, DeleteUserGroupMutationVariables, TContext>) =>
    useMutation<DeleteUserGroupMutation, TError, DeleteUserGroupMutationVariables, TContext>(
      ['DeleteUserGroup'],
      (variables?: DeleteUserGroupMutationVariables) => fetcher<DeleteUserGroupMutation, DeleteUserGroupMutationVariables>(DeleteUserGroupDocument, variables)(),
      options
    );
useDeleteUserGroupMutation.fetcher = (variables: DeleteUserGroupMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserGroupMutation, DeleteUserGroupMutationVariables>(DeleteUserGroupDocument, variables, options);
export const DeleteUserGroupInvitesByGroupIdDocument = `
    mutation DeleteUserGroupInvitesByGroupId($groupId: Int!) {
  delete_user_group_invites(where: {user_group_id: {_eq: $groupId}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteUserGroupInvitesByGroupIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserGroupInvitesByGroupIdMutation, TError, DeleteUserGroupInvitesByGroupIdMutationVariables, TContext>) =>
    useMutation<DeleteUserGroupInvitesByGroupIdMutation, TError, DeleteUserGroupInvitesByGroupIdMutationVariables, TContext>(
      ['DeleteUserGroupInvitesByGroupId'],
      (variables?: DeleteUserGroupInvitesByGroupIdMutationVariables) => fetcher<DeleteUserGroupInvitesByGroupIdMutation, DeleteUserGroupInvitesByGroupIdMutationVariables>(DeleteUserGroupInvitesByGroupIdDocument, variables)(),
      options
    );
useDeleteUserGroupInvitesByGroupIdMutation.fetcher = (variables: DeleteUserGroupInvitesByGroupIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserGroupInvitesByGroupIdMutation, DeleteUserGroupInvitesByGroupIdMutationVariables>(DeleteUserGroupInvitesByGroupIdDocument, variables, options);
export const DeleteUserGroupMembersByGroupIdDocument = `
    mutation DeleteUserGroupMembersByGroupId($groupId: Int!) {
  delete_user_group_members(where: {user_group_id: {_eq: $groupId}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteUserGroupMembersByGroupIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserGroupMembersByGroupIdMutation, TError, DeleteUserGroupMembersByGroupIdMutationVariables, TContext>) =>
    useMutation<DeleteUserGroupMembersByGroupIdMutation, TError, DeleteUserGroupMembersByGroupIdMutationVariables, TContext>(
      ['DeleteUserGroupMembersByGroupId'],
      (variables?: DeleteUserGroupMembersByGroupIdMutationVariables) => fetcher<DeleteUserGroupMembersByGroupIdMutation, DeleteUserGroupMembersByGroupIdMutationVariables>(DeleteUserGroupMembersByGroupIdDocument, variables)(),
      options
    );
useDeleteUserGroupMembersByGroupIdMutation.fetcher = (variables: DeleteUserGroupMembersByGroupIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserGroupMembersByGroupIdMutation, DeleteUserGroupMembersByGroupIdMutationVariables>(DeleteUserGroupMembersByGroupIdDocument, variables, options);
export const GetUserGroupByIdDocument = `
    query GetUserGroupById($id: Int!) {
  user_groups(where: {id: {_eq: $id}}, limit: 1) {
    id
    name
    created_by_user_id
    created_at
  }
}
    `;
export const useGetUserGroupByIdQuery = <
      TData = GetUserGroupByIdQuery,
      TError = Error
    >(
      variables: GetUserGroupByIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupByIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupByIdQuery, TError, TData>(
      ['GetUserGroupById', variables],
      fetcher<GetUserGroupByIdQuery, GetUserGroupByIdQueryVariables>(GetUserGroupByIdDocument, variables),
      options
    );
useGetUserGroupByIdQuery.document = GetUserGroupByIdDocument;


useGetUserGroupByIdQuery.getKey = (variables: GetUserGroupByIdQueryVariables) => ['GetUserGroupById', variables];
;

useGetUserGroupByIdQuery.fetcher = (variables: GetUserGroupByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupByIdQuery, GetUserGroupByIdQueryVariables>(GetUserGroupByIdDocument, variables, options);
export const GetUserGroupMemberByIdDocument = `
    query GetUserGroupMemberById($id: Int!) {
  user_group_members(where: {id: {_eq: $id}}, limit: 1) {
    id
    user_id
    user_group_id
    user {
      id
      email
    }
  }
}
    `;
export const useGetUserGroupMemberByIdQuery = <
      TData = GetUserGroupMemberByIdQuery,
      TError = Error
    >(
      variables: GetUserGroupMemberByIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupMemberByIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupMemberByIdQuery, TError, TData>(
      ['GetUserGroupMemberById', variables],
      fetcher<GetUserGroupMemberByIdQuery, GetUserGroupMemberByIdQueryVariables>(GetUserGroupMemberByIdDocument, variables),
      options
    );
useGetUserGroupMemberByIdQuery.document = GetUserGroupMemberByIdDocument;


useGetUserGroupMemberByIdQuery.getKey = (variables: GetUserGroupMemberByIdQueryVariables) => ['GetUserGroupMemberById', variables];
;

useGetUserGroupMemberByIdQuery.fetcher = (variables: GetUserGroupMemberByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupMemberByIdQuery, GetUserGroupMemberByIdQueryVariables>(GetUserGroupMemberByIdDocument, variables, options);
export const GetUserGroupMemberByGroupIdDocument = `
    query GetUserGroupMemberByGroupId($user_group_id: Int!) {
  user_group_members(where: {user_group_id: {_eq: $user_group_id}}) {
    id
    user_group_id
    user_group {
      id
      name
      description
    }
    user_id
    user {
      id
      display_name
      email
    }
  }
}
    `;
export const useGetUserGroupMemberByGroupIdQuery = <
      TData = GetUserGroupMemberByGroupIdQuery,
      TError = Error
    >(
      variables: GetUserGroupMemberByGroupIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupMemberByGroupIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupMemberByGroupIdQuery, TError, TData>(
      ['GetUserGroupMemberByGroupId', variables],
      fetcher<GetUserGroupMemberByGroupIdQuery, GetUserGroupMemberByGroupIdQueryVariables>(GetUserGroupMemberByGroupIdDocument, variables),
      options
    );
useGetUserGroupMemberByGroupIdQuery.document = GetUserGroupMemberByGroupIdDocument;


useGetUserGroupMemberByGroupIdQuery.getKey = (variables: GetUserGroupMemberByGroupIdQueryVariables) => ['GetUserGroupMemberByGroupId', variables];
;

useGetUserGroupMemberByGroupIdQuery.fetcher = (variables: GetUserGroupMemberByGroupIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupMemberByGroupIdQuery, GetUserGroupMemberByGroupIdQueryVariables>(GetUserGroupMemberByGroupIdDocument, variables, options);
export const GetUserGroupInviteByIdDocument = `
    query GetUserGroupInviteById($id: Int!) {
  user_group_invites(where: {id: {_eq: $id}}, limit: 1) {
    id
    email
    user_group_id
    created_by_user_id
  }
}
    `;
export const useGetUserGroupInviteByIdQuery = <
      TData = GetUserGroupInviteByIdQuery,
      TError = Error
    >(
      variables: GetUserGroupInviteByIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupInviteByIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupInviteByIdQuery, TError, TData>(
      ['GetUserGroupInviteById', variables],
      fetcher<GetUserGroupInviteByIdQuery, GetUserGroupInviteByIdQueryVariables>(GetUserGroupInviteByIdDocument, variables),
      options
    );
useGetUserGroupInviteByIdQuery.document = GetUserGroupInviteByIdDocument;


useGetUserGroupInviteByIdQuery.getKey = (variables: GetUserGroupInviteByIdQueryVariables) => ['GetUserGroupInviteById', variables];
;

useGetUserGroupInviteByIdQuery.fetcher = (variables: GetUserGroupInviteByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupInviteByIdQuery, GetUserGroupInviteByIdQueryVariables>(GetUserGroupInviteByIdDocument, variables, options);
export const InsertUserGroupMembersDocument = `
    mutation InsertUserGroupMembers($object: user_group_members_insert_input!) {
  insert_user_group_members_one(object: $object) {
    id
    user_id
    user {
      id
      display_name
      email
      person {
        id
        slug
        picture
      }
    }
    user_group_id
    user_group {
      id
      name
    }
  }
}
    `;
export const useInsertUserGroupMembersMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertUserGroupMembersMutation, TError, InsertUserGroupMembersMutationVariables, TContext>) =>
    useMutation<InsertUserGroupMembersMutation, TError, InsertUserGroupMembersMutationVariables, TContext>(
      ['InsertUserGroupMembers'],
      (variables?: InsertUserGroupMembersMutationVariables) => fetcher<InsertUserGroupMembersMutation, InsertUserGroupMembersMutationVariables>(InsertUserGroupMembersDocument, variables)(),
      options
    );
useInsertUserGroupMembersMutation.fetcher = (variables: InsertUserGroupMembersMutationVariables, options?: RequestInit['headers']) => fetcher<InsertUserGroupMembersMutation, InsertUserGroupMembersMutationVariables>(InsertUserGroupMembersDocument, variables, options);
export const GetUserGroupInvitesByEmailDocument = `
    query GetUserGroupInvitesByEmail($email: String!) {
  user_group_invites(where: {email: {_eq: $email}}) {
    id
    user_group_id
  }
}
    `;
export const useGetUserGroupInvitesByEmailQuery = <
      TData = GetUserGroupInvitesByEmailQuery,
      TError = Error
    >(
      variables: GetUserGroupInvitesByEmailQueryVariables,
      options?: UseQueryOptions<GetUserGroupInvitesByEmailQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupInvitesByEmailQuery, TError, TData>(
      ['GetUserGroupInvitesByEmail', variables],
      fetcher<GetUserGroupInvitesByEmailQuery, GetUserGroupInvitesByEmailQueryVariables>(GetUserGroupInvitesByEmailDocument, variables),
      options
    );
useGetUserGroupInvitesByEmailQuery.document = GetUserGroupInvitesByEmailDocument;


useGetUserGroupInvitesByEmailQuery.getKey = (variables: GetUserGroupInvitesByEmailQueryVariables) => ['GetUserGroupInvitesByEmail', variables];
;

useGetUserGroupInvitesByEmailQuery.fetcher = (variables: GetUserGroupInvitesByEmailQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupInvitesByEmailQuery, GetUserGroupInvitesByEmailQueryVariables>(GetUserGroupInvitesByEmailDocument, variables, options);
export const GetUserGroupInvitesByEmailAndGroupIdDocument = `
    query GetUserGroupInvitesByEmailAndGroupId($email: String!, $user_group_id: Int!) {
  user_group_invites(
    where: {_and: [{email: {_eq: $email}}, {user_group_id: {_eq: $user_group_id}}]}
    limit: 1
  ) {
    id
    email
    user_group_id
    created_by_user_id
  }
}
    `;
export const useGetUserGroupInvitesByEmailAndGroupIdQuery = <
      TData = GetUserGroupInvitesByEmailAndGroupIdQuery,
      TError = Error
    >(
      variables: GetUserGroupInvitesByEmailAndGroupIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupInvitesByEmailAndGroupIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupInvitesByEmailAndGroupIdQuery, TError, TData>(
      ['GetUserGroupInvitesByEmailAndGroupId', variables],
      fetcher<GetUserGroupInvitesByEmailAndGroupIdQuery, GetUserGroupInvitesByEmailAndGroupIdQueryVariables>(GetUserGroupInvitesByEmailAndGroupIdDocument, variables),
      options
    );
useGetUserGroupInvitesByEmailAndGroupIdQuery.document = GetUserGroupInvitesByEmailAndGroupIdDocument;


useGetUserGroupInvitesByEmailAndGroupIdQuery.getKey = (variables: GetUserGroupInvitesByEmailAndGroupIdQueryVariables) => ['GetUserGroupInvitesByEmailAndGroupId', variables];
;

useGetUserGroupInvitesByEmailAndGroupIdQuery.fetcher = (variables: GetUserGroupInvitesByEmailAndGroupIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupInvitesByEmailAndGroupIdQuery, GetUserGroupInvitesByEmailAndGroupIdQueryVariables>(GetUserGroupInvitesByEmailAndGroupIdDocument, variables, options);
export const GetUserGroupMembersByUserIdAndGroupIdDocument = `
    query GetUserGroupMembersByUserIdAndGroupId($user_id: Int!, $user_group_id: Int!) {
  user_group_members(
    where: {_and: [{user_id: {_eq: $user_id}}, {user_group_id: {_eq: $user_group_id}}]}
    limit: 1
  ) {
    id
    user_id
    user_group_id
  }
}
    `;
export const useGetUserGroupMembersByUserIdAndGroupIdQuery = <
      TData = GetUserGroupMembersByUserIdAndGroupIdQuery,
      TError = Error
    >(
      variables: GetUserGroupMembersByUserIdAndGroupIdQueryVariables,
      options?: UseQueryOptions<GetUserGroupMembersByUserIdAndGroupIdQuery, TError, TData>
    ) =>
    useQuery<GetUserGroupMembersByUserIdAndGroupIdQuery, TError, TData>(
      ['GetUserGroupMembersByUserIdAndGroupId', variables],
      fetcher<GetUserGroupMembersByUserIdAndGroupIdQuery, GetUserGroupMembersByUserIdAndGroupIdQueryVariables>(GetUserGroupMembersByUserIdAndGroupIdDocument, variables),
      options
    );
useGetUserGroupMembersByUserIdAndGroupIdQuery.document = GetUserGroupMembersByUserIdAndGroupIdDocument;


useGetUserGroupMembersByUserIdAndGroupIdQuery.getKey = (variables: GetUserGroupMembersByUserIdAndGroupIdQueryVariables) => ['GetUserGroupMembersByUserIdAndGroupId', variables];
;

useGetUserGroupMembersByUserIdAndGroupIdQuery.fetcher = (variables: GetUserGroupMembersByUserIdAndGroupIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserGroupMembersByUserIdAndGroupIdQuery, GetUserGroupMembersByUserIdAndGroupIdQueryVariables>(GetUserGroupMembersByUserIdAndGroupIdDocument, variables, options);
export const DeleteUserGroupInviteByIdDocument = `
    mutation DeleteUserGroupInviteById($id: Int!) {
  delete_user_group_invites(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteUserGroupInviteByIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserGroupInviteByIdMutation, TError, DeleteUserGroupInviteByIdMutationVariables, TContext>) =>
    useMutation<DeleteUserGroupInviteByIdMutation, TError, DeleteUserGroupInviteByIdMutationVariables, TContext>(
      ['DeleteUserGroupInviteById'],
      (variables?: DeleteUserGroupInviteByIdMutationVariables) => fetcher<DeleteUserGroupInviteByIdMutation, DeleteUserGroupInviteByIdMutationVariables>(DeleteUserGroupInviteByIdDocument, variables)(),
      options
    );
useDeleteUserGroupInviteByIdMutation.fetcher = (variables: DeleteUserGroupInviteByIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserGroupInviteByIdMutation, DeleteUserGroupInviteByIdMutationVariables>(DeleteUserGroupInviteByIdDocument, variables, options);
export const DeleteUserGroupMemberByIdDocument = `
    mutation DeleteUserGroupMemberById($id: Int!) {
  delete_user_group_members(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteUserGroupMemberByIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteUserGroupMemberByIdMutation, TError, DeleteUserGroupMemberByIdMutationVariables, TContext>) =>
    useMutation<DeleteUserGroupMemberByIdMutation, TError, DeleteUserGroupMemberByIdMutationVariables, TContext>(
      ['DeleteUserGroupMemberById'],
      (variables?: DeleteUserGroupMemberByIdMutationVariables) => fetcher<DeleteUserGroupMemberByIdMutation, DeleteUserGroupMemberByIdMutationVariables>(DeleteUserGroupMemberByIdDocument, variables)(),
      options
    );
useDeleteUserGroupMemberByIdMutation.fetcher = (variables: DeleteUserGroupMemberByIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteUserGroupMemberByIdMutation, DeleteUserGroupMemberByIdMutationVariables>(DeleteUserGroupMemberByIdDocument, variables, options);
export const InsertUserGroupInvitesDocument = `
    mutation InsertUserGroupInvites($object: user_group_invites_insert_input!) {
  insert_user_group_invites_one(object: $object) {
    id
    email
    user_group_id
    created_by_user_id
  }
}
    `;
export const useInsertUserGroupInvitesMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertUserGroupInvitesMutation, TError, InsertUserGroupInvitesMutationVariables, TContext>) =>
    useMutation<InsertUserGroupInvitesMutation, TError, InsertUserGroupInvitesMutationVariables, TContext>(
      ['InsertUserGroupInvites'],
      (variables?: InsertUserGroupInvitesMutationVariables) => fetcher<InsertUserGroupInvitesMutation, InsertUserGroupInvitesMutationVariables>(InsertUserGroupInvitesDocument, variables)(),
      options
    );
useInsertUserGroupInvitesMutation.fetcher = (variables: InsertUserGroupInvitesMutationVariables, options?: RequestInit['headers']) => fetcher<InsertUserGroupInvitesMutation, InsertUserGroupInvitesMutationVariables>(InsertUserGroupInvitesDocument, variables, options);
export const UpsertInvestmentRoundDocument = `
    mutation UpsertInvestmentRound($data: investment_rounds_insert_input!) {
  insert_investment_rounds_one(
    object: $data
    on_conflict: {constraint: investment_rounds_pkey, update_columns: [round_date, round, amount, valuation, currency]}
  ) {
    id
    round_date
    round
    amount
    valuation
    currency
  }
}
    `;
export const useUpsertInvestmentRoundMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertInvestmentRoundMutation, TError, UpsertInvestmentRoundMutationVariables, TContext>) =>
    useMutation<UpsertInvestmentRoundMutation, TError, UpsertInvestmentRoundMutationVariables, TContext>(
      ['UpsertInvestmentRound'],
      (variables?: UpsertInvestmentRoundMutationVariables) => fetcher<UpsertInvestmentRoundMutation, UpsertInvestmentRoundMutationVariables>(UpsertInvestmentRoundDocument, variables)(),
      options
    );
useUpsertInvestmentRoundMutation.fetcher = (variables: UpsertInvestmentRoundMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertInvestmentRoundMutation, UpsertInvestmentRoundMutationVariables>(UpsertInvestmentRoundDocument, variables, options);
export const GetInvestmentRoundByRoundIdDocument = `
    query GetInvestmentRoundByRoundId($round_id: Int!) {
  investment_rounds(where: {id: {_eq: $round_id}}) {
    id
    company_id
  }
}
    `;
export const useGetInvestmentRoundByRoundIdQuery = <
      TData = GetInvestmentRoundByRoundIdQuery,
      TError = Error
    >(
      variables: GetInvestmentRoundByRoundIdQueryVariables,
      options?: UseQueryOptions<GetInvestmentRoundByRoundIdQuery, TError, TData>
    ) =>
    useQuery<GetInvestmentRoundByRoundIdQuery, TError, TData>(
      ['GetInvestmentRoundByRoundId', variables],
      fetcher<GetInvestmentRoundByRoundIdQuery, GetInvestmentRoundByRoundIdQueryVariables>(GetInvestmentRoundByRoundIdDocument, variables),
      options
    );
useGetInvestmentRoundByRoundIdQuery.document = GetInvestmentRoundByRoundIdDocument;


useGetInvestmentRoundByRoundIdQuery.getKey = (variables: GetInvestmentRoundByRoundIdQueryVariables) => ['GetInvestmentRoundByRoundId', variables];
;

useGetInvestmentRoundByRoundIdQuery.fetcher = (variables: GetInvestmentRoundByRoundIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestmentRoundByRoundIdQuery, GetInvestmentRoundByRoundIdQueryVariables>(GetInvestmentRoundByRoundIdDocument, variables, options);
export const GetInvestmentRoundByIdDocument = `
    query GetInvestmentRoundById($id: Int!) {
  investment_rounds(where: {id: {_eq: $id}}, limit: 1) {
    id
    round
    company_id
    status
    company {
      id
      name
      slug
    }
  }
}
    `;
export const useGetInvestmentRoundByIdQuery = <
      TData = GetInvestmentRoundByIdQuery,
      TError = Error
    >(
      variables: GetInvestmentRoundByIdQueryVariables,
      options?: UseQueryOptions<GetInvestmentRoundByIdQuery, TError, TData>
    ) =>
    useQuery<GetInvestmentRoundByIdQuery, TError, TData>(
      ['GetInvestmentRoundById', variables],
      fetcher<GetInvestmentRoundByIdQuery, GetInvestmentRoundByIdQueryVariables>(GetInvestmentRoundByIdDocument, variables),
      options
    );
useGetInvestmentRoundByIdQuery.document = GetInvestmentRoundByIdDocument;


useGetInvestmentRoundByIdQuery.getKey = (variables: GetInvestmentRoundByIdQueryVariables) => ['GetInvestmentRoundById', variables];
;

useGetInvestmentRoundByIdQuery.fetcher = (variables: GetInvestmentRoundByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestmentRoundByIdQuery, GetInvestmentRoundByIdQueryVariables>(GetInvestmentRoundByIdDocument, variables, options);
export const GetInvestmentInsightByLocationDocument = `
    query GetInvestmentInsightByLocation($where: investment_rounds_bool_exp!) {
  investment_rounds_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetInvestmentInsightByLocationQuery = <
      TData = GetInvestmentInsightByLocationQuery,
      TError = Error
    >(
      variables: GetInvestmentInsightByLocationQueryVariables,
      options?: UseQueryOptions<GetInvestmentInsightByLocationQuery, TError, TData>
    ) =>
    useQuery<GetInvestmentInsightByLocationQuery, TError, TData>(
      ['GetInvestmentInsightByLocation', variables],
      fetcher<GetInvestmentInsightByLocationQuery, GetInvestmentInsightByLocationQueryVariables>(GetInvestmentInsightByLocationDocument, variables),
      options
    );
useGetInvestmentInsightByLocationQuery.document = GetInvestmentInsightByLocationDocument;


useGetInvestmentInsightByLocationQuery.getKey = (variables: GetInvestmentInsightByLocationQueryVariables) => ['GetInvestmentInsightByLocation', variables];
;

useGetInvestmentInsightByLocationQuery.fetcher = (variables: GetInvestmentInsightByLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestmentInsightByLocationQuery, GetInvestmentInsightByLocationQueryVariables>(GetInvestmentInsightByLocationDocument, variables, options);
export const UpsertInvestmentsDocument = `
    mutation UpsertInvestments($data: [investments_insert_input!]!) {
  insert_investments(
    objects: $data
    on_conflict: {constraint: investments_pkey, update_columns: [amount]}
  ) {
    returning {
      id
      round_id
      person_id
      vc_firm_id
      amount
    }
  }
}
    `;
export const useUpsertInvestmentsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertInvestmentsMutation, TError, UpsertInvestmentsMutationVariables, TContext>) =>
    useMutation<UpsertInvestmentsMutation, TError, UpsertInvestmentsMutationVariables, TContext>(
      ['UpsertInvestments'],
      (variables?: UpsertInvestmentsMutationVariables) => fetcher<UpsertInvestmentsMutation, UpsertInvestmentsMutationVariables>(UpsertInvestmentsDocument, variables)(),
      options
    );
useUpsertInvestmentsMutation.fetcher = (variables: UpsertInvestmentsMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertInvestmentsMutation, UpsertInvestmentsMutationVariables>(UpsertInvestmentsDocument, variables, options);
export const DeleteInvestmentDocument = `
    mutation DeleteInvestment($investmentId: Int!) {
  delete_investments_by_pk(id: $investmentId) {
    id
  }
}
    `;
export const useDeleteInvestmentMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteInvestmentMutation, TError, DeleteInvestmentMutationVariables, TContext>) =>
    useMutation<DeleteInvestmentMutation, TError, DeleteInvestmentMutationVariables, TContext>(
      ['DeleteInvestment'],
      (variables?: DeleteInvestmentMutationVariables) => fetcher<DeleteInvestmentMutation, DeleteInvestmentMutationVariables>(DeleteInvestmentDocument, variables)(),
      options
    );
useDeleteInvestmentMutation.fetcher = (variables: DeleteInvestmentMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteInvestmentMutation, DeleteInvestmentMutationVariables>(DeleteInvestmentDocument, variables, options);
export const GetInvestmentByIdDocument = `
    query GetInvestmentById($id: Int!) {
  investments(where: {id: {_eq: $id}}, limit: 1) {
    id
    vc_firm_id
    round_id
    status
  }
}
    `;
export const useGetInvestmentByIdQuery = <
      TData = GetInvestmentByIdQuery,
      TError = Error
    >(
      variables: GetInvestmentByIdQueryVariables,
      options?: UseQueryOptions<GetInvestmentByIdQuery, TError, TData>
    ) =>
    useQuery<GetInvestmentByIdQuery, TError, TData>(
      ['GetInvestmentById', variables],
      fetcher<GetInvestmentByIdQuery, GetInvestmentByIdQueryVariables>(GetInvestmentByIdDocument, variables),
      options
    );
useGetInvestmentByIdQuery.document = GetInvestmentByIdDocument;


useGetInvestmentByIdQuery.getKey = (variables: GetInvestmentByIdQueryVariables) => ['GetInvestmentById', variables];
;

useGetInvestmentByIdQuery.fetcher = (variables: GetInvestmentByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestmentByIdQuery, GetInvestmentByIdQueryVariables>(GetInvestmentByIdDocument, variables, options);
export const InsertInvestorDocument = `
    mutation InsertInvestor($personId: Int, $vcFirmId: Int) {
  insert_investors_one(
    object: {person_id: $personId, vc_firm_id: $vcFirmId}
    on_conflict: {constraint: investors_vc_firm_id_person_id_key, update_columns: []}
  ) {
    id
  }
}
    `;
export const useInsertInvestorMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertInvestorMutation, TError, InsertInvestorMutationVariables, TContext>) =>
    useMutation<InsertInvestorMutation, TError, InsertInvestorMutationVariables, TContext>(
      ['InsertInvestor'],
      (variables?: InsertInvestorMutationVariables) => fetcher<InsertInvestorMutation, InsertInvestorMutationVariables>(InsertInvestorDocument, variables)(),
      options
    );
useInsertInvestorMutation.fetcher = (variables?: InsertInvestorMutationVariables, options?: RequestInit['headers']) => fetcher<InsertInvestorMutation, InsertInvestorMutationVariables>(InsertInvestorDocument, variables, options);
export const GetInvestorByIdDocument = `
    query GetInvestorById($id: Int!) {
  investors(where: {id: {_eq: $id}}, limit: 1) {
    id
    vc_firm_id
    person_id
    person {
      id
      name
      slug
      status
    }
  }
}
    `;
export const useGetInvestorByIdQuery = <
      TData = GetInvestorByIdQuery,
      TError = Error
    >(
      variables: GetInvestorByIdQueryVariables,
      options?: UseQueryOptions<GetInvestorByIdQuery, TError, TData>
    ) =>
    useQuery<GetInvestorByIdQuery, TError, TData>(
      ['GetInvestorById', variables],
      fetcher<GetInvestorByIdQuery, GetInvestorByIdQueryVariables>(GetInvestorByIdDocument, variables),
      options
    );
useGetInvestorByIdQuery.document = GetInvestorByIdDocument;


useGetInvestorByIdQuery.getKey = (variables: GetInvestorByIdQueryVariables) => ['GetInvestorById', variables];
;

useGetInvestorByIdQuery.fetcher = (variables: GetInvestorByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestorByIdQuery, GetInvestorByIdQueryVariables>(GetInvestorByIdDocument, variables, options);
export const GetInvestorByPersonIdDocument = `
    query GetInvestorByPersonId($personId: Int!) {
  investors(where: {person_id: {_eq: $personId}}, limit: 1) {
    id
    vc_firm_id
    person_id
    person {
      id
      name
      slug
      status
    }
    vc_firm {
      name
    }
  }
}
    `;
export const useGetInvestorByPersonIdQuery = <
      TData = GetInvestorByPersonIdQuery,
      TError = Error
    >(
      variables: GetInvestorByPersonIdQueryVariables,
      options?: UseQueryOptions<GetInvestorByPersonIdQuery, TError, TData>
    ) =>
    useQuery<GetInvestorByPersonIdQuery, TError, TData>(
      ['GetInvestorByPersonId', variables],
      fetcher<GetInvestorByPersonIdQuery, GetInvestorByPersonIdQueryVariables>(GetInvestorByPersonIdDocument, variables),
      options
    );
useGetInvestorByPersonIdQuery.document = GetInvestorByPersonIdDocument;


useGetInvestorByPersonIdQuery.getKey = (variables: GetInvestorByPersonIdQueryVariables) => ['GetInvestorByPersonId', variables];
;

useGetInvestorByPersonIdQuery.fetcher = (variables: GetInvestorByPersonIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestorByPersonIdQuery, GetInvestorByPersonIdQueryVariables>(GetInvestorByPersonIdDocument, variables, options);
export const GetInvestorMailingListDocument = `
    query GetInvestorMailingList($personId: Int!) {
  investors(where: {person_id: {_eq: $personId}}) {
    id
    vc_firm {
      investments {
        investment_round {
          company {
            id
            name
            logo
            slug
            teamMembers(where: {email_address: {_is_null: false}}) {
              id
              person_id
            }
            teamMembers_aggregate(where: {email_address: {_is_null: false}}) {
              aggregate {
                count
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const useGetInvestorMailingListQuery = <
      TData = GetInvestorMailingListQuery,
      TError = Error
    >(
      variables: GetInvestorMailingListQueryVariables,
      options?: UseQueryOptions<GetInvestorMailingListQuery, TError, TData>
    ) =>
    useQuery<GetInvestorMailingListQuery, TError, TData>(
      ['GetInvestorMailingList', variables],
      fetcher<GetInvestorMailingListQuery, GetInvestorMailingListQueryVariables>(GetInvestorMailingListDocument, variables),
      options
    );
useGetInvestorMailingListQuery.document = GetInvestorMailingListDocument;


useGetInvestorMailingListQuery.getKey = (variables: GetInvestorMailingListQueryVariables) => ['GetInvestorMailingList', variables];
;

useGetInvestorMailingListQuery.fetcher = (variables: GetInvestorMailingListQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestorMailingListQuery, GetInvestorMailingListQueryVariables>(GetInvestorMailingListDocument, variables, options);
export const GetAdminInvestorMailingListDocument = `
    query GetAdminInvestorMailingList($personId: Int!, $companyIds: [Int!]) {
  investors(where: {person_id: {_eq: $personId}}) {
    id
    vc_firm {
      investments(where: {investment_round: {company: {id: {_in: $companyIds}}}}) {
        investment_round {
          company {
            id
            teamMembers(where: {email_address: {_is_null: false}}) {
              id
              email_address
              person_id
              person {
                name
              }
            }
            teamMembers_aggregate(where: {email_address: {_is_null: false}}) {
              aggregate {
                count
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const useGetAdminInvestorMailingListQuery = <
      TData = GetAdminInvestorMailingListQuery,
      TError = Error
    >(
      variables: GetAdminInvestorMailingListQueryVariables,
      options?: UseQueryOptions<GetAdminInvestorMailingListQuery, TError, TData>
    ) =>
    useQuery<GetAdminInvestorMailingListQuery, TError, TData>(
      ['GetAdminInvestorMailingList', variables],
      fetcher<GetAdminInvestorMailingListQuery, GetAdminInvestorMailingListQueryVariables>(GetAdminInvestorMailingListDocument, variables),
      options
    );
useGetAdminInvestorMailingListQuery.document = GetAdminInvestorMailingListDocument;


useGetAdminInvestorMailingListQuery.getKey = (variables: GetAdminInvestorMailingListQueryVariables) => ['GetAdminInvestorMailingList', variables];
;

useGetAdminInvestorMailingListQuery.fetcher = (variables: GetAdminInvestorMailingListQueryVariables, options?: RequestInit['headers']) => fetcher<GetAdminInvestorMailingListQuery, GetAdminInvestorMailingListQueryVariables>(GetAdminInvestorMailingListDocument, variables, options);
export const GetInvitedPeopleByUserIdDocument = `
    query GetInvitedPeopleByUserId($userId: Int!) {
  invited_people(where: {inviter_user_id: {_eq: $userId}}) {
    id
    person_id
    inviter_user_id
    created_at
  }
}
    `;
export const useGetInvitedPeopleByUserIdQuery = <
      TData = GetInvitedPeopleByUserIdQuery,
      TError = Error
    >(
      variables: GetInvitedPeopleByUserIdQueryVariables,
      options?: UseQueryOptions<GetInvitedPeopleByUserIdQuery, TError, TData>
    ) =>
    useQuery<GetInvitedPeopleByUserIdQuery, TError, TData>(
      ['GetInvitedPeopleByUserId', variables],
      fetcher<GetInvitedPeopleByUserIdQuery, GetInvitedPeopleByUserIdQueryVariables>(GetInvitedPeopleByUserIdDocument, variables),
      options
    );
useGetInvitedPeopleByUserIdQuery.document = GetInvitedPeopleByUserIdDocument;


useGetInvitedPeopleByUserIdQuery.getKey = (variables: GetInvitedPeopleByUserIdQueryVariables) => ['GetInvitedPeopleByUserId', variables];
;

useGetInvitedPeopleByUserIdQuery.fetcher = (variables: GetInvitedPeopleByUserIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvitedPeopleByUserIdQuery, GetInvitedPeopleByUserIdQueryVariables>(GetInvitedPeopleByUserIdDocument, variables, options);
export const InsertInvitedPeopleDocument = `
    mutation InsertInvitedPeople($personId: Int!, $userId: Int!) {
  insert_invited_people_one(
    object: {person_id: $personId, inviter_user_id: $userId}
  ) {
    id
    person_id
    inviter_user_id
    created_at
  }
}
    `;
export const useInsertInvitedPeopleMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertInvitedPeopleMutation, TError, InsertInvitedPeopleMutationVariables, TContext>) =>
    useMutation<InsertInvitedPeopleMutation, TError, InsertInvitedPeopleMutationVariables, TContext>(
      ['InsertInvitedPeople'],
      (variables?: InsertInvitedPeopleMutationVariables) => fetcher<InsertInvitedPeopleMutation, InsertInvitedPeopleMutationVariables>(InsertInvitedPeopleDocument, variables)(),
      options
    );
useInsertInvitedPeopleMutation.fetcher = (variables: InsertInvitedPeopleMutationVariables, options?: RequestInit['headers']) => fetcher<InsertInvitedPeopleMutation, InsertInvitedPeopleMutationVariables>(InsertInvitedPeopleDocument, variables, options);
export const InsertLeadsDocument = `
    mutation InsertLeads($object: leads_insert_input!) {
  insert_leads_one(object: $object) {
    id
  }
}
    `;
export const useInsertLeadsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertLeadsMutation, TError, InsertLeadsMutationVariables, TContext>) =>
    useMutation<InsertLeadsMutation, TError, InsertLeadsMutationVariables, TContext>(
      ['InsertLeads'],
      (variables?: InsertLeadsMutationVariables) => fetcher<InsertLeadsMutation, InsertLeadsMutationVariables>(InsertLeadsDocument, variables)(),
      options
    );
useInsertLeadsMutation.fetcher = (variables: InsertLeadsMutationVariables, options?: RequestInit['headers']) => fetcher<InsertLeadsMutation, InsertLeadsMutationVariables>(InsertLeadsDocument, variables, options);
export const InsertLeadsSegmentationDocument = `
    mutation InsertLeadsSegmentation($object: leads_segmentation_insert_input!) {
  insert_leads_segmentation_one(object: $object) {
    id
  }
}
    `;
export const useInsertLeadsSegmentationMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertLeadsSegmentationMutation, TError, InsertLeadsSegmentationMutationVariables, TContext>) =>
    useMutation<InsertLeadsSegmentationMutation, TError, InsertLeadsSegmentationMutationVariables, TContext>(
      ['InsertLeadsSegmentation'],
      (variables?: InsertLeadsSegmentationMutationVariables) => fetcher<InsertLeadsSegmentationMutation, InsertLeadsSegmentationMutationVariables>(InsertLeadsSegmentationDocument, variables)(),
      options
    );
useInsertLeadsSegmentationMutation.fetcher = (variables: InsertLeadsSegmentationMutationVariables, options?: RequestInit['headers']) => fetcher<InsertLeadsSegmentationMutation, InsertLeadsSegmentationMutationVariables>(InsertLeadsSegmentationDocument, variables, options);
export const GetListUserGroupsDocument = `
    query GetListUserGroups($where: list_user_groups_bool_exp!) {
  list_user_groups(where: $where) {
    id
    list_id
    list {
      id
      name
      description
      public
      created_at
      created_by {
        id
        display_name
        email
      }
    }
    user_group_id
    user_group {
      id
      name
    }
  }
}
    `;
export const useGetListUserGroupsQuery = <
      TData = GetListUserGroupsQuery,
      TError = Error
    >(
      variables: GetListUserGroupsQueryVariables,
      options?: UseQueryOptions<GetListUserGroupsQuery, TError, TData>
    ) =>
    useQuery<GetListUserGroupsQuery, TError, TData>(
      ['GetListUserGroups', variables],
      fetcher<GetListUserGroupsQuery, GetListUserGroupsQueryVariables>(GetListUserGroupsDocument, variables),
      options
    );
useGetListUserGroupsQuery.document = GetListUserGroupsDocument;


useGetListUserGroupsQuery.getKey = (variables: GetListUserGroupsQueryVariables) => ['GetListUserGroups', variables];
;

useGetListUserGroupsQuery.fetcher = (variables: GetListUserGroupsQueryVariables, options?: RequestInit['headers']) => fetcher<GetListUserGroupsQuery, GetListUserGroupsQueryVariables>(GetListUserGroupsDocument, variables, options);
export const GetListMembersDocument = `
    query GetListMembers($where: list_members_bool_exp!) {
  list_members(where: $where) {
    id
    member_type
    list_id
    list {
      id
      name
      public
      created_at
      created_by {
        id
        display_name
        email
      }
    }
    user_id
    user {
      id
      display_name
      email
    }
  }
}
    `;
export const useGetListMembersQuery = <
      TData = GetListMembersQuery,
      TError = Error
    >(
      variables: GetListMembersQueryVariables,
      options?: UseQueryOptions<GetListMembersQuery, TError, TData>
    ) =>
    useQuery<GetListMembersQuery, TError, TData>(
      ['GetListMembers', variables],
      fetcher<GetListMembersQuery, GetListMembersQueryVariables>(GetListMembersDocument, variables),
      options
    );
useGetListMembersQuery.document = GetListMembersDocument;


useGetListMembersQuery.getKey = (variables: GetListMembersQueryVariables) => ['GetListMembers', variables];
;

useGetListMembersQuery.fetcher = (variables: GetListMembersQueryVariables, options?: RequestInit['headers']) => fetcher<GetListMembersQuery, GetListMembersQueryVariables>(GetListMembersDocument, variables, options);
export const GetListUserGroupsByListIdDocument = `
    query GetListUserGroupsByListId($listId: Int!) {
  list_user_groups(where: {list_id: {_eq: $listId}}) {
    id
    list_id
    user_group_id
  }
}
    `;
export const useGetListUserGroupsByListIdQuery = <
      TData = GetListUserGroupsByListIdQuery,
      TError = Error
    >(
      variables: GetListUserGroupsByListIdQueryVariables,
      options?: UseQueryOptions<GetListUserGroupsByListIdQuery, TError, TData>
    ) =>
    useQuery<GetListUserGroupsByListIdQuery, TError, TData>(
      ['GetListUserGroupsByListId', variables],
      fetcher<GetListUserGroupsByListIdQuery, GetListUserGroupsByListIdQueryVariables>(GetListUserGroupsByListIdDocument, variables),
      options
    );
useGetListUserGroupsByListIdQuery.document = GetListUserGroupsByListIdDocument;


useGetListUserGroupsByListIdQuery.getKey = (variables: GetListUserGroupsByListIdQueryVariables) => ['GetListUserGroupsByListId', variables];
;

useGetListUserGroupsByListIdQuery.fetcher = (variables: GetListUserGroupsByListIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetListUserGroupsByListIdQuery, GetListUserGroupsByListIdQueryVariables>(GetListUserGroupsByListIdDocument, variables, options);
export const InsertListUserGroupsDocument = `
    mutation InsertListUserGroups($object: list_user_groups_insert_input!) {
  insert_list_user_groups_one(object: $object) {
    id
    list_id
    user_group_id
  }
}
    `;
export const useInsertListUserGroupsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertListUserGroupsMutation, TError, InsertListUserGroupsMutationVariables, TContext>) =>
    useMutation<InsertListUserGroupsMutation, TError, InsertListUserGroupsMutationVariables, TContext>(
      ['InsertListUserGroups'],
      (variables?: InsertListUserGroupsMutationVariables) => fetcher<InsertListUserGroupsMutation, InsertListUserGroupsMutationVariables>(InsertListUserGroupsDocument, variables)(),
      options
    );
useInsertListUserGroupsMutation.fetcher = (variables: InsertListUserGroupsMutationVariables, options?: RequestInit['headers']) => fetcher<InsertListUserGroupsMutation, InsertListUserGroupsMutationVariables>(InsertListUserGroupsDocument, variables, options);
export const GetListUserGroupsByListIdAndGroupIdDocument = `
    query GetListUserGroupsByListIdAndGroupId($list_id: Int!, $user_group_id: Int!) {
  list_user_groups(
    where: {_and: [{list_id: {_eq: $list_id}}, {user_group_id: {_eq: $user_group_id}}]}
  ) {
    id
    list_id
    user_group_id
  }
}
    `;
export const useGetListUserGroupsByListIdAndGroupIdQuery = <
      TData = GetListUserGroupsByListIdAndGroupIdQuery,
      TError = Error
    >(
      variables: GetListUserGroupsByListIdAndGroupIdQueryVariables,
      options?: UseQueryOptions<GetListUserGroupsByListIdAndGroupIdQuery, TError, TData>
    ) =>
    useQuery<GetListUserGroupsByListIdAndGroupIdQuery, TError, TData>(
      ['GetListUserGroupsByListIdAndGroupId', variables],
      fetcher<GetListUserGroupsByListIdAndGroupIdQuery, GetListUserGroupsByListIdAndGroupIdQueryVariables>(GetListUserGroupsByListIdAndGroupIdDocument, variables),
      options
    );
useGetListUserGroupsByListIdAndGroupIdQuery.document = GetListUserGroupsByListIdAndGroupIdDocument;


useGetListUserGroupsByListIdAndGroupIdQuery.getKey = (variables: GetListUserGroupsByListIdAndGroupIdQueryVariables) => ['GetListUserGroupsByListIdAndGroupId', variables];
;

useGetListUserGroupsByListIdAndGroupIdQuery.fetcher = (variables: GetListUserGroupsByListIdAndGroupIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetListUserGroupsByListIdAndGroupIdQuery, GetListUserGroupsByListIdAndGroupIdQueryVariables>(GetListUserGroupsByListIdAndGroupIdDocument, variables, options);
export const UpsertListDocument = `
    mutation UpsertList($userId: Int, $name: String, $public: Boolean = true) {
  insert_lists_one(
    object: {created_by_id: $userId, name: $name, public: $public}
    on_conflict: {constraint: lists_created_by_id_name_key, update_columns: [created_by_id, public]}
  ) {
    id
  }
}
    `;
export const useUpsertListMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertListMutation, TError, UpsertListMutationVariables, TContext>) =>
    useMutation<UpsertListMutation, TError, UpsertListMutationVariables, TContext>(
      ['UpsertList'],
      (variables?: UpsertListMutationVariables) => fetcher<UpsertListMutation, UpsertListMutationVariables>(UpsertListDocument, variables)(),
      options
    );
useUpsertListMutation.fetcher = (variables?: UpsertListMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertListMutation, UpsertListMutationVariables>(UpsertListDocument, variables, options);
export const UpsertMembershipDocument = `
    mutation UpsertMembership($userId: Int!, $listId: Int!) {
  insert_list_members_one(
    object: {user_id: $userId, list_id: $listId, member_type: "owner"}
    on_conflict: {update_columns: user_id, constraint: list_members_list_id_user_id_key}
  ) {
    id
  }
}
    `;
export const useUpsertMembershipMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertMembershipMutation, TError, UpsertMembershipMutationVariables, TContext>) =>
    useMutation<UpsertMembershipMutation, TError, UpsertMembershipMutationVariables, TContext>(
      ['UpsertMembership'],
      (variables?: UpsertMembershipMutationVariables) => fetcher<UpsertMembershipMutation, UpsertMembershipMutationVariables>(UpsertMembershipDocument, variables)(),
      options
    );
useUpsertMembershipMutation.fetcher = (variables: UpsertMembershipMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertMembershipMutation, UpsertMembershipMutationVariables>(UpsertMembershipDocument, variables, options);
export const GetListByIdDocument = `
    query GetListById($id: Int!) {
  lists(where: {id: {_eq: $id}}, limit: 1) {
    id
    name
    created_by_id
  }
}
    `;
export const useGetListByIdQuery = <
      TData = GetListByIdQuery,
      TError = Error
    >(
      variables: GetListByIdQueryVariables,
      options?: UseQueryOptions<GetListByIdQuery, TError, TData>
    ) =>
    useQuery<GetListByIdQuery, TError, TData>(
      ['GetListById', variables],
      fetcher<GetListByIdQuery, GetListByIdQueryVariables>(GetListByIdDocument, variables),
      options
    );
useGetListByIdQuery.document = GetListByIdDocument;


useGetListByIdQuery.getKey = (variables: GetListByIdQueryVariables) => ['GetListById', variables];
;

useGetListByIdQuery.fetcher = (variables: GetListByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetListByIdQuery, GetListByIdQueryVariables>(GetListByIdDocument, variables, options);
export const DeleteListMembersDocument = `
    mutation DeleteListMembers($where: list_members_bool_exp!) {
  delete_list_members(where: $where) {
    returning {
      id
    }
  }
}
    `;
export const useDeleteListMembersMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteListMembersMutation, TError, DeleteListMembersMutationVariables, TContext>) =>
    useMutation<DeleteListMembersMutation, TError, DeleteListMembersMutationVariables, TContext>(
      ['DeleteListMembers'],
      (variables?: DeleteListMembersMutationVariables) => fetcher<DeleteListMembersMutation, DeleteListMembersMutationVariables>(DeleteListMembersDocument, variables)(),
      options
    );
useDeleteListMembersMutation.fetcher = (variables: DeleteListMembersMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteListMembersMutation, DeleteListMembersMutationVariables>(DeleteListMembersDocument, variables, options);
export const DeleteListsDocument = `
    mutation DeleteLists($where: lists_bool_exp!) {
  delete_lists(where: $where) {
    returning {
      id
    }
  }
}
    `;
export const useDeleteListsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteListsMutation, TError, DeleteListsMutationVariables, TContext>) =>
    useMutation<DeleteListsMutation, TError, DeleteListsMutationVariables, TContext>(
      ['DeleteLists'],
      (variables?: DeleteListsMutationVariables) => fetcher<DeleteListsMutation, DeleteListsMutationVariables>(DeleteListsDocument, variables)(),
      options
    );
useDeleteListsMutation.fetcher = (variables: DeleteListsMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteListsMutation, DeleteListsMutationVariables>(DeleteListsDocument, variables, options);
export const DeleteListUserGroupsDocument = `
    mutation DeleteListUserGroups($where: list_user_groups_bool_exp!) {
  delete_list_user_groups(where: $where) {
    returning {
      id
    }
  }
}
    `;
export const useDeleteListUserGroupsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteListUserGroupsMutation, TError, DeleteListUserGroupsMutationVariables, TContext>) =>
    useMutation<DeleteListUserGroupsMutation, TError, DeleteListUserGroupsMutationVariables, TContext>(
      ['DeleteListUserGroups'],
      (variables?: DeleteListUserGroupsMutationVariables) => fetcher<DeleteListUserGroupsMutation, DeleteListUserGroupsMutationVariables>(DeleteListUserGroupsDocument, variables)(),
      options
    );
useDeleteListUserGroupsMutation.fetcher = (variables: DeleteListUserGroupsMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteListUserGroupsMutation, DeleteListUserGroupsMutationVariables>(DeleteListUserGroupsDocument, variables, options);
export const InsertListMembersDocument = `
    mutation InsertListMembers($object: list_members_insert_input!) {
  insert_list_members_one(object: $object) {
    id
    member_type
    list_id
    list {
      id
      name
      created_at
      created_by {
        id
        display_name
        email
      }
    }
    user_id
    user {
      id
      display_name
      email
    }
  }
}
    `;
export const useInsertListMembersMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertListMembersMutation, TError, InsertListMembersMutationVariables, TContext>) =>
    useMutation<InsertListMembersMutation, TError, InsertListMembersMutationVariables, TContext>(
      ['InsertListMembers'],
      (variables?: InsertListMembersMutationVariables) => fetcher<InsertListMembersMutation, InsertListMembersMutationVariables>(InsertListMembersDocument, variables)(),
      options
    );
useInsertListMembersMutation.fetcher = (variables: InsertListMembersMutationVariables, options?: RequestInit['headers']) => fetcher<InsertListMembersMutation, InsertListMembersMutationVariables>(InsertListMembersDocument, variables, options);
export const UpdateListByIdDocument = `
    mutation UpdateListById($listId: Int!, $changes: lists_set_input!) {
  update_lists(where: {id: {_eq: $listId}}, _set: $changes) {
    affected_rows
    returning {
      id
      name
    }
  }
}
    `;
export const useUpdateListByIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateListByIdMutation, TError, UpdateListByIdMutationVariables, TContext>) =>
    useMutation<UpdateListByIdMutation, TError, UpdateListByIdMutationVariables, TContext>(
      ['UpdateListById'],
      (variables?: UpdateListByIdMutationVariables) => fetcher<UpdateListByIdMutation, UpdateListByIdMutationVariables>(UpdateListByIdDocument, variables)(),
      options
    );
useUpdateListByIdMutation.fetcher = (variables: UpdateListByIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateListByIdMutation, UpdateListByIdMutationVariables>(UpdateListByIdDocument, variables, options);
export const TriggerListUpdatedAtDocument = `
    mutation TriggerListUpdatedAt($id: Int!, $updated_at: timestamptz!) {
  update_lists(where: {id: {_eq: $id}}, _set: {updated_at: $updated_at}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useTriggerListUpdatedAtMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<TriggerListUpdatedAtMutation, TError, TriggerListUpdatedAtMutationVariables, TContext>) =>
    useMutation<TriggerListUpdatedAtMutation, TError, TriggerListUpdatedAtMutationVariables, TContext>(
      ['TriggerListUpdatedAt'],
      (variables?: TriggerListUpdatedAtMutationVariables) => fetcher<TriggerListUpdatedAtMutation, TriggerListUpdatedAtMutationVariables>(TriggerListUpdatedAtDocument, variables)(),
      options
    );
useTriggerListUpdatedAtMutation.fetcher = (variables: TriggerListUpdatedAtMutationVariables, options?: RequestInit['headers']) => fetcher<TriggerListUpdatedAtMutation, TriggerListUpdatedAtMutationVariables>(TriggerListUpdatedAtDocument, variables, options);
export const GetListsDocument = `
    query GetLists($limit: Int, $offset: Int, $orderBy: [lists_order_by!], $where: lists_bool_exp!) {
  lists(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    name
    description
    total_no_of_resources
    public
    created_at
    updated_at
    created_by {
      id
      display_name
      email
      person {
        id
        name
        slug
        picture
      }
    }
    list_members {
      id
      member_type
      user_id
      user {
        id
        display_name
        email
        person {
          id
          name
          slug
          picture
        }
      }
    }
  }
  lists_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetListsQuery = <
      TData = GetListsQuery,
      TError = Error
    >(
      variables: GetListsQueryVariables,
      options?: UseQueryOptions<GetListsQuery, TError, TData>
    ) =>
    useQuery<GetListsQuery, TError, TData>(
      ['GetLists', variables],
      fetcher<GetListsQuery, GetListsQueryVariables>(GetListsDocument, variables),
      options
    );
useGetListsQuery.document = GetListsDocument;


useGetListsQuery.getKey = (variables: GetListsQueryVariables) => ['GetLists', variables];
;

useGetListsQuery.fetcher = (variables: GetListsQueryVariables, options?: RequestInit['headers']) => fetcher<GetListsQuery, GetListsQueryVariables>(GetListsDocument, variables, options);
export const GetListDocument = `
    query GetList($id: Int!) {
  lists(where: {id: {_eq: $id}}) {
    id
    name
    description
    total_no_of_resources
    public
    created_at
    updated_at
    created_by {
      id
      display_name
      email
      person {
        id
        name
        slug
        picture
      }
    }
    list_members {
      id
      member_type
      user_id
      user {
        id
        display_name
        email
        person {
          id
          name
          slug
          picture
        }
      }
    }
  }
}
    `;
export const useGetListQuery = <
      TData = GetListQuery,
      TError = Error
    >(
      variables: GetListQueryVariables,
      options?: UseQueryOptions<GetListQuery, TError, TData>
    ) =>
    useQuery<GetListQuery, TError, TData>(
      ['GetList', variables],
      fetcher<GetListQuery, GetListQueryVariables>(GetListDocument, variables),
      options
    );
useGetListQuery.document = GetListDocument;


useGetListQuery.getKey = (variables: GetListQueryVariables) => ['GetList', variables];
;

useGetListQuery.fetcher = (variables: GetListQueryVariables, options?: RequestInit['headers']) => fetcher<GetListQuery, GetListQueryVariables>(GetListDocument, variables, options);
export const GetNewsDocument = `
    query GetNews($limit: Int, $offset: Int, $orderBy: [news_order_by!], $where: news_bool_exp!) {
  news(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    date
    kind
    link
    source
    created_at
    status
    text
    metadata
    updated_at
    organizations {
      type
      company {
        id
        name
        slug
        logo
        tags
      }
      vc_firm {
        id
        name
        slug
        logo
        investments {
          investment_round {
            company {
              tags
            }
          }
        }
      }
    }
  }
  news_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetNewsQuery = <
      TData = GetNewsQuery,
      TError = Error
    >(
      variables: GetNewsQueryVariables,
      options?: UseQueryOptions<GetNewsQuery, TError, TData>
    ) =>
    useQuery<GetNewsQuery, TError, TData>(
      ['GetNews', variables],
      fetcher<GetNewsQuery, GetNewsQueryVariables>(GetNewsDocument, variables),
      options
    );
useGetNewsQuery.document = GetNewsDocument;


useGetNewsQuery.getKey = (variables: GetNewsQueryVariables) => ['GetNews', variables];
;

useGetNewsQuery.fetcher = (variables: GetNewsQueryVariables, options?: RequestInit['headers']) => fetcher<GetNewsQuery, GetNewsQueryVariables>(GetNewsDocument, variables, options);
export const GetNewsArticlesDocument = `
    query GetNewsArticles($limit: Int, $offset: Int, $order: order_by!, $where: news_bool_exp!) {
  news(where: $where, order_by: {date: $order}, limit: $limit, offset: $offset) {
    id
    date
    kind
    link
    source
    created_at
    status
    text
    metadata
    updated_at
    organizations {
      type
      company {
        id
        name
        slug
        logo
      }
      vc_firm {
        id
        name
        slug
        logo
      }
    }
  }
  news_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetNewsArticlesQuery = <
      TData = GetNewsArticlesQuery,
      TError = Error
    >(
      variables: GetNewsArticlesQueryVariables,
      options?: UseQueryOptions<GetNewsArticlesQuery, TError, TData>
    ) =>
    useQuery<GetNewsArticlesQuery, TError, TData>(
      ['GetNewsArticles', variables],
      fetcher<GetNewsArticlesQuery, GetNewsArticlesQueryVariables>(GetNewsArticlesDocument, variables),
      options
    );
useGetNewsArticlesQuery.document = GetNewsArticlesDocument;


useGetNewsArticlesQuery.getKey = (variables: GetNewsArticlesQueryVariables) => ['GetNewsArticles', variables];
;

useGetNewsArticlesQuery.fetcher = (variables: GetNewsArticlesQueryVariables, options?: RequestInit['headers']) => fetcher<GetNewsArticlesQuery, GetNewsArticlesQueryVariables>(GetNewsArticlesDocument, variables, options);
export const GetNewsByDateDocument = `
    query GetNewsByDate($date: timestamptz, $library: jsonb) {
  news(
    where: {_and: [{status: {_eq: "published"}}, {updated_at: {_gte: $date}}, {library: {_contains: $library}}]}
  ) {
    id
    date
    link
    text
    source
  }
}
    `;
export const useGetNewsByDateQuery = <
      TData = GetNewsByDateQuery,
      TError = Error
    >(
      variables?: GetNewsByDateQueryVariables,
      options?: UseQueryOptions<GetNewsByDateQuery, TError, TData>
    ) =>
    useQuery<GetNewsByDateQuery, TError, TData>(
      variables === undefined ? ['GetNewsByDate'] : ['GetNewsByDate', variables],
      fetcher<GetNewsByDateQuery, GetNewsByDateQueryVariables>(GetNewsByDateDocument, variables),
      options
    );
useGetNewsByDateQuery.document = GetNewsByDateDocument;


useGetNewsByDateQuery.getKey = (variables?: GetNewsByDateQueryVariables) => variables === undefined ? ['GetNewsByDate'] : ['GetNewsByDate', variables];
;

useGetNewsByDateQuery.fetcher = (variables?: GetNewsByDateQueryVariables, options?: RequestInit['headers']) => fetcher<GetNewsByDateQuery, GetNewsByDateQueryVariables>(GetNewsByDateDocument, variables, options);
export const GetNotesDocument = `
    query GetNotes($where: notes_bool_exp!) {
  notes(where: $where, order_by: {created_at: desc}) {
    id
    notes
    created_by
    created_at
    updated_at
    user_group_id
    audience
    resource_type
    resource_id
    user_group {
      id
      name
    }
    created_by_user {
      id
      display_name
      person {
        slug
        name
        picture
      }
    }
    likes {
      id
      created_at
      created_by_user_id
      created_by_user {
        id
        display_name
        email
        person {
          id
          slug
          name
          picture
        }
      }
    }
    comments(order_by: {created_at: asc}) {
      id
      content
      created_at
      created_by_user_id
      created_by_user {
        id
        display_name
        email
        person {
          id
          slug
          name
          picture
        }
      }
    }
  }
}
    `;
export const useGetNotesQuery = <
      TData = GetNotesQuery,
      TError = Error
    >(
      variables: GetNotesQueryVariables,
      options?: UseQueryOptions<GetNotesQuery, TError, TData>
    ) =>
    useQuery<GetNotesQuery, TError, TData>(
      ['GetNotes', variables],
      fetcher<GetNotesQuery, GetNotesQueryVariables>(GetNotesDocument, variables),
      options
    );
useGetNotesQuery.document = GetNotesDocument;


useGetNotesQuery.getKey = (variables: GetNotesQueryVariables) => ['GetNotes', variables];
;

useGetNotesQuery.fetcher = (variables: GetNotesQueryVariables, options?: RequestInit['headers']) => fetcher<GetNotesQuery, GetNotesQueryVariables>(GetNotesDocument, variables, options);
export const GetNoteByIdDocument = `
    query GetNoteById($id: Int!) {
  notes(where: {id: {_eq: $id}}, limit: 1) {
    id
    notes
    created_by
    created_at
    resource_type
    resource_id
    user_group_id
    user_group {
      id
      name
    }
  }
}
    `;
export const useGetNoteByIdQuery = <
      TData = GetNoteByIdQuery,
      TError = Error
    >(
      variables: GetNoteByIdQueryVariables,
      options?: UseQueryOptions<GetNoteByIdQuery, TError, TData>
    ) =>
    useQuery<GetNoteByIdQuery, TError, TData>(
      ['GetNoteById', variables],
      fetcher<GetNoteByIdQuery, GetNoteByIdQueryVariables>(GetNoteByIdDocument, variables),
      options
    );
useGetNoteByIdQuery.document = GetNoteByIdDocument;


useGetNoteByIdQuery.getKey = (variables: GetNoteByIdQueryVariables) => ['GetNoteById', variables];
;

useGetNoteByIdQuery.fetcher = (variables: GetNoteByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetNoteByIdQuery, GetNoteByIdQueryVariables>(GetNoteByIdDocument, variables, options);
export const DeleteNotesByGroupIdDocument = `
    mutation DeleteNotesByGroupId($groupId: Int!) {
  delete_notes(where: {user_group_id: {_eq: $groupId}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteNotesByGroupIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteNotesByGroupIdMutation, TError, DeleteNotesByGroupIdMutationVariables, TContext>) =>
    useMutation<DeleteNotesByGroupIdMutation, TError, DeleteNotesByGroupIdMutationVariables, TContext>(
      ['DeleteNotesByGroupId'],
      (variables?: DeleteNotesByGroupIdMutationVariables) => fetcher<DeleteNotesByGroupIdMutation, DeleteNotesByGroupIdMutationVariables>(DeleteNotesByGroupIdDocument, variables)(),
      options
    );
useDeleteNotesByGroupIdMutation.fetcher = (variables: DeleteNotesByGroupIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteNotesByGroupIdMutation, DeleteNotesByGroupIdMutationVariables>(DeleteNotesByGroupIdDocument, variables, options);
export const InsertNoteDocument = `
    mutation InsertNote($object: notes_insert_input!) {
  insert_notes_one(object: $object) {
    id
    notes
    created_by
    created_at
    resource_type
    resource_id
    user_group_id
    user_group {
      id
      name
    }
  }
}
    `;
export const useInsertNoteMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertNoteMutation, TError, InsertNoteMutationVariables, TContext>) =>
    useMutation<InsertNoteMutation, TError, InsertNoteMutationVariables, TContext>(
      ['InsertNote'],
      (variables?: InsertNoteMutationVariables) => fetcher<InsertNoteMutation, InsertNoteMutationVariables>(InsertNoteDocument, variables)(),
      options
    );
useInsertNoteMutation.fetcher = (variables: InsertNoteMutationVariables, options?: RequestInit['headers']) => fetcher<InsertNoteMutation, InsertNoteMutationVariables>(InsertNoteDocument, variables, options);
export const UpdateNoteDocument = `
    mutation UpdateNote($id: Int!, $notes: String!) {
  update_notes(where: {id: {_eq: $id}}, _set: {notes: $notes}) {
    affected_rows
    returning {
      id
      notes
      created_by
      created_at
      resource_type
      resource_id
      user_group_id
      user_group {
        id
        name
      }
    }
  }
}
    `;
export const useUpdateNoteMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateNoteMutation, TError, UpdateNoteMutationVariables, TContext>) =>
    useMutation<UpdateNoteMutation, TError, UpdateNoteMutationVariables, TContext>(
      ['UpdateNote'],
      (variables?: UpdateNoteMutationVariables) => fetcher<UpdateNoteMutation, UpdateNoteMutationVariables>(UpdateNoteDocument, variables)(),
      options
    );
useUpdateNoteMutation.fetcher = (variables: UpdateNoteMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateNoteMutation, UpdateNoteMutationVariables>(UpdateNoteDocument, variables, options);
export const DeleteNoteByIdDocument = `
    mutation DeleteNoteById($id: Int!) {
  delete_notes(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteNoteByIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteNoteByIdMutation, TError, DeleteNoteByIdMutationVariables, TContext>) =>
    useMutation<DeleteNoteByIdMutation, TError, DeleteNoteByIdMutationVariables, TContext>(
      ['DeleteNoteById'],
      (variables?: DeleteNoteByIdMutationVariables) => fetcher<DeleteNoteByIdMutation, DeleteNoteByIdMutationVariables>(DeleteNoteByIdDocument, variables)(),
      options
    );
useDeleteNoteByIdMutation.fetcher = (variables: DeleteNoteByIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteNoteByIdMutation, DeleteNoteByIdMutationVariables>(DeleteNoteByIdDocument, variables, options);
export const InsertLikesDocument = `
    mutation InsertLikes($object: likes_insert_input!) {
  insert_likes_one(object: $object) {
    id
  }
}
    `;
export const useInsertLikesMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertLikesMutation, TError, InsertLikesMutationVariables, TContext>) =>
    useMutation<InsertLikesMutation, TError, InsertLikesMutationVariables, TContext>(
      ['InsertLikes'],
      (variables?: InsertLikesMutationVariables) => fetcher<InsertLikesMutation, InsertLikesMutationVariables>(InsertLikesDocument, variables)(),
      options
    );
useInsertLikesMutation.fetcher = (variables: InsertLikesMutationVariables, options?: RequestInit['headers']) => fetcher<InsertLikesMutation, InsertLikesMutationVariables>(InsertLikesDocument, variables, options);
export const DeleteLikesDocument = `
    mutation DeleteLikes($id: Int!) {
  delete_likes(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteLikesMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteLikesMutation, TError, DeleteLikesMutationVariables, TContext>) =>
    useMutation<DeleteLikesMutation, TError, DeleteLikesMutationVariables, TContext>(
      ['DeleteLikes'],
      (variables?: DeleteLikesMutationVariables) => fetcher<DeleteLikesMutation, DeleteLikesMutationVariables>(DeleteLikesDocument, variables)(),
      options
    );
useDeleteLikesMutation.fetcher = (variables: DeleteLikesMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteLikesMutation, DeleteLikesMutationVariables>(DeleteLikesDocument, variables, options);
export const InsertCommentsDocument = `
    mutation InsertComments($object: comments_insert_input!) {
  insert_comments_one(object: $object) {
    id
  }
}
    `;
export const useInsertCommentsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertCommentsMutation, TError, InsertCommentsMutationVariables, TContext>) =>
    useMutation<InsertCommentsMutation, TError, InsertCommentsMutationVariables, TContext>(
      ['InsertComments'],
      (variables?: InsertCommentsMutationVariables) => fetcher<InsertCommentsMutation, InsertCommentsMutationVariables>(InsertCommentsDocument, variables)(),
      options
    );
useInsertCommentsMutation.fetcher = (variables: InsertCommentsMutationVariables, options?: RequestInit['headers']) => fetcher<InsertCommentsMutation, InsertCommentsMutationVariables>(InsertCommentsDocument, variables, options);
export const DeleteCommentOneDocument = `
    mutation DeleteCommentOne($id: Int!) {
  delete_comments(where: {id: {_eq: $id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteCommentOneMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteCommentOneMutation, TError, DeleteCommentOneMutationVariables, TContext>) =>
    useMutation<DeleteCommentOneMutation, TError, DeleteCommentOneMutationVariables, TContext>(
      ['DeleteCommentOne'],
      (variables?: DeleteCommentOneMutationVariables) => fetcher<DeleteCommentOneMutation, DeleteCommentOneMutationVariables>(DeleteCommentOneDocument, variables)(),
      options
    );
useDeleteCommentOneMutation.fetcher = (variables: DeleteCommentOneMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteCommentOneMutation, DeleteCommentOneMutationVariables>(DeleteCommentOneDocument, variables, options);
export const DeleteLikesByNoteIdDocument = `
    mutation DeleteLikesByNoteId($note_id: Int!) {
  delete_likes(where: {note_id: {_eq: $note_id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteLikesByNoteIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteLikesByNoteIdMutation, TError, DeleteLikesByNoteIdMutationVariables, TContext>) =>
    useMutation<DeleteLikesByNoteIdMutation, TError, DeleteLikesByNoteIdMutationVariables, TContext>(
      ['DeleteLikesByNoteId'],
      (variables?: DeleteLikesByNoteIdMutationVariables) => fetcher<DeleteLikesByNoteIdMutation, DeleteLikesByNoteIdMutationVariables>(DeleteLikesByNoteIdDocument, variables)(),
      options
    );
useDeleteLikesByNoteIdMutation.fetcher = (variables: DeleteLikesByNoteIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteLikesByNoteIdMutation, DeleteLikesByNoteIdMutationVariables>(DeleteLikesByNoteIdDocument, variables, options);
export const DeleteCommentsByNoteIdDocument = `
    mutation DeleteCommentsByNoteId($note_id: Int!) {
  delete_comments(where: {note_id: {_eq: $note_id}}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useDeleteCommentsByNoteIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteCommentsByNoteIdMutation, TError, DeleteCommentsByNoteIdMutationVariables, TContext>) =>
    useMutation<DeleteCommentsByNoteIdMutation, TError, DeleteCommentsByNoteIdMutationVariables, TContext>(
      ['DeleteCommentsByNoteId'],
      (variables?: DeleteCommentsByNoteIdMutationVariables) => fetcher<DeleteCommentsByNoteIdMutation, DeleteCommentsByNoteIdMutationVariables>(DeleteCommentsByNoteIdDocument, variables)(),
      options
    );
useDeleteCommentsByNoteIdMutation.fetcher = (variables: DeleteCommentsByNoteIdMutationVariables, options?: RequestInit['headers']) => fetcher<DeleteCommentsByNoteIdMutation, DeleteCommentsByNoteIdMutationVariables>(DeleteCommentsByNoteIdDocument, variables, options);
export const FindNoteLikesOneDocument = `
    query FindNoteLikesOne($note_id: Int!, $user_id: Int!) {
  likes(
    where: {_and: [{note_id: {_eq: $note_id}}, {created_by_user_id: {_eq: $user_id}}]}
    limit: 1
  ) {
    id
  }
}
    `;
export const useFindNoteLikesOneQuery = <
      TData = FindNoteLikesOneQuery,
      TError = Error
    >(
      variables: FindNoteLikesOneQueryVariables,
      options?: UseQueryOptions<FindNoteLikesOneQuery, TError, TData>
    ) =>
    useQuery<FindNoteLikesOneQuery, TError, TData>(
      ['FindNoteLikesOne', variables],
      fetcher<FindNoteLikesOneQuery, FindNoteLikesOneQueryVariables>(FindNoteLikesOneDocument, variables),
      options
    );
useFindNoteLikesOneQuery.document = FindNoteLikesOneDocument;


useFindNoteLikesOneQuery.getKey = (variables: FindNoteLikesOneQueryVariables) => ['FindNoteLikesOne', variables];
;

useFindNoteLikesOneQuery.fetcher = (variables: FindNoteLikesOneQueryVariables, options?: RequestInit['headers']) => fetcher<FindNoteLikesOneQuery, FindNoteLikesOneQueryVariables>(FindNoteLikesOneDocument, variables, options);
export const FindCommentByIdDocument = `
    query FindCommentById($id: Int!) {
  comments(where: {id: {_eq: $id}}, limit: 1) {
    id
    created_by_user_id
  }
}
    `;
export const useFindCommentByIdQuery = <
      TData = FindCommentByIdQuery,
      TError = Error
    >(
      variables: FindCommentByIdQueryVariables,
      options?: UseQueryOptions<FindCommentByIdQuery, TError, TData>
    ) =>
    useQuery<FindCommentByIdQuery, TError, TData>(
      ['FindCommentById', variables],
      fetcher<FindCommentByIdQuery, FindCommentByIdQueryVariables>(FindCommentByIdDocument, variables),
      options
    );
useFindCommentByIdQuery.document = FindCommentByIdDocument;


useFindCommentByIdQuery.getKey = (variables: FindCommentByIdQueryVariables) => ['FindCommentById', variables];
;

useFindCommentByIdQuery.fetcher = (variables: FindCommentByIdQueryVariables, options?: RequestInit['headers']) => fetcher<FindCommentByIdQuery, FindCommentByIdQueryVariables>(FindCommentByIdDocument, variables, options);
export const GetNotificationsForUserDocument = `
    query GetNotificationsForUser($limit: Int, $offset: Int, $user: Int!) {
  notifications(
    where: {_and: [{target_user_id: {_eq: $user}}, {event_type: {_neq: "Delete Data"}}, {_or: [{_and: [{company_id: {_is_null: false}}, {company: {status: {_neq: "draft"}}}]}, {_and: [{vc_firm_id: {_is_null: false}}, {vc_firm: {status: {_neq: "draft"}}}]}]}]}
    order_by: {created_at: desc}
    limit: $limit
    offset: $offset
  ) {
    id
    read
    created_at
    event_type
    message
    read_at
    follow_resource_type
    notification_resource_type
    company {
      id
      name
      slug
      logo
    }
    vc_firm {
      id
      name
      slug
      logo
    }
    notification_actions {
      id
      action_id
      action {
        id
        properties
      }
    }
  }
  notifications_aggregate(
    where: {_and: [{target_user_id: {_eq: $user}}, {event_type: {_neq: "Delete Data"}}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetNotificationsForUserQuery = <
      TData = GetNotificationsForUserQuery,
      TError = Error
    >(
      variables: GetNotificationsForUserQueryVariables,
      options?: UseQueryOptions<GetNotificationsForUserQuery, TError, TData>
    ) =>
    useQuery<GetNotificationsForUserQuery, TError, TData>(
      ['GetNotificationsForUser', variables],
      fetcher<GetNotificationsForUserQuery, GetNotificationsForUserQueryVariables>(GetNotificationsForUserDocument, variables),
      options
    );
useGetNotificationsForUserQuery.document = GetNotificationsForUserDocument;


useGetNotificationsForUserQuery.getKey = (variables: GetNotificationsForUserQueryVariables) => ['GetNotificationsForUser', variables];
;

useGetNotificationsForUserQuery.fetcher = (variables: GetNotificationsForUserQueryVariables, options?: RequestInit['headers']) => fetcher<GetNotificationsForUserQuery, GetNotificationsForUserQueryVariables>(GetNotificationsForUserDocument, variables, options);
export const InsertNotificationsDocument = `
    mutation InsertNotifications($object: notifications_insert_input!) {
  insert_notifications_one(object: $object) {
    id
    target_user_id
    event_type
    follow_resource_type
    notification_resource_type
    company_id
    vc_firm_id
    message
    read_at
    created_at
    updated_at
    read
  }
}
    `;
export const useInsertNotificationsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertNotificationsMutation, TError, InsertNotificationsMutationVariables, TContext>) =>
    useMutation<InsertNotificationsMutation, TError, InsertNotificationsMutationVariables, TContext>(
      ['InsertNotifications'],
      (variables?: InsertNotificationsMutationVariables) => fetcher<InsertNotificationsMutation, InsertNotificationsMutationVariables>(InsertNotificationsDocument, variables)(),
      options
    );
useInsertNotificationsMutation.fetcher = (variables: InsertNotificationsMutationVariables, options?: RequestInit['headers']) => fetcher<InsertNotificationsMutation, InsertNotificationsMutationVariables>(InsertNotificationsDocument, variables, options);
export const MarkNotificationsAsReadDocument = `
    mutation MarkNotificationsAsRead($where: notifications_bool_exp!) {
  update_notifications(where: $where, _set: {read: true}) {
    affected_rows
    returning {
      id
    }
  }
}
    `;
export const useMarkNotificationsAsReadMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<MarkNotificationsAsReadMutation, TError, MarkNotificationsAsReadMutationVariables, TContext>) =>
    useMutation<MarkNotificationsAsReadMutation, TError, MarkNotificationsAsReadMutationVariables, TContext>(
      ['MarkNotificationsAsRead'],
      (variables?: MarkNotificationsAsReadMutationVariables) => fetcher<MarkNotificationsAsReadMutation, MarkNotificationsAsReadMutationVariables>(MarkNotificationsAsReadDocument, variables)(),
      options
    );
useMarkNotificationsAsReadMutation.fetcher = (variables: MarkNotificationsAsReadMutationVariables, options?: RequestInit['headers']) => fetcher<MarkNotificationsAsReadMutation, MarkNotificationsAsReadMutationVariables>(MarkNotificationsAsReadDocument, variables, options);
export const InsertNotificationActionsDocument = `
    mutation InsertNotificationActions($object: notification_actions_insert_input!) {
  insert_notification_actions_one(object: $object) {
    id
  }
}
    `;
export const useInsertNotificationActionsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertNotificationActionsMutation, TError, InsertNotificationActionsMutationVariables, TContext>) =>
    useMutation<InsertNotificationActionsMutation, TError, InsertNotificationActionsMutationVariables, TContext>(
      ['InsertNotificationActions'],
      (variables?: InsertNotificationActionsMutationVariables) => fetcher<InsertNotificationActionsMutation, InsertNotificationActionsMutationVariables>(InsertNotificationActionsDocument, variables)(),
      options
    );
useInsertNotificationActionsMutation.fetcher = (variables: InsertNotificationActionsMutationVariables, options?: RequestInit['headers']) => fetcher<InsertNotificationActionsMutation, InsertNotificationActionsMutationVariables>(InsertNotificationActionsDocument, variables, options);
export const GetUnreadNotificationsDocument = `
    query GetUnreadNotifications($user_id: Int!) {
  notifications_aggregate(
    where: {_and: [{target_user_id: {_eq: $user_id}}, {event_type: {_neq: "Delete Data"}}, {read: {_eq: false}}, {_or: [{_and: [{company_id: {_is_null: false}}, {company: {status: {_neq: "draft"}}}]}, {_and: [{vc_firm_id: {_is_null: false}}, {vc_firm: {status: {_neq: "draft"}}}]}]}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetUnreadNotificationsQuery = <
      TData = GetUnreadNotificationsQuery,
      TError = Error
    >(
      variables: GetUnreadNotificationsQueryVariables,
      options?: UseQueryOptions<GetUnreadNotificationsQuery, TError, TData>
    ) =>
    useQuery<GetUnreadNotificationsQuery, TError, TData>(
      ['GetUnreadNotifications', variables],
      fetcher<GetUnreadNotificationsQuery, GetUnreadNotificationsQueryVariables>(GetUnreadNotificationsDocument, variables),
      options
    );
useGetUnreadNotificationsQuery.document = GetUnreadNotificationsDocument;


useGetUnreadNotificationsQuery.getKey = (variables: GetUnreadNotificationsQueryVariables) => ['GetUnreadNotifications', variables];
;

useGetUnreadNotificationsQuery.fetcher = (variables: GetUnreadNotificationsQueryVariables, options?: RequestInit['headers']) => fetcher<GetUnreadNotificationsQuery, GetUnreadNotificationsQueryVariables>(GetUnreadNotificationsDocument, variables, options);
export const GetPersonDocument = `
    query GetPerson($slug: String!) {
  people(where: {slug: {_eq: $slug}}) {
    id
    name
    library
    personal_email
    picture
    slug
    status
    type
    work_email
    linkedin
    web3_address
    twitter_url
    discord
    telegram
    github
    location_json
    facebook_url
    website_url
    about
    email
    investors(order_by: {start_date: desc_nulls_last, end_date: desc_nulls_first}) {
      id
      end_date
      start_date
      function
      title
      vc_firm {
        id
        slug
        name
        logo
        overview
        location_json
        tags
      }
    }
    team_members(
      order_by: {start_date: desc_nulls_last, end_date: desc_nulls_first}
    ) {
      id
      end_date
      start_date
      founder
      function
      title
      company {
        id
        slug
        name
        logo
        overview
        location_json
        tags
      }
    }
    investments {
      investment_round {
        id
        round_date
        round
        amount
        company {
          id
          slug
          name
          logo
          tags
        }
        investments {
          id
          vc_firm {
            id
            slug
            name
            logo
          }
          person {
            id
            slug
            name
            picture
          }
        }
      }
    }
    news_links {
      id
      news {
        id
        date
        text
        link
        kind
        source
        status
        people {
          id
          type
          person_id
        }
      }
    }
    user {
      id
    }
    follows {
      id
      list_id
    }
    people_computed_data {
      title
      tags
      person_id
      location_json
      geopoint
      id
    }
  }
}
    `;
export const useGetPersonQuery = <
      TData = GetPersonQuery,
      TError = Error
    >(
      variables: GetPersonQueryVariables,
      options?: UseQueryOptions<GetPersonQuery, TError, TData>
    ) =>
    useQuery<GetPersonQuery, TError, TData>(
      ['GetPerson', variables],
      fetcher<GetPersonQuery, GetPersonQueryVariables>(GetPersonDocument, variables),
      options
    );
useGetPersonQuery.document = GetPersonDocument;


useGetPersonQuery.getKey = (variables: GetPersonQueryVariables) => ['GetPerson', variables];
;

useGetPersonQuery.fetcher = (variables: GetPersonQueryVariables, options?: RequestInit['headers']) => fetcher<GetPersonQuery, GetPersonQueryVariables>(GetPersonDocument, variables, options);
export const GetPeopleByIdDocument = `
    query GetPeopleById($id: Int!) {
  people(where: {id: {_eq: $id}}) {
    ...PeopleFragment
  }
}
    ${PeopleFragmentFragmentDoc}`;
export const useGetPeopleByIdQuery = <
      TData = GetPeopleByIdQuery,
      TError = Error
    >(
      variables: GetPeopleByIdQueryVariables,
      options?: UseQueryOptions<GetPeopleByIdQuery, TError, TData>
    ) =>
    useQuery<GetPeopleByIdQuery, TError, TData>(
      ['GetPeopleById', variables],
      fetcher<GetPeopleByIdQuery, GetPeopleByIdQueryVariables>(GetPeopleByIdDocument, variables),
      options
    );
useGetPeopleByIdQuery.document = GetPeopleByIdDocument;


useGetPeopleByIdQuery.getKey = (variables: GetPeopleByIdQueryVariables) => ['GetPeopleById', variables];
;

useGetPeopleByIdQuery.fetcher = (variables: GetPeopleByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleByIdQuery, GetPeopleByIdQueryVariables>(GetPeopleByIdDocument, variables, options);
export const GetPeopleDocument = `
    query GetPeople($limit: Int, $offset: Int, $orderBy: [people_order_by!], $where: people_bool_exp!) {
  people(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    ...PeopleFragment
  }
  people_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    ${PeopleFragmentFragmentDoc}`;
export const useGetPeopleQuery = <
      TData = GetPeopleQuery,
      TError = Error
    >(
      variables: GetPeopleQueryVariables,
      options?: UseQueryOptions<GetPeopleQuery, TError, TData>
    ) =>
    useQuery<GetPeopleQuery, TError, TData>(
      ['GetPeople', variables],
      fetcher<GetPeopleQuery, GetPeopleQueryVariables>(GetPeopleDocument, variables),
      options
    );
useGetPeopleQuery.document = GetPeopleDocument;


useGetPeopleQuery.getKey = (variables: GetPeopleQueryVariables) => ['GetPeople', variables];
;

useGetPeopleQuery.fetcher = (variables: GetPeopleQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleQuery, GetPeopleQueryVariables>(GetPeopleDocument, variables, options);
export const GetAllPersonsDocument = `
    query GetAllPersons {
  people {
    id
    name
  }
}
    `;
export const useGetAllPersonsQuery = <
      TData = GetAllPersonsQuery,
      TError = Error
    >(
      variables?: GetAllPersonsQueryVariables,
      options?: UseQueryOptions<GetAllPersonsQuery, TError, TData>
    ) =>
    useQuery<GetAllPersonsQuery, TError, TData>(
      variables === undefined ? ['GetAllPersons'] : ['GetAllPersons', variables],
      fetcher<GetAllPersonsQuery, GetAllPersonsQueryVariables>(GetAllPersonsDocument, variables),
      options
    );
useGetAllPersonsQuery.document = GetAllPersonsDocument;


useGetAllPersonsQuery.getKey = (variables?: GetAllPersonsQueryVariables) => variables === undefined ? ['GetAllPersons'] : ['GetAllPersons', variables];
;

useGetAllPersonsQuery.fetcher = (variables?: GetAllPersonsQueryVariables, options?: RequestInit['headers']) => fetcher<GetAllPersonsQuery, GetAllPersonsQueryVariables>(GetAllPersonsDocument, variables, options);
export const SearchPeopleDocument = `
    query SearchPeople($query: String, $searchText: jsonb) {
  users(
    where: {_or: [{email: {_ilike: $query}}, {additional_emails: {_contains: $searchText}}, {person: {_or: [{name: {_ilike: $query}}, {work_email: {_ilike: $query}}, {personal_email: {_ilike: $query}}]}}]}
    limit: 50
  ) {
    id
    display_name
    email
    person {
      id
      name
      picture
      slug
    }
  }
}
    `;
export const useSearchPeopleQuery = <
      TData = SearchPeopleQuery,
      TError = Error
    >(
      variables?: SearchPeopleQueryVariables,
      options?: UseQueryOptions<SearchPeopleQuery, TError, TData>
    ) =>
    useQuery<SearchPeopleQuery, TError, TData>(
      variables === undefined ? ['SearchPeople'] : ['SearchPeople', variables],
      fetcher<SearchPeopleQuery, SearchPeopleQueryVariables>(SearchPeopleDocument, variables),
      options
    );
useSearchPeopleQuery.document = SearchPeopleDocument;


useSearchPeopleQuery.getKey = (variables?: SearchPeopleQueryVariables) => variables === undefined ? ['SearchPeople'] : ['SearchPeople', variables];
;

useSearchPeopleQuery.fetcher = (variables?: SearchPeopleQueryVariables, options?: RequestInit['headers']) => fetcher<SearchPeopleQuery, SearchPeopleQueryVariables>(SearchPeopleDocument, variables, options);
export const GetPeopleByDateDocument = `
    query GetPeopleByDate($date: timestamptz, $library: jsonb) {
  people(
    where: {_and: [{status: {_eq: "published"}}, {updated_at: {_gte: $date}}, {library: {_contains: $library}}]}
  ) {
    id
    name
    work_email
    personal_email
    picture
    slug
  }
}
    `;
export const useGetPeopleByDateQuery = <
      TData = GetPeopleByDateQuery,
      TError = Error
    >(
      variables?: GetPeopleByDateQueryVariables,
      options?: UseQueryOptions<GetPeopleByDateQuery, TError, TData>
    ) =>
    useQuery<GetPeopleByDateQuery, TError, TData>(
      variables === undefined ? ['GetPeopleByDate'] : ['GetPeopleByDate', variables],
      fetcher<GetPeopleByDateQuery, GetPeopleByDateQueryVariables>(GetPeopleByDateDocument, variables),
      options
    );
useGetPeopleByDateQuery.document = GetPeopleByDateDocument;


useGetPeopleByDateQuery.getKey = (variables?: GetPeopleByDateQueryVariables) => variables === undefined ? ['GetPeopleByDate'] : ['GetPeopleByDate', variables];
;

useGetPeopleByDateQuery.fetcher = (variables?: GetPeopleByDateQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleByDateQuery, GetPeopleByDateQueryVariables>(GetPeopleByDateDocument, variables, options);
export const GetDraftPeopleDocument = `
    query GetDraftPeople($date: timestamptz, $library: jsonb) {
  people(
    where: {_and: [{status: {_eq: "draft"}}, {library: {_contains: $library}}, {updated_at: {_gte: $date}}]}
  ) {
    id
  }
}
    `;
export const useGetDraftPeopleQuery = <
      TData = GetDraftPeopleQuery,
      TError = Error
    >(
      variables?: GetDraftPeopleQueryVariables,
      options?: UseQueryOptions<GetDraftPeopleQuery, TError, TData>
    ) =>
    useQuery<GetDraftPeopleQuery, TError, TData>(
      variables === undefined ? ['GetDraftPeople'] : ['GetDraftPeople', variables],
      fetcher<GetDraftPeopleQuery, GetDraftPeopleQueryVariables>(GetDraftPeopleDocument, variables),
      options
    );
useGetDraftPeopleQuery.document = GetDraftPeopleDocument;


useGetDraftPeopleQuery.getKey = (variables?: GetDraftPeopleQueryVariables) => variables === undefined ? ['GetDraftPeople'] : ['GetDraftPeople', variables];
;

useGetDraftPeopleQuery.fetcher = (variables?: GetDraftPeopleQueryVariables, options?: RequestInit['headers']) => fetcher<GetDraftPeopleQuery, GetDraftPeopleQueryVariables>(GetDraftPeopleDocument, variables, options);
export const UpdatePeopleByPkDocument = `
    mutation UpdatePeopleByPk($set: people_set_input, $id: Int!) {
  update_people_by_pk(_set: $set, pk_columns: {id: $id}) {
    id
    name
    personal_email
    picture
    slug
    status
    type
    work_email
    linkedin
    github
    location_json
    facebook_url
    twitter_url
    website_url
    about
    email
    team_members {
      id
      end_date
      start_date
      founder
      function
      company {
        id
        slug
        name
        logo
        overview
      }
    }
    investments {
      investment_round {
        id
        round_date
        round
        amount
        company {
          id
          slug
          name
          logo
        }
      }
    }
  }
}
    `;
export const useUpdatePeopleByPkMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdatePeopleByPkMutation, TError, UpdatePeopleByPkMutationVariables, TContext>) =>
    useMutation<UpdatePeopleByPkMutation, TError, UpdatePeopleByPkMutationVariables, TContext>(
      ['UpdatePeopleByPk'],
      (variables?: UpdatePeopleByPkMutationVariables) => fetcher<UpdatePeopleByPkMutation, UpdatePeopleByPkMutationVariables>(UpdatePeopleByPkDocument, variables)(),
      options
    );
useUpdatePeopleByPkMutation.fetcher = (variables: UpdatePeopleByPkMutationVariables, options?: RequestInit['headers']) => fetcher<UpdatePeopleByPkMutation, UpdatePeopleByPkMutationVariables>(UpdatePeopleByPkDocument, variables, options);
export const FindPeopleByNameAndEmailDocument = `
    query FindPeopleByNameAndEmail($name: String, $email: String) {
  people(
    where: {_and: [{_not: {user: {}}}, {_or: [{name: {_ilike: $name}}, {work_email: {_ilike: $email}}, {personal_email: {_ilike: $email}}]}]}
    limit: 50
  ) {
    id
    name
    picture
    slug
    user {
      id
    }
  }
}
    `;
export const useFindPeopleByNameAndEmailQuery = <
      TData = FindPeopleByNameAndEmailQuery,
      TError = Error
    >(
      variables?: FindPeopleByNameAndEmailQueryVariables,
      options?: UseQueryOptions<FindPeopleByNameAndEmailQuery, TError, TData>
    ) =>
    useQuery<FindPeopleByNameAndEmailQuery, TError, TData>(
      variables === undefined ? ['FindPeopleByNameAndEmail'] : ['FindPeopleByNameAndEmail', variables],
      fetcher<FindPeopleByNameAndEmailQuery, FindPeopleByNameAndEmailQueryVariables>(FindPeopleByNameAndEmailDocument, variables),
      options
    );
useFindPeopleByNameAndEmailQuery.document = FindPeopleByNameAndEmailDocument;


useFindPeopleByNameAndEmailQuery.getKey = (variables?: FindPeopleByNameAndEmailQueryVariables) => variables === undefined ? ['FindPeopleByNameAndEmail'] : ['FindPeopleByNameAndEmail', variables];
;

useFindPeopleByNameAndEmailQuery.fetcher = (variables?: FindPeopleByNameAndEmailQueryVariables, options?: RequestInit['headers']) => fetcher<FindPeopleByNameAndEmailQuery, FindPeopleByNameAndEmailQueryVariables>(FindPeopleByNameAndEmailDocument, variables, options);
export const FindPeopleByLinkedinUrlDocument = `
    query FindPeopleByLinkedinUrl($linkedin: String) {
  people(where: {linkedin: {_eq: $linkedin}}, limit: 1) {
    id
    name
    picture
    slug
  }
}
    `;
export const useFindPeopleByLinkedinUrlQuery = <
      TData = FindPeopleByLinkedinUrlQuery,
      TError = Error
    >(
      variables?: FindPeopleByLinkedinUrlQueryVariables,
      options?: UseQueryOptions<FindPeopleByLinkedinUrlQuery, TError, TData>
    ) =>
    useQuery<FindPeopleByLinkedinUrlQuery, TError, TData>(
      variables === undefined ? ['FindPeopleByLinkedinUrl'] : ['FindPeopleByLinkedinUrl', variables],
      fetcher<FindPeopleByLinkedinUrlQuery, FindPeopleByLinkedinUrlQueryVariables>(FindPeopleByLinkedinUrlDocument, variables),
      options
    );
useFindPeopleByLinkedinUrlQuery.document = FindPeopleByLinkedinUrlDocument;


useFindPeopleByLinkedinUrlQuery.getKey = (variables?: FindPeopleByLinkedinUrlQueryVariables) => variables === undefined ? ['FindPeopleByLinkedinUrl'] : ['FindPeopleByLinkedinUrl', variables];
;

useFindPeopleByLinkedinUrlQuery.fetcher = (variables?: FindPeopleByLinkedinUrlQueryVariables, options?: RequestInit['headers']) => fetcher<FindPeopleByLinkedinUrlQuery, FindPeopleByLinkedinUrlQueryVariables>(FindPeopleByLinkedinUrlDocument, variables, options);
export const InsertOnboardingClaimProfileDocument = `
    mutation InsertOnboardingClaimProfile($object: people_insert_input!) {
  insert_people_one(object: $object) {
    id
    name
    work_email
    linkedin
  }
}
    `;
export const useInsertOnboardingClaimProfileMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertOnboardingClaimProfileMutation, TError, InsertOnboardingClaimProfileMutationVariables, TContext>) =>
    useMutation<InsertOnboardingClaimProfileMutation, TError, InsertOnboardingClaimProfileMutationVariables, TContext>(
      ['InsertOnboardingClaimProfile'],
      (variables?: InsertOnboardingClaimProfileMutationVariables) => fetcher<InsertOnboardingClaimProfileMutation, InsertOnboardingClaimProfileMutationVariables>(InsertOnboardingClaimProfileDocument, variables)(),
      options
    );
useInsertOnboardingClaimProfileMutation.fetcher = (variables: InsertOnboardingClaimProfileMutationVariables, options?: RequestInit['headers']) => fetcher<InsertOnboardingClaimProfileMutation, InsertOnboardingClaimProfileMutationVariables>(InsertOnboardingClaimProfileDocument, variables, options);
export const FindPeopleByEmailDocument = `
    query FindPeopleByEmail($query: String) {
  people(where: {work_email: {_ilike: $query}}, limit: 25) {
    id
    name
    picture
    slug
    work_email
    personal_email
  }
}
    `;
export const useFindPeopleByEmailQuery = <
      TData = FindPeopleByEmailQuery,
      TError = Error
    >(
      variables?: FindPeopleByEmailQueryVariables,
      options?: UseQueryOptions<FindPeopleByEmailQuery, TError, TData>
    ) =>
    useQuery<FindPeopleByEmailQuery, TError, TData>(
      variables === undefined ? ['FindPeopleByEmail'] : ['FindPeopleByEmail', variables],
      fetcher<FindPeopleByEmailQuery, FindPeopleByEmailQueryVariables>(FindPeopleByEmailDocument, variables),
      options
    );
useFindPeopleByEmailQuery.document = FindPeopleByEmailDocument;


useFindPeopleByEmailQuery.getKey = (variables?: FindPeopleByEmailQueryVariables) => variables === undefined ? ['FindPeopleByEmail'] : ['FindPeopleByEmail', variables];
;

useFindPeopleByEmailQuery.fetcher = (variables?: FindPeopleByEmailQueryVariables, options?: RequestInit['headers']) => fetcher<FindPeopleByEmailQuery, FindPeopleByEmailQueryVariables>(FindPeopleByEmailDocument, variables, options);
export const GetSignUpProfileDocument = `
    query GetSignUpProfile($email: String, $name: String) {
  people(
    where: {_and: [{_not: {user: {}}}, {_and: [{name: {_eq: $name}}, {_or: [{work_email: {_eq: $email}}, {personal_email: {_eq: $email}}]}]}]}
    limit: 1
  ) {
    id
    name
    picture
    slug
    website_url
    linkedin
    twitter_url
    github
    facebook_url
  }
}
    `;
export const useGetSignUpProfileQuery = <
      TData = GetSignUpProfileQuery,
      TError = Error
    >(
      variables?: GetSignUpProfileQueryVariables,
      options?: UseQueryOptions<GetSignUpProfileQuery, TError, TData>
    ) =>
    useQuery<GetSignUpProfileQuery, TError, TData>(
      variables === undefined ? ['GetSignUpProfile'] : ['GetSignUpProfile', variables],
      fetcher<GetSignUpProfileQuery, GetSignUpProfileQueryVariables>(GetSignUpProfileDocument, variables),
      options
    );
useGetSignUpProfileQuery.document = GetSignUpProfileDocument;


useGetSignUpProfileQuery.getKey = (variables?: GetSignUpProfileQueryVariables) => variables === undefined ? ['GetSignUpProfile'] : ['GetSignUpProfile', variables];
;

useGetSignUpProfileQuery.fetcher = (variables?: GetSignUpProfileQueryVariables, options?: RequestInit['headers']) => fetcher<GetSignUpProfileQuery, GetSignUpProfileQueryVariables>(GetSignUpProfileDocument, variables, options);
export const InsertPeopleDocument = `
    mutation InsertPeople($objects: [people_insert_input!]!) {
  insert_people(
    objects: $objects
    on_conflict: {constraint: people_slug_key, update_columns: []}
  ) {
    returning {
      id
      status
      linkedin
      slug
      enrichment_priority
    }
  }
}
    `;
export const useInsertPeopleMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertPeopleMutation, TError, InsertPeopleMutationVariables, TContext>) =>
    useMutation<InsertPeopleMutation, TError, InsertPeopleMutationVariables, TContext>(
      ['InsertPeople'],
      (variables?: InsertPeopleMutationVariables) => fetcher<InsertPeopleMutation, InsertPeopleMutationVariables>(InsertPeopleDocument, variables)(),
      options
    );
useInsertPeopleMutation.fetcher = (variables: InsertPeopleMutationVariables, options?: RequestInit['headers']) => fetcher<InsertPeopleMutation, InsertPeopleMutationVariables>(InsertPeopleDocument, variables, options);
export const GetPeopleByTagsAndLocationDocument = `
    query GetPeopleByTagsAndLocation($limit: Int, $where: people_bool_exp!) {
  people(where: $where, limit: $limit) {
    id
  }
}
    `;
export const useGetPeopleByTagsAndLocationQuery = <
      TData = GetPeopleByTagsAndLocationQuery,
      TError = Error
    >(
      variables: GetPeopleByTagsAndLocationQueryVariables,
      options?: UseQueryOptions<GetPeopleByTagsAndLocationQuery, TError, TData>
    ) =>
    useQuery<GetPeopleByTagsAndLocationQuery, TError, TData>(
      ['GetPeopleByTagsAndLocation', variables],
      fetcher<GetPeopleByTagsAndLocationQuery, GetPeopleByTagsAndLocationQueryVariables>(GetPeopleByTagsAndLocationDocument, variables),
      options
    );
useGetPeopleByTagsAndLocationQuery.document = GetPeopleByTagsAndLocationDocument;


useGetPeopleByTagsAndLocationQuery.getKey = (variables: GetPeopleByTagsAndLocationQueryVariables) => ['GetPeopleByTagsAndLocation', variables];
;

useGetPeopleByTagsAndLocationQuery.fetcher = (variables: GetPeopleByTagsAndLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleByTagsAndLocationQuery, GetPeopleByTagsAndLocationQueryVariables>(GetPeopleByTagsAndLocationDocument, variables, options);
export const GetPeopleComputedByPersonIdDocument = `
    query GetPeopleComputedByPersonId($personId: Int!) {
  people_computed_data(where: {person_id: {_eq: $personId}}) {
    geopoint
    location_json
    person_id
  }
}
    `;
export const useGetPeopleComputedByPersonIdQuery = <
      TData = GetPeopleComputedByPersonIdQuery,
      TError = Error
    >(
      variables: GetPeopleComputedByPersonIdQueryVariables,
      options?: UseQueryOptions<GetPeopleComputedByPersonIdQuery, TError, TData>
    ) =>
    useQuery<GetPeopleComputedByPersonIdQuery, TError, TData>(
      ['GetPeopleComputedByPersonId', variables],
      fetcher<GetPeopleComputedByPersonIdQuery, GetPeopleComputedByPersonIdQueryVariables>(GetPeopleComputedByPersonIdDocument, variables),
      options
    );
useGetPeopleComputedByPersonIdQuery.document = GetPeopleComputedByPersonIdDocument;


useGetPeopleComputedByPersonIdQuery.getKey = (variables: GetPeopleComputedByPersonIdQueryVariables) => ['GetPeopleComputedByPersonId', variables];
;

useGetPeopleComputedByPersonIdQuery.fetcher = (variables: GetPeopleComputedByPersonIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetPeopleComputedByPersonIdQuery, GetPeopleComputedByPersonIdQueryVariables>(GetPeopleComputedByPersonIdDocument, variables, options);
export const InsertResetPasswordDocument = `
    mutation InsertResetPassword($object: reset_passwords_insert_input!) {
  insert_reset_passwords_one(object: $object) {
    id
    user_id
    generated_password
    created_at
  }
}
    `;
export const useInsertResetPasswordMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertResetPasswordMutation, TError, InsertResetPasswordMutationVariables, TContext>) =>
    useMutation<InsertResetPasswordMutation, TError, InsertResetPasswordMutationVariables, TContext>(
      ['InsertResetPassword'],
      (variables?: InsertResetPasswordMutationVariables) => fetcher<InsertResetPasswordMutation, InsertResetPasswordMutationVariables>(InsertResetPasswordDocument, variables)(),
      options
    );
useInsertResetPasswordMutation.fetcher = (variables: InsertResetPasswordMutationVariables, options?: RequestInit['headers']) => fetcher<InsertResetPasswordMutation, InsertResetPasswordMutationVariables>(InsertResetPasswordDocument, variables, options);
export const InsertEditAccessDocument = `
    mutation InsertEditAccess($userId: Int, $resourceId: Int, $resourceType: String) {
  insert_resource_edit_access_one(
    object: {user_id: $userId, resource_id: $resourceId, resource_type: $resourceType}
    on_conflict: {constraint: resource_edit_access_resource_id_user_id_resource_type_key, update_columns: []}
  ) {
    id
    user_id
    resource_id
    resource_type
  }
}
    `;
export const useInsertEditAccessMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertEditAccessMutation, TError, InsertEditAccessMutationVariables, TContext>) =>
    useMutation<InsertEditAccessMutation, TError, InsertEditAccessMutationVariables, TContext>(
      ['InsertEditAccess'],
      (variables?: InsertEditAccessMutationVariables) => fetcher<InsertEditAccessMutation, InsertEditAccessMutationVariables>(InsertEditAccessDocument, variables)(),
      options
    );
useInsertEditAccessMutation.fetcher = (variables?: InsertEditAccessMutationVariables, options?: RequestInit['headers']) => fetcher<InsertEditAccessMutation, InsertEditAccessMutationVariables>(InsertEditAccessDocument, variables, options);
export const GetEventsPathsDocument = `
    query GetEventsPaths($limit: Int, $offset: Int) {
  events(
    where: {status: {_eq: "published"}}
    order_by: {slug: asc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    updated_at
  }
}
    `;
export const useGetEventsPathsQuery = <
      TData = GetEventsPathsQuery,
      TError = Error
    >(
      variables?: GetEventsPathsQueryVariables,
      options?: UseQueryOptions<GetEventsPathsQuery, TError, TData>
    ) =>
    useQuery<GetEventsPathsQuery, TError, TData>(
      variables === undefined ? ['GetEventsPaths'] : ['GetEventsPaths', variables],
      fetcher<GetEventsPathsQuery, GetEventsPathsQueryVariables>(GetEventsPathsDocument, variables),
      options
    );
useGetEventsPathsQuery.document = GetEventsPathsDocument;


useGetEventsPathsQuery.getKey = (variables?: GetEventsPathsQueryVariables) => variables === undefined ? ['GetEventsPaths'] : ['GetEventsPaths', variables];
;

useGetEventsPathsQuery.fetcher = (variables?: GetEventsPathsQueryVariables, options?: RequestInit['headers']) => fetcher<GetEventsPathsQuery, GetEventsPathsQueryVariables>(GetEventsPathsDocument, variables, options);
export const GetCompaniesPathsDocument = `
    query GetCompaniesPaths($limit: Int, $offset: Int) {
  companies(
    where: {status: {_eq: "published"}}
    order_by: {slug: asc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    updated_at
  }
}
    `;
export const useGetCompaniesPathsQuery = <
      TData = GetCompaniesPathsQuery,
      TError = Error
    >(
      variables?: GetCompaniesPathsQueryVariables,
      options?: UseQueryOptions<GetCompaniesPathsQuery, TError, TData>
    ) =>
    useQuery<GetCompaniesPathsQuery, TError, TData>(
      variables === undefined ? ['GetCompaniesPaths'] : ['GetCompaniesPaths', variables],
      fetcher<GetCompaniesPathsQuery, GetCompaniesPathsQueryVariables>(GetCompaniesPathsDocument, variables),
      options
    );
useGetCompaniesPathsQuery.document = GetCompaniesPathsDocument;


useGetCompaniesPathsQuery.getKey = (variables?: GetCompaniesPathsQueryVariables) => variables === undefined ? ['GetCompaniesPaths'] : ['GetCompaniesPaths', variables];
;

useGetCompaniesPathsQuery.fetcher = (variables?: GetCompaniesPathsQueryVariables, options?: RequestInit['headers']) => fetcher<GetCompaniesPathsQuery, GetCompaniesPathsQueryVariables>(GetCompaniesPathsDocument, variables, options);
export const GetPersonsPathDocument = `
    query GetPersonsPath($limit: Int, $offset: Int) {
  people(
    where: {status: {_eq: "published"}}
    order_by: {slug: asc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    updated_at
  }
}
    `;
export const useGetPersonsPathQuery = <
      TData = GetPersonsPathQuery,
      TError = Error
    >(
      variables?: GetPersonsPathQueryVariables,
      options?: UseQueryOptions<GetPersonsPathQuery, TError, TData>
    ) =>
    useQuery<GetPersonsPathQuery, TError, TData>(
      variables === undefined ? ['GetPersonsPath'] : ['GetPersonsPath', variables],
      fetcher<GetPersonsPathQuery, GetPersonsPathQueryVariables>(GetPersonsPathDocument, variables),
      options
    );
useGetPersonsPathQuery.document = GetPersonsPathDocument;


useGetPersonsPathQuery.getKey = (variables?: GetPersonsPathQueryVariables) => variables === undefined ? ['GetPersonsPath'] : ['GetPersonsPath', variables];
;

useGetPersonsPathQuery.fetcher = (variables?: GetPersonsPathQueryVariables, options?: RequestInit['headers']) => fetcher<GetPersonsPathQuery, GetPersonsPathQueryVariables>(GetPersonsPathDocument, variables, options);
export const GetVcFirmsPathDocument = `
    query GetVCFirmsPath($limit: Int, $offset: Int) {
  vc_firms(
    where: {status: {_eq: "published"}}
    order_by: {slug: asc}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    updated_at
  }
}
    `;
export const useGetVcFirmsPathQuery = <
      TData = GetVcFirmsPathQuery,
      TError = Error
    >(
      variables?: GetVcFirmsPathQueryVariables,
      options?: UseQueryOptions<GetVcFirmsPathQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsPathQuery, TError, TData>(
      variables === undefined ? ['GetVCFirmsPath'] : ['GetVCFirmsPath', variables],
      fetcher<GetVcFirmsPathQuery, GetVcFirmsPathQueryVariables>(GetVcFirmsPathDocument, variables),
      options
    );
useGetVcFirmsPathQuery.document = GetVcFirmsPathDocument;


useGetVcFirmsPathQuery.getKey = (variables?: GetVcFirmsPathQueryVariables) => variables === undefined ? ['GetVCFirmsPath'] : ['GetVCFirmsPath', variables];
;

useGetVcFirmsPathQuery.fetcher = (variables?: GetVcFirmsPathQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsPathQuery, GetVcFirmsPathQueryVariables>(GetVcFirmsPathDocument, variables, options);
export const GetSiteMapAggregatesDocument = `
    query GetSiteMapAggregates {
  companies_aggregate(where: {status: {_eq: "published"}}) {
    aggregate {
      count
    }
  }
  events_aggregate(where: {status: {_eq: "published"}}) {
    aggregate {
      count
    }
  }
  people_aggregate(where: {status: {_eq: "published"}}) {
    aggregate {
      count
    }
  }
  vc_firms_aggregate(where: {status: {_eq: "published"}}) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetSiteMapAggregatesQuery = <
      TData = GetSiteMapAggregatesQuery,
      TError = Error
    >(
      variables?: GetSiteMapAggregatesQueryVariables,
      options?: UseQueryOptions<GetSiteMapAggregatesQuery, TError, TData>
    ) =>
    useQuery<GetSiteMapAggregatesQuery, TError, TData>(
      variables === undefined ? ['GetSiteMapAggregates'] : ['GetSiteMapAggregates', variables],
      fetcher<GetSiteMapAggregatesQuery, GetSiteMapAggregatesQueryVariables>(GetSiteMapAggregatesDocument, variables),
      options
    );
useGetSiteMapAggregatesQuery.document = GetSiteMapAggregatesDocument;


useGetSiteMapAggregatesQuery.getKey = (variables?: GetSiteMapAggregatesQueryVariables) => variables === undefined ? ['GetSiteMapAggregates'] : ['GetSiteMapAggregates', variables];
;

useGetSiteMapAggregatesQuery.fetcher = (variables?: GetSiteMapAggregatesQueryVariables, options?: RequestInit['headers']) => fetcher<GetSiteMapAggregatesQuery, GetSiteMapAggregatesQueryVariables>(GetSiteMapAggregatesDocument, variables, options);
export const UpsertTeamMemberDocument = `
    mutation UpsertTeamMember($data: team_members_insert_input!) {
  insert_team_members_one(
    object: $data
    on_conflict: {constraint: team_members_company_id_person_id_key, update_columns: [function, title, founder, start_date, end_date]}
  ) {
    id
    function
    person_id
    company_id
    title
    start_date
    end_date
    seniority
  }
}
    `;
export const useUpsertTeamMemberMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertTeamMemberMutation, TError, UpsertTeamMemberMutationVariables, TContext>) =>
    useMutation<UpsertTeamMemberMutation, TError, UpsertTeamMemberMutationVariables, TContext>(
      ['UpsertTeamMember'],
      (variables?: UpsertTeamMemberMutationVariables) => fetcher<UpsertTeamMemberMutation, UpsertTeamMemberMutationVariables>(UpsertTeamMemberDocument, variables)(),
      options
    );
useUpsertTeamMemberMutation.fetcher = (variables: UpsertTeamMemberMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertTeamMemberMutation, UpsertTeamMemberMutationVariables>(UpsertTeamMemberDocument, variables, options);
export const InsertTeamMemberDocument = `
    mutation InsertTeamMember($personId: Int, $companyId: Int, $vcFirmId: Int) {
  insert_team_members_one(
    object: {person_id: $personId, company_id: $companyId}
    on_conflict: {constraint: team_members_company_id_person_id_key, update_columns: []}
  ) {
    id
  }
}
    `;
export const useInsertTeamMemberMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertTeamMemberMutation, TError, InsertTeamMemberMutationVariables, TContext>) =>
    useMutation<InsertTeamMemberMutation, TError, InsertTeamMemberMutationVariables, TContext>(
      ['InsertTeamMember'],
      (variables?: InsertTeamMemberMutationVariables) => fetcher<InsertTeamMemberMutation, InsertTeamMemberMutationVariables>(InsertTeamMemberDocument, variables)(),
      options
    );
useInsertTeamMemberMutation.fetcher = (variables?: InsertTeamMemberMutationVariables, options?: RequestInit['headers']) => fetcher<InsertTeamMemberMutation, InsertTeamMemberMutationVariables>(InsertTeamMemberDocument, variables, options);
export const GetTeamMemberByPersonIdDocument = `
    query GetTeamMemberByPersonId($person_id: Int!) {
  team_members(where: {person_id: {_eq: $person_id}}) {
    id
    company_id
  }
}
    `;
export const useGetTeamMemberByPersonIdQuery = <
      TData = GetTeamMemberByPersonIdQuery,
      TError = Error
    >(
      variables: GetTeamMemberByPersonIdQueryVariables,
      options?: UseQueryOptions<GetTeamMemberByPersonIdQuery, TError, TData>
    ) =>
    useQuery<GetTeamMemberByPersonIdQuery, TError, TData>(
      ['GetTeamMemberByPersonId', variables],
      fetcher<GetTeamMemberByPersonIdQuery, GetTeamMemberByPersonIdQueryVariables>(GetTeamMemberByPersonIdDocument, variables),
      options
    );
useGetTeamMemberByPersonIdQuery.document = GetTeamMemberByPersonIdDocument;


useGetTeamMemberByPersonIdQuery.getKey = (variables: GetTeamMemberByPersonIdQueryVariables) => ['GetTeamMemberByPersonId', variables];
;

useGetTeamMemberByPersonIdQuery.fetcher = (variables: GetTeamMemberByPersonIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetTeamMemberByPersonIdQuery, GetTeamMemberByPersonIdQueryVariables>(GetTeamMemberByPersonIdDocument, variables, options);
export const GetTeamMemberByCompanyIdsDocument = `
    query GetTeamMemberByCompanyIds($company_ids: [Int!]) {
  team_members(where: {company_id: {_in: $company_ids}}) {
    id
    company_id
    company {
      id
      name
      slug
      logo
    }
    person_id
    person {
      id
      name
      slug
      picture
      personal_email
      work_email
    }
  }
}
    `;
export const useGetTeamMemberByCompanyIdsQuery = <
      TData = GetTeamMemberByCompanyIdsQuery,
      TError = Error
    >(
      variables?: GetTeamMemberByCompanyIdsQueryVariables,
      options?: UseQueryOptions<GetTeamMemberByCompanyIdsQuery, TError, TData>
    ) =>
    useQuery<GetTeamMemberByCompanyIdsQuery, TError, TData>(
      variables === undefined ? ['GetTeamMemberByCompanyIds'] : ['GetTeamMemberByCompanyIds', variables],
      fetcher<GetTeamMemberByCompanyIdsQuery, GetTeamMemberByCompanyIdsQueryVariables>(GetTeamMemberByCompanyIdsDocument, variables),
      options
    );
useGetTeamMemberByCompanyIdsQuery.document = GetTeamMemberByCompanyIdsDocument;


useGetTeamMemberByCompanyIdsQuery.getKey = (variables?: GetTeamMemberByCompanyIdsQueryVariables) => variables === undefined ? ['GetTeamMemberByCompanyIds'] : ['GetTeamMemberByCompanyIds', variables];
;

useGetTeamMemberByCompanyIdsQuery.fetcher = (variables?: GetTeamMemberByCompanyIdsQueryVariables, options?: RequestInit['headers']) => fetcher<GetTeamMemberByCompanyIdsQuery, GetTeamMemberByCompanyIdsQueryVariables>(GetTeamMemberByCompanyIdsDocument, variables, options);
export const GetTeamMemberByIdDocument = `
    query GetTeamMemberById($id: Int!) {
  team_members(where: {id: {_eq: $id}}, limit: 1) {
    id
    company_id
    person {
      id
      name
      slug
      picture
      personal_email
      work_email
      status
    }
  }
}
    `;
export const useGetTeamMemberByIdQuery = <
      TData = GetTeamMemberByIdQuery,
      TError = Error
    >(
      variables: GetTeamMemberByIdQueryVariables,
      options?: UseQueryOptions<GetTeamMemberByIdQuery, TError, TData>
    ) =>
    useQuery<GetTeamMemberByIdQuery, TError, TData>(
      ['GetTeamMemberById', variables],
      fetcher<GetTeamMemberByIdQuery, GetTeamMemberByIdQueryVariables>(GetTeamMemberByIdDocument, variables),
      options
    );
useGetTeamMemberByIdQuery.document = GetTeamMemberByIdDocument;


useGetTeamMemberByIdQuery.getKey = (variables: GetTeamMemberByIdQueryVariables) => ['GetTeamMemberById', variables];
;

useGetTeamMemberByIdQuery.fetcher = (variables: GetTeamMemberByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetTeamMemberByIdQuery, GetTeamMemberByIdQueryVariables>(GetTeamMemberByIdDocument, variables, options);
export const GetTeamMembersDocument = `
    query GetTeamMembers($limit: Int, $offset: Int, $orderBy: [team_members_order_by!], $where: team_members_bool_exp!) {
  team_members(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    company_id
    person {
      id
      slug
      name
      picture
      linkedin
      personal_email
      work_email
    }
    function
    start_date
    end_date
    founder
    title
  }
  team_members_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetTeamMembersQuery = <
      TData = GetTeamMembersQuery,
      TError = Error
    >(
      variables: GetTeamMembersQueryVariables,
      options?: UseQueryOptions<GetTeamMembersQuery, TError, TData>
    ) =>
    useQuery<GetTeamMembersQuery, TError, TData>(
      ['GetTeamMembers', variables],
      fetcher<GetTeamMembersQuery, GetTeamMembersQueryVariables>(GetTeamMembersDocument, variables),
      options
    );
useGetTeamMembersQuery.document = GetTeamMembersDocument;


useGetTeamMembersQuery.getKey = (variables: GetTeamMembersQueryVariables) => ['GetTeamMembers', variables];
;

useGetTeamMembersQuery.fetcher = (variables: GetTeamMembersQueryVariables, options?: RequestInit['headers']) => fetcher<GetTeamMembersQuery, GetTeamMembersQueryVariables>(GetTeamMembersDocument, variables, options);
export const GetInvestorsDocument = `
    query GetInvestors($limit: Int, $offset: Int, $orderBy: [investors_order_by!], $where: investors_bool_exp!) {
  investors(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    vc_firm_id
    person {
      id
      slug
      name
      picture
      linkedin
      personal_email
      work_email
    }
    function
    start_date
    end_date
    founder
    title
  }
  investors_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetInvestorsQuery = <
      TData = GetInvestorsQuery,
      TError = Error
    >(
      variables: GetInvestorsQueryVariables,
      options?: UseQueryOptions<GetInvestorsQuery, TError, TData>
    ) =>
    useQuery<GetInvestorsQuery, TError, TData>(
      ['GetInvestors', variables],
      fetcher<GetInvestorsQuery, GetInvestorsQueryVariables>(GetInvestorsDocument, variables),
      options
    );
useGetInvestorsQuery.document = GetInvestorsDocument;


useGetInvestorsQuery.getKey = (variables: GetInvestorsQueryVariables) => ['GetInvestors', variables];
;

useGetInvestorsQuery.fetcher = (variables: GetInvestorsQueryVariables, options?: RequestInit['headers']) => fetcher<GetInvestorsQuery, GetInvestorsQueryVariables>(GetInvestorsDocument, variables, options);
export const InsertUserTransactionDocument = `
    mutation InsertUserTransaction($object: user_transactions_insert_input!) {
  insert_user_transactions_one(object: $object) {
    user_id
    amount
    note
  }
}
    `;
export const useInsertUserTransactionMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<InsertUserTransactionMutation, TError, InsertUserTransactionMutationVariables, TContext>) =>
    useMutation<InsertUserTransactionMutation, TError, InsertUserTransactionMutationVariables, TContext>(
      ['InsertUserTransaction'],
      (variables?: InsertUserTransactionMutationVariables) => fetcher<InsertUserTransactionMutation, InsertUserTransactionMutationVariables>(InsertUserTransactionDocument, variables)(),
      options
    );
useInsertUserTransactionMutation.fetcher = (variables: InsertUserTransactionMutationVariables, options?: RequestInit['headers']) => fetcher<InsertUserTransactionMutation, InsertUserTransactionMutationVariables>(InsertUserTransactionDocument, variables, options);
export const GetUserProfileDocument = `
    query GetUserProfile($id: Int!) {
  users_by_pk(id: $id) {
    id
    credits
    use_credits_system
    last_transaction_expiration
    billing_org_id
    billing_org {
      status
    }
    preferences
    organization_companies {
      id
      company {
        id
        slug
        name
        logo
        overview
        location_json
      }
    }
    organization_vc_firms {
      id
      vc_firm {
        id
        slug
        name
        logo
        overview
        location_json
      }
    }
    person {
      id
      name
      personal_email
      picture
      slug
      status
      type
      work_email
      linkedin
      github
      city
      country
      facebook_url
      twitter_url
      website_url
      about
      email
      team_members {
        id
        end_date
        start_date
        founder
        function
        title
        company {
          id
          slug
          name
          logo
          overview
          location_json
        }
      }
      investments {
        investment_round {
          id
          round_date
          round
          amount
          company {
            id
            slug
            name
            logo
          }
        }
      }
    }
  }
}
    `;
export const useGetUserProfileQuery = <
      TData = GetUserProfileQuery,
      TError = Error
    >(
      variables: GetUserProfileQueryVariables,
      options?: UseQueryOptions<GetUserProfileQuery, TError, TData>
    ) =>
    useQuery<GetUserProfileQuery, TError, TData>(
      ['GetUserProfile', variables],
      fetcher<GetUserProfileQuery, GetUserProfileQueryVariables>(GetUserProfileDocument, variables),
      options
    );
useGetUserProfileQuery.document = GetUserProfileDocument;


useGetUserProfileQuery.getKey = (variables: GetUserProfileQueryVariables) => ['GetUserProfile', variables];
;

useGetUserProfileQuery.fetcher = (variables: GetUserProfileQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserProfileQuery, GetUserProfileQueryVariables>(GetUserProfileDocument, variables, options);
export const GetUserByPersonIdDocument = `
    query GetUserByPersonId($person_id: Int!) {
  users(where: {person_id: {_eq: $person_id}}) {
    id
    credits
    use_credits_system
    last_transaction_expiration
    billing_org_id
    organization_companies {
      id
      company {
        id
        slug
        name
        logo
        overview
        location_json
      }
    }
    organization_vc_firms {
      id
      vc_firm {
        id
        slug
        name
        logo
        overview
        location_json
      }
    }
    person {
      id
      name
      personal_email
      picture
      slug
      status
      type
      work_email
      linkedin
      github
      city
      country
      facebook_url
      twitter_url
      website_url
      about
      email
      team_members {
        id
        end_date
        start_date
        founder
        function
        title
        company {
          id
          slug
          name
          logo
          overview
          location_json
        }
      }
      investments {
        investment_round {
          id
          round_date
          round
          amount
          company {
            id
            slug
            name
            logo
          }
        }
      }
    }
  }
}
    `;
export const useGetUserByPersonIdQuery = <
      TData = GetUserByPersonIdQuery,
      TError = Error
    >(
      variables: GetUserByPersonIdQueryVariables,
      options?: UseQueryOptions<GetUserByPersonIdQuery, TError, TData>
    ) =>
    useQuery<GetUserByPersonIdQuery, TError, TData>(
      ['GetUserByPersonId', variables],
      fetcher<GetUserByPersonIdQuery, GetUserByPersonIdQueryVariables>(GetUserByPersonIdDocument, variables),
      options
    );
useGetUserByPersonIdQuery.document = GetUserByPersonIdDocument;


useGetUserByPersonIdQuery.getKey = (variables: GetUserByPersonIdQueryVariables) => ['GetUserByPersonId', variables];
;

useGetUserByPersonIdQuery.fetcher = (variables: GetUserByPersonIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByPersonIdQuery, GetUserByPersonIdQueryVariables>(GetUserByPersonIdDocument, variables, options);
export const GetUserByPkDocument = `
    query GetUserByPk($userId: Int!) {
  users_by_pk(id: $userId) {
    id
    additional_emails
    email
  }
}
    `;
export const useGetUserByPkQuery = <
      TData = GetUserByPkQuery,
      TError = Error
    >(
      variables: GetUserByPkQueryVariables,
      options?: UseQueryOptions<GetUserByPkQuery, TError, TData>
    ) =>
    useQuery<GetUserByPkQuery, TError, TData>(
      ['GetUserByPk', variables],
      fetcher<GetUserByPkQuery, GetUserByPkQueryVariables>(GetUserByPkDocument, variables),
      options
    );
useGetUserByPkQuery.document = GetUserByPkDocument;


useGetUserByPkQuery.getKey = (variables: GetUserByPkQueryVariables) => ['GetUserByPk', variables];
;

useGetUserByPkQuery.fetcher = (variables: GetUserByPkQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByPkQuery, GetUserByPkQueryVariables>(GetUserByPkDocument, variables, options);
export const UpdateUserAdditionalEmailsByPkDocument = `
    mutation UpdateUserAdditionalEmailsByPk($userId: Int!, $emails: jsonb) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {additional_emails: $emails}
  ) {
    id
  }
}
    `;
export const useUpdateUserAdditionalEmailsByPkMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserAdditionalEmailsByPkMutation, TError, UpdateUserAdditionalEmailsByPkMutationVariables, TContext>) =>
    useMutation<UpdateUserAdditionalEmailsByPkMutation, TError, UpdateUserAdditionalEmailsByPkMutationVariables, TContext>(
      ['UpdateUserAdditionalEmailsByPk'],
      (variables?: UpdateUserAdditionalEmailsByPkMutationVariables) => fetcher<UpdateUserAdditionalEmailsByPkMutation, UpdateUserAdditionalEmailsByPkMutationVariables>(UpdateUserAdditionalEmailsByPkDocument, variables)(),
      options
    );
useUpdateUserAdditionalEmailsByPkMutation.fetcher = (variables: UpdateUserAdditionalEmailsByPkMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserAdditionalEmailsByPkMutation, UpdateUserAdditionalEmailsByPkMutationVariables>(UpdateUserAdditionalEmailsByPkDocument, variables, options);
export const GetUserByEmailDocument = `
    query GetUserByEmail($email: String) {
  users(where: {email: {_eq: $email}}, limit: 1) {
    id
    email
    role
    external_id
    is_auth0_verified
    display_name
    auth0_linkedin_id
    auth0_user_pass_id
    reference_id
    credits
    use_credits_system
    last_transaction_expiration
    billing_org_id
    person {
      name
      picture
      slug
      id
    }
    additional_emails
    active
    onboarding_information
    feature_flags
  }
}
    `;
export const useGetUserByEmailQuery = <
      TData = GetUserByEmailQuery,
      TError = Error
    >(
      variables?: GetUserByEmailQueryVariables,
      options?: UseQueryOptions<GetUserByEmailQuery, TError, TData>
    ) =>
    useQuery<GetUserByEmailQuery, TError, TData>(
      variables === undefined ? ['GetUserByEmail'] : ['GetUserByEmail', variables],
      fetcher<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument, variables),
      options
    );
useGetUserByEmailQuery.document = GetUserByEmailDocument;


useGetUserByEmailQuery.getKey = (variables?: GetUserByEmailQueryVariables) => variables === undefined ? ['GetUserByEmail'] : ['GetUserByEmail', variables];
;

useGetUserByEmailQuery.fetcher = (variables?: GetUserByEmailQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByEmailQuery, GetUserByEmailQueryVariables>(GetUserByEmailDocument, variables, options);
export const GetUserByIdDocument = `
    query GetUserById($id: Int) {
  users(where: {id: {_eq: $id}}, limit: 1) {
    id
    email
    role
    external_id
    is_auth0_verified
    display_name
    auth0_linkedin_id
    auth0_user_pass_id
    reference_id
    use_credits_system
    credits
    billing_org_id
    billing_org {
      customer_id
      status
    }
    person {
      name
      picture
    }
    additional_emails
    onboarding_information
    feature_flags
    preferences
  }
}
    `;
export const useGetUserByIdQuery = <
      TData = GetUserByIdQuery,
      TError = Error
    >(
      variables?: GetUserByIdQueryVariables,
      options?: UseQueryOptions<GetUserByIdQuery, TError, TData>
    ) =>
    useQuery<GetUserByIdQuery, TError, TData>(
      variables === undefined ? ['GetUserById'] : ['GetUserById', variables],
      fetcher<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument, variables),
      options
    );
useGetUserByIdQuery.document = GetUserByIdDocument;


useGetUserByIdQuery.getKey = (variables?: GetUserByIdQueryVariables) => variables === undefined ? ['GetUserById'] : ['GetUserById', variables];
;

useGetUserByIdQuery.fetcher = (variables?: GetUserByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByIdQuery, GetUserByIdQueryVariables>(GetUserByIdDocument, variables, options);
export const GetUserByIdForTokenDocument = `
    query GetUserByIdForToken($id: Int) {
  users(where: {id: {_eq: $id}}, limit: 1) {
    ...UserForToken
  }
}
    ${UserForTokenFragmentDoc}`;
export const useGetUserByIdForTokenQuery = <
      TData = GetUserByIdForTokenQuery,
      TError = Error
    >(
      variables?: GetUserByIdForTokenQueryVariables,
      options?: UseQueryOptions<GetUserByIdForTokenQuery, TError, TData>
    ) =>
    useQuery<GetUserByIdForTokenQuery, TError, TData>(
      variables === undefined ? ['GetUserByIdForToken'] : ['GetUserByIdForToken', variables],
      fetcher<GetUserByIdForTokenQuery, GetUserByIdForTokenQueryVariables>(GetUserByIdForTokenDocument, variables),
      options
    );
useGetUserByIdForTokenQuery.document = GetUserByIdForTokenDocument;


useGetUserByIdForTokenQuery.getKey = (variables?: GetUserByIdForTokenQueryVariables) => variables === undefined ? ['GetUserByIdForToken'] : ['GetUserByIdForToken', variables];
;

useGetUserByIdForTokenQuery.fetcher = (variables?: GetUserByIdForTokenQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByIdForTokenQuery, GetUserByIdForTokenQueryVariables>(GetUserByIdForTokenDocument, variables, options);
export const GetUserByEmailForTokenDocument = `
    query GetUserByEmailForToken($email: String!) {
  users(where: {email: {_eq: $email}}, limit: 1) {
    ...UserForToken
  }
}
    ${UserForTokenFragmentDoc}`;
export const useGetUserByEmailForTokenQuery = <
      TData = GetUserByEmailForTokenQuery,
      TError = Error
    >(
      variables: GetUserByEmailForTokenQueryVariables,
      options?: UseQueryOptions<GetUserByEmailForTokenQuery, TError, TData>
    ) =>
    useQuery<GetUserByEmailForTokenQuery, TError, TData>(
      ['GetUserByEmailForToken', variables],
      fetcher<GetUserByEmailForTokenQuery, GetUserByEmailForTokenQueryVariables>(GetUserByEmailForTokenDocument, variables),
      options
    );
useGetUserByEmailForTokenQuery.document = GetUserByEmailForTokenDocument;


useGetUserByEmailForTokenQuery.getKey = (variables: GetUserByEmailForTokenQueryVariables) => ['GetUserByEmailForToken', variables];
;

useGetUserByEmailForTokenQuery.fetcher = (variables: GetUserByEmailForTokenQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByEmailForTokenQuery, GetUserByEmailForTokenQueryVariables>(GetUserByEmailForTokenDocument, variables, options);
export const UpdateUserBillingOrgDocument = `
    mutation UpdateUserBillingOrg($userId: Int!, $billingOrgId: Int!) {
  update_users_by_pk(
    pk_columns: {id: $userId}
    _set: {billing_org_id: $billingOrgId}
  ) {
    id
  }
}
    `;
export const useUpdateUserBillingOrgMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserBillingOrgMutation, TError, UpdateUserBillingOrgMutationVariables, TContext>) =>
    useMutation<UpdateUserBillingOrgMutation, TError, UpdateUserBillingOrgMutationVariables, TContext>(
      ['UpdateUserBillingOrg'],
      (variables?: UpdateUserBillingOrgMutationVariables) => fetcher<UpdateUserBillingOrgMutation, UpdateUserBillingOrgMutationVariables>(UpdateUserBillingOrgDocument, variables)(),
      options
    );
useUpdateUserBillingOrgMutation.fetcher = (variables: UpdateUserBillingOrgMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserBillingOrgMutation, UpdateUserBillingOrgMutationVariables>(UpdateUserBillingOrgDocument, variables, options);
export const UpdateUserUseCreditsSystemDocument = `
    mutation UpdateUserUseCreditsSystem($user_id: Int!, $use_credits_system: Boolean) {
  update_users_by_pk(
    pk_columns: {id: $user_id}
    _set: {use_credits_system: $use_credits_system}
  ) {
    id
  }
}
    `;
export const useUpdateUserUseCreditsSystemMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserUseCreditsSystemMutation, TError, UpdateUserUseCreditsSystemMutationVariables, TContext>) =>
    useMutation<UpdateUserUseCreditsSystemMutation, TError, UpdateUserUseCreditsSystemMutationVariables, TContext>(
      ['UpdateUserUseCreditsSystem'],
      (variables?: UpdateUserUseCreditsSystemMutationVariables) => fetcher<UpdateUserUseCreditsSystemMutation, UpdateUserUseCreditsSystemMutationVariables>(UpdateUserUseCreditsSystemDocument, variables)(),
      options
    );
useUpdateUserUseCreditsSystemMutation.fetcher = (variables: UpdateUserUseCreditsSystemMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserUseCreditsSystemMutation, UpdateUserUseCreditsSystemMutationVariables>(UpdateUserUseCreditsSystemDocument, variables, options);
export const UpdateUserExpirationOfLastValidTransactionDocument = `
    mutation UpdateUserExpirationOfLastValidTransaction($user_id: Int!, $last_transaction_expiration: timestamptz) {
  update_users(
    where: {id: {_eq: $user_id}, use_credits_system: {_eq: true}}
    _set: {last_transaction_expiration: $last_transaction_expiration}
  ) {
    affected_rows
  }
}
    `;
export const useUpdateUserExpirationOfLastValidTransactionMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserExpirationOfLastValidTransactionMutation, TError, UpdateUserExpirationOfLastValidTransactionMutationVariables, TContext>) =>
    useMutation<UpdateUserExpirationOfLastValidTransactionMutation, TError, UpdateUserExpirationOfLastValidTransactionMutationVariables, TContext>(
      ['UpdateUserExpirationOfLastValidTransaction'],
      (variables?: UpdateUserExpirationOfLastValidTransactionMutationVariables) => fetcher<UpdateUserExpirationOfLastValidTransactionMutation, UpdateUserExpirationOfLastValidTransactionMutationVariables>(UpdateUserExpirationOfLastValidTransactionDocument, variables)(),
      options
    );
useUpdateUserExpirationOfLastValidTransactionMutation.fetcher = (variables: UpdateUserExpirationOfLastValidTransactionMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserExpirationOfLastValidTransactionMutation, UpdateUserExpirationOfLastValidTransactionMutationVariables>(UpdateUserExpirationOfLastValidTransactionDocument, variables, options);
export const UpsertUsersDocument = `
    mutation UpsertUsers($external_id: String, $email: String, $role: String, $display_name: String, $auth0_linkedin_id: String, $auth0_user_pass_id: String, $reference_user_id: Int) {
  insert_users(
    objects: [{external_id: $external_id, email: $email, role: $role, display_name: $display_name, auth0_linkedin_id: $auth0_linkedin_id, auth0_user_pass_id: $auth0_user_pass_id, reference_user_id: $reference_user_id}]
    on_conflict: {constraint: users_email_key, update_columns: [external_id]}
  ) {
    returning {
      id
      email
      role
      external_id
      is_auth0_verified
      display_name
      auth0_linkedin_id
      auth0_user_pass_id
      reference_id
      credits
      use_credits_system
      last_transaction_expiration
      billing_org_id
      person {
        name
        picture
        slug
        id
      }
      additional_emails
      active
    }
  }
}
    `;
export const useUpsertUsersMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertUsersMutation, TError, UpsertUsersMutationVariables, TContext>) =>
    useMutation<UpsertUsersMutation, TError, UpsertUsersMutationVariables, TContext>(
      ['UpsertUsers'],
      (variables?: UpsertUsersMutationVariables) => fetcher<UpsertUsersMutation, UpsertUsersMutationVariables>(UpsertUsersDocument, variables)(),
      options
    );
useUpsertUsersMutation.fetcher = (variables?: UpsertUsersMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertUsersMutation, UpsertUsersMutationVariables>(UpsertUsersDocument, variables, options);
export const UpdateUserEmailVerifiedStatusDocument = `
    mutation UpdateUserEmailVerifiedStatus($email: String!, $is_auth0_verified: Boolean) {
  update_users(
    where: {email: {_eq: $email}}
    _set: {is_auth0_verified: $is_auth0_verified}
  ) {
    affected_rows
    returning {
      id
      email
      role
      external_id
      is_auth0_verified
      display_name
      auth0_linkedin_id
      auth0_user_pass_id
      reference_id
      credits
      use_credits_system
      last_transaction_expiration
      billing_org_id
      person {
        name
        picture
        slug
        id
      }
      additional_emails
      active
    }
  }
}
    `;
export const useUpdateUserEmailVerifiedStatusMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserEmailVerifiedStatusMutation, TError, UpdateUserEmailVerifiedStatusMutationVariables, TContext>) =>
    useMutation<UpdateUserEmailVerifiedStatusMutation, TError, UpdateUserEmailVerifiedStatusMutationVariables, TContext>(
      ['UpdateUserEmailVerifiedStatus'],
      (variables?: UpdateUserEmailVerifiedStatusMutationVariables) => fetcher<UpdateUserEmailVerifiedStatusMutation, UpdateUserEmailVerifiedStatusMutationVariables>(UpdateUserEmailVerifiedStatusDocument, variables)(),
      options
    );
useUpdateUserEmailVerifiedStatusMutation.fetcher = (variables: UpdateUserEmailVerifiedStatusMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserEmailVerifiedStatusMutation, UpdateUserEmailVerifiedStatusMutationVariables>(UpdateUserEmailVerifiedStatusDocument, variables, options);
export const UpdateUserAuth0LinkedInIdDocument = `
    mutation UpdateUserAuth0LinkedInId($email: String!, $auth0_linkedin_id: String) {
  update_users(
    where: {email: {_eq: $email}}
    _set: {auth0_linkedin_id: $auth0_linkedin_id}
  ) {
    affected_rows
    returning {
      id
      auth0_linkedin_id
      auth0_user_pass_id
      reference_id
      credits
      use_credits_system
      last_transaction_expiration
      billing_org_id
      onboarding_information
      person {
        name
        picture
        slug
        id
      }
      additional_emails
      active
    }
  }
}
    `;
export const useUpdateUserAuth0LinkedInIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserAuth0LinkedInIdMutation, TError, UpdateUserAuth0LinkedInIdMutationVariables, TContext>) =>
    useMutation<UpdateUserAuth0LinkedInIdMutation, TError, UpdateUserAuth0LinkedInIdMutationVariables, TContext>(
      ['UpdateUserAuth0LinkedInId'],
      (variables?: UpdateUserAuth0LinkedInIdMutationVariables) => fetcher<UpdateUserAuth0LinkedInIdMutation, UpdateUserAuth0LinkedInIdMutationVariables>(UpdateUserAuth0LinkedInIdDocument, variables)(),
      options
    );
useUpdateUserAuth0LinkedInIdMutation.fetcher = (variables: UpdateUserAuth0LinkedInIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserAuth0LinkedInIdMutation, UpdateUserAuth0LinkedInIdMutationVariables>(UpdateUserAuth0LinkedInIdDocument, variables, options);
export const UpdateUserAuth0UserPassIdDocument = `
    mutation UpdateUserAuth0UserPassId($email: String!, $auth0_user_pass_id: String) {
  update_users(
    where: {email: {_eq: $email}}
    _set: {auth0_user_pass_id: $auth0_user_pass_id}
  ) {
    affected_rows
    returning {
      id
      email
      role
      external_id
      is_auth0_verified
      display_name
      auth0_linkedin_id
      auth0_user_pass_id
      reference_id
      credits
      use_credits_system
      last_transaction_expiration
      billing_org_id
      person {
        name
        picture
        slug
        id
      }
      additional_emails
      active
    }
  }
}
    `;
export const useUpdateUserAuth0UserPassIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserAuth0UserPassIdMutation, TError, UpdateUserAuth0UserPassIdMutationVariables, TContext>) =>
    useMutation<UpdateUserAuth0UserPassIdMutation, TError, UpdateUserAuth0UserPassIdMutationVariables, TContext>(
      ['UpdateUserAuth0UserPassId'],
      (variables?: UpdateUserAuth0UserPassIdMutationVariables) => fetcher<UpdateUserAuth0UserPassIdMutation, UpdateUserAuth0UserPassIdMutationVariables>(UpdateUserAuth0UserPassIdDocument, variables)(),
      options
    );
useUpdateUserAuth0UserPassIdMutation.fetcher = (variables: UpdateUserAuth0UserPassIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserAuth0UserPassIdMutation, UpdateUserAuth0UserPassIdMutationVariables>(UpdateUserAuth0UserPassIdDocument, variables, options);
export const GetUserByReferenceIdDocument = `
    query GetUserByReferenceId($reference_id: String) {
  users(where: {reference_id: {_eq: $reference_id}}, limit: 1) {
    id
    email
    role
    external_id
    is_auth0_verified
    display_name
    auth0_linkedin_id
    auth0_user_pass_id
    reference_id
    credits
    use_credits_system
    last_transaction_expiration
    billing_org_id
    person {
      name
      picture
      slug
      id
    }
    additional_emails
    active
  }
}
    `;
export const useGetUserByReferenceIdQuery = <
      TData = GetUserByReferenceIdQuery,
      TError = Error
    >(
      variables?: GetUserByReferenceIdQueryVariables,
      options?: UseQueryOptions<GetUserByReferenceIdQuery, TError, TData>
    ) =>
    useQuery<GetUserByReferenceIdQuery, TError, TData>(
      variables === undefined ? ['GetUserByReferenceId'] : ['GetUserByReferenceId', variables],
      fetcher<GetUserByReferenceIdQuery, GetUserByReferenceIdQueryVariables>(GetUserByReferenceIdDocument, variables),
      options
    );
useGetUserByReferenceIdQuery.document = GetUserByReferenceIdDocument;


useGetUserByReferenceIdQuery.getKey = (variables?: GetUserByReferenceIdQueryVariables) => variables === undefined ? ['GetUserByReferenceId'] : ['GetUserByReferenceId', variables];
;

useGetUserByReferenceIdQuery.fetcher = (variables?: GetUserByReferenceIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByReferenceIdQuery, GetUserByReferenceIdQueryVariables>(GetUserByReferenceIdDocument, variables, options);
export const UpdateUserAdditionalEmailsDocument = `
    mutation UpdateUserAdditionalEmails($id: Int!, $additional_emails: jsonb) {
  update_users(
    where: {id: {_eq: $id}}
    _set: {additional_emails: $additional_emails}
  ) {
    affected_rows
    returning {
      id
      email
      role
      external_id
      is_auth0_verified
      display_name
      auth0_linkedin_id
      auth0_user_pass_id
      reference_id
      credits
      use_credits_system
      last_transaction_expiration
      billing_org_id
      person {
        name
        picture
        slug
        id
      }
      additional_emails
    }
  }
}
    `;
export const useUpdateUserAdditionalEmailsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserAdditionalEmailsMutation, TError, UpdateUserAdditionalEmailsMutationVariables, TContext>) =>
    useMutation<UpdateUserAdditionalEmailsMutation, TError, UpdateUserAdditionalEmailsMutationVariables, TContext>(
      ['UpdateUserAdditionalEmails'],
      (variables?: UpdateUserAdditionalEmailsMutationVariables) => fetcher<UpdateUserAdditionalEmailsMutation, UpdateUserAdditionalEmailsMutationVariables>(UpdateUserAdditionalEmailsDocument, variables)(),
      options
    );
useUpdateUserAdditionalEmailsMutation.fetcher = (variables: UpdateUserAdditionalEmailsMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserAdditionalEmailsMutation, UpdateUserAdditionalEmailsMutationVariables>(UpdateUserAdditionalEmailsDocument, variables, options);
export const GetUserByAdditionalEmailDocument = `
    query GetUserByAdditionalEmail($email: jsonb) {
  users(where: {additional_emails: {_contains: $email}}, limit: 1) {
    id
    email
    role
    external_id
    is_auth0_verified
    display_name
    auth0_linkedin_id
    auth0_user_pass_id
    reference_id
    credits
    use_credits_system
    last_transaction_expiration
    billing_org_id
    person {
      name
      picture
      slug
      id
    }
    additional_emails
    active
  }
}
    `;
export const useGetUserByAdditionalEmailQuery = <
      TData = GetUserByAdditionalEmailQuery,
      TError = Error
    >(
      variables?: GetUserByAdditionalEmailQueryVariables,
      options?: UseQueryOptions<GetUserByAdditionalEmailQuery, TError, TData>
    ) =>
    useQuery<GetUserByAdditionalEmailQuery, TError, TData>(
      variables === undefined ? ['GetUserByAdditionalEmail'] : ['GetUserByAdditionalEmail', variables],
      fetcher<GetUserByAdditionalEmailQuery, GetUserByAdditionalEmailQueryVariables>(GetUserByAdditionalEmailDocument, variables),
      options
    );
useGetUserByAdditionalEmailQuery.document = GetUserByAdditionalEmailDocument;


useGetUserByAdditionalEmailQuery.getKey = (variables?: GetUserByAdditionalEmailQueryVariables) => variables === undefined ? ['GetUserByAdditionalEmail'] : ['GetUserByAdditionalEmail', variables];
;

useGetUserByAdditionalEmailQuery.fetcher = (variables?: GetUserByAdditionalEmailQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByAdditionalEmailQuery, GetUserByAdditionalEmailQueryVariables>(GetUserByAdditionalEmailDocument, variables, options);
export const UpdateUserOnboardingInformationDocument = `
    mutation UpdateUserOnboardingInformation($id: Int!, $onboarding_information: jsonb) {
  update_users(
    where: {id: {_eq: $id}}
    _set: {onboarding_information: $onboarding_information}
  ) {
    affected_rows
    returning {
      id
      email
      display_name
      person {
        name
        picture
        slug
        id
      }
      onboarding_information
    }
  }
}
    `;
export const useUpdateUserOnboardingInformationMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserOnboardingInformationMutation, TError, UpdateUserOnboardingInformationMutationVariables, TContext>) =>
    useMutation<UpdateUserOnboardingInformationMutation, TError, UpdateUserOnboardingInformationMutationVariables, TContext>(
      ['UpdateUserOnboardingInformation'],
      (variables?: UpdateUserOnboardingInformationMutationVariables) => fetcher<UpdateUserOnboardingInformationMutation, UpdateUserOnboardingInformationMutationVariables>(UpdateUserOnboardingInformationDocument, variables)(),
      options
    );
useUpdateUserOnboardingInformationMutation.fetcher = (variables: UpdateUserOnboardingInformationMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserOnboardingInformationMutation, UpdateUserOnboardingInformationMutationVariables>(UpdateUserOnboardingInformationDocument, variables, options);
export const UpdateUserPersonIdDocument = `
    mutation UpdateUserPersonId($id: Int!, $person_id: Int!) {
  update_users(where: {id: {_eq: $id}}, _set: {person_id: $person_id}) {
    affected_rows
    returning {
      id
      email
      display_name
      person {
        name
        picture
        slug
        id
      }
    }
  }
}
    `;
export const useUpdateUserPersonIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserPersonIdMutation, TError, UpdateUserPersonIdMutationVariables, TContext>) =>
    useMutation<UpdateUserPersonIdMutation, TError, UpdateUserPersonIdMutationVariables, TContext>(
      ['UpdateUserPersonId'],
      (variables?: UpdateUserPersonIdMutationVariables) => fetcher<UpdateUserPersonIdMutation, UpdateUserPersonIdMutationVariables>(UpdateUserPersonIdDocument, variables)(),
      options
    );
useUpdateUserPersonIdMutation.fetcher = (variables: UpdateUserPersonIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserPersonIdMutation, UpdateUserPersonIdMutationVariables>(UpdateUserPersonIdDocument, variables, options);
export const GetUserByPersonIdsDocument = `
    query GetUserByPersonIds($person_ids: [Int!]) {
  users(where: {person_id: {_in: $person_ids}}) {
    id
    email
    display_name
    person_id
  }
}
    `;
export const useGetUserByPersonIdsQuery = <
      TData = GetUserByPersonIdsQuery,
      TError = Error
    >(
      variables?: GetUserByPersonIdsQueryVariables,
      options?: UseQueryOptions<GetUserByPersonIdsQuery, TError, TData>
    ) =>
    useQuery<GetUserByPersonIdsQuery, TError, TData>(
      variables === undefined ? ['GetUserByPersonIds'] : ['GetUserByPersonIds', variables],
      fetcher<GetUserByPersonIdsQuery, GetUserByPersonIdsQueryVariables>(GetUserByPersonIdsDocument, variables),
      options
    );
useGetUserByPersonIdsQuery.document = GetUserByPersonIdsDocument;


useGetUserByPersonIdsQuery.getKey = (variables?: GetUserByPersonIdsQueryVariables) => variables === undefined ? ['GetUserByPersonIds'] : ['GetUserByPersonIds', variables];
;

useGetUserByPersonIdsQuery.fetcher = (variables?: GetUserByPersonIdsQueryVariables, options?: RequestInit['headers']) => fetcher<GetUserByPersonIdsQuery, GetUserByPersonIdsQueryVariables>(GetUserByPersonIdsDocument, variables, options);
export const UpdateUserFeatureFlagsDocument = `
    mutation UpdateUserFeatureFlags($id: Int!, $feature_flags: jsonb) {
  update_users(where: {id: {_eq: $id}}, _set: {feature_flags: $feature_flags}) {
    affected_rows
    returning {
      id
      email
      display_name
      person {
        name
        picture
        slug
        id
      }
      feature_flags
    }
  }
}
    `;
export const useUpdateUserFeatureFlagsMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserFeatureFlagsMutation, TError, UpdateUserFeatureFlagsMutationVariables, TContext>) =>
    useMutation<UpdateUserFeatureFlagsMutation, TError, UpdateUserFeatureFlagsMutationVariables, TContext>(
      ['UpdateUserFeatureFlags'],
      (variables?: UpdateUserFeatureFlagsMutationVariables) => fetcher<UpdateUserFeatureFlagsMutation, UpdateUserFeatureFlagsMutationVariables>(UpdateUserFeatureFlagsDocument, variables)(),
      options
    );
useUpdateUserFeatureFlagsMutation.fetcher = (variables: UpdateUserFeatureFlagsMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserFeatureFlagsMutation, UpdateUserFeatureFlagsMutationVariables>(UpdateUserFeatureFlagsDocument, variables, options);
export const UpdateUserPreferencesDocument = `
    mutation UpdateUserPreferences($id: Int!, $preferences: jsonb!) {
  update_users(where: {id: {_eq: $id}}, _set: {preferences: $preferences}) {
    affected_rows
    returning {
      id
      email
      display_name
      person {
        name
        picture
        slug
        id
      }
      preferences
    }
  }
}
    `;
export const useUpdateUserPreferencesMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateUserPreferencesMutation, TError, UpdateUserPreferencesMutationVariables, TContext>) =>
    useMutation<UpdateUserPreferencesMutation, TError, UpdateUserPreferencesMutationVariables, TContext>(
      ['UpdateUserPreferences'],
      (variables?: UpdateUserPreferencesMutationVariables) => fetcher<UpdateUserPreferencesMutation, UpdateUserPreferencesMutationVariables>(UpdateUserPreferencesDocument, variables)(),
      options
    );
useUpdateUserPreferencesMutation.fetcher = (variables: UpdateUserPreferencesMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateUserPreferencesMutation, UpdateUserPreferencesMutationVariables>(UpdateUserPreferencesDocument, variables, options);
export const GetVcFirmDocument = `
    query GetVCFirm($slug: String!) {
  vc_firms(where: {slug: {_eq: $slug}}) {
    id
    name
    slug
    logo
    website
    linkedin
    sentiment
    tags
    overview
    year_founded
    location_json
    twitter
    discord
    github
    telegram
    library
    investors {
      id
      person {
        id
        slug
        name
        picture
        linkedin
        personal_email
        work_email
      }
      function
      start_date
      end_date
      seniority
      founder
      title
    }
    investments {
      investment_round {
        id
        round_date
        round
        amount
        company {
          id
          slug
          name
          tags
          logo
        }
        investments {
          id
          vc_firm {
            id
            slug
            name
            logo
          }
          person {
            id
            slug
            name
            picture
          }
        }
      }
    }
    to_links {
      link_type
      from_company {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        follows {
          id
          list_id
        }
      }
      from_vc_firm {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        follows {
          id
          list_id
        }
      }
    }
    from_links {
      link_type
      to_company {
        id
        name
        slug
        tags
        sentiment
        overview
        logo
        total_employees
        investor_amount
        year_founded
        investment_rounds_aggregate {
          aggregate {
            count
          }
        }
        investment_rounds(order_by: {round_date: desc}, limit: 1) {
          round
          round_date
        }
        follows {
          id
          list_id
        }
      }
      to_vc_firm {
        id
        name
        slug
        tags
        sentiment
        year_founded
        investment_amount_total
        num_of_investments
        overview
        logo
        follows {
          id
          list_id
        }
      }
    }
    news_links {
      id
      news {
        id
        date
        text
        link
        kind
        source
        status
        organizations {
          id
          type
          company_id
          vc_firm_id
        }
      }
    }
    follows {
      id
      list_id
    }
  }
}
    `;
export const useGetVcFirmQuery = <
      TData = GetVcFirmQuery,
      TError = Error
    >(
      variables: GetVcFirmQueryVariables,
      options?: UseQueryOptions<GetVcFirmQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmQuery, TError, TData>(
      ['GetVCFirm', variables],
      fetcher<GetVcFirmQuery, GetVcFirmQueryVariables>(GetVcFirmDocument, variables),
      options
    );
useGetVcFirmQuery.document = GetVcFirmDocument;


useGetVcFirmQuery.getKey = (variables: GetVcFirmQueryVariables) => ['GetVCFirm', variables];
;

useGetVcFirmQuery.fetcher = (variables: GetVcFirmQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmQuery, GetVcFirmQueryVariables>(GetVcFirmDocument, variables, options);
export const GetVcFirmsDocument = `
    query GetVCFirms($limit: Int, $offset: Int, $orderBy: [vc_firms_order_by!], $where: vc_firms_bool_exp!) {
  vc_firms(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    name
    slug
    logo
    location_json
    tags
    overview
    website
    num_of_investments
    year_founded
    sentiment
    follows {
      id
      list_id
    }
  }
  vc_firms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetVcFirmsQuery = <
      TData = GetVcFirmsQuery,
      TError = Error
    >(
      variables: GetVcFirmsQueryVariables,
      options?: UseQueryOptions<GetVcFirmsQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsQuery, TError, TData>(
      ['GetVCFirms', variables],
      fetcher<GetVcFirmsQuery, GetVcFirmsQueryVariables>(GetVcFirmsDocument, variables),
      options
    );
useGetVcFirmsQuery.document = GetVcFirmsDocument;


useGetVcFirmsQuery.getKey = (variables: GetVcFirmsQueryVariables) => ['GetVCFirms', variables];
;

useGetVcFirmsQuery.fetcher = (variables: GetVcFirmsQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsQuery, GetVcFirmsQueryVariables>(GetVcFirmsDocument, variables, options);
export const GetVcFirmsRecentInvestmentsDocument = `
    query GetVCFirmsRecentInvestments($limit: Int, $offset: Int, $where: vc_firms_bool_exp!) {
  vc_firms(
    where: $where
    order_by: {latest_investment: desc_nulls_last}
    limit: $limit
    offset: $offset
  ) {
    id
    name
    slug
    logo
    tags
    latest_investment
    num_of_investments
    sentiment
    overview
    investments(
      limit: 1
      order_by: {investment_round: {round_date: desc_nulls_last}}
    ) {
      investment_round {
        id
        round_date
        round
        amount
      }
    }
    follows {
      id
      list_id
    }
  }
}
    `;
export const useGetVcFirmsRecentInvestmentsQuery = <
      TData = GetVcFirmsRecentInvestmentsQuery,
      TError = Error
    >(
      variables: GetVcFirmsRecentInvestmentsQueryVariables,
      options?: UseQueryOptions<GetVcFirmsRecentInvestmentsQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsRecentInvestmentsQuery, TError, TData>(
      ['GetVCFirmsRecentInvestments', variables],
      fetcher<GetVcFirmsRecentInvestmentsQuery, GetVcFirmsRecentInvestmentsQueryVariables>(GetVcFirmsRecentInvestmentsDocument, variables),
      options
    );
useGetVcFirmsRecentInvestmentsQuery.document = GetVcFirmsRecentInvestmentsDocument;


useGetVcFirmsRecentInvestmentsQuery.getKey = (variables: GetVcFirmsRecentInvestmentsQueryVariables) => ['GetVCFirmsRecentInvestments', variables];
;

useGetVcFirmsRecentInvestmentsQuery.fetcher = (variables: GetVcFirmsRecentInvestmentsQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsRecentInvestmentsQuery, GetVcFirmsRecentInvestmentsQueryVariables>(GetVcFirmsRecentInvestmentsDocument, variables, options);
export const GetRelevantVcFirmsDocument = `
    query GetRelevantVCFirms($where: vc_firms_bool_exp!, $limit: Int) {
  vc_firms(where: $where, limit: $limit) {
    id
    logo
    name
    slug
    sentiment
  }
}
    `;
export const useGetRelevantVcFirmsQuery = <
      TData = GetRelevantVcFirmsQuery,
      TError = Error
    >(
      variables: GetRelevantVcFirmsQueryVariables,
      options?: UseQueryOptions<GetRelevantVcFirmsQuery, TError, TData>
    ) =>
    useQuery<GetRelevantVcFirmsQuery, TError, TData>(
      ['GetRelevantVCFirms', variables],
      fetcher<GetRelevantVcFirmsQuery, GetRelevantVcFirmsQueryVariables>(GetRelevantVcFirmsDocument, variables),
      options
    );
useGetRelevantVcFirmsQuery.document = GetRelevantVcFirmsDocument;


useGetRelevantVcFirmsQuery.getKey = (variables: GetRelevantVcFirmsQueryVariables) => ['GetRelevantVCFirms', variables];
;

useGetRelevantVcFirmsQuery.fetcher = (variables: GetRelevantVcFirmsQueryVariables, options?: RequestInit['headers']) => fetcher<GetRelevantVcFirmsQuery, GetRelevantVcFirmsQueryVariables>(GetRelevantVcFirmsDocument, variables, options);
export const GetAllVcFirmsDocument = `
    query GetAllVCFirms {
  vc_firms {
    id
    name
    logo
    slug
  }
}
    `;
export const useGetAllVcFirmsQuery = <
      TData = GetAllVcFirmsQuery,
      TError = Error
    >(
      variables?: GetAllVcFirmsQueryVariables,
      options?: UseQueryOptions<GetAllVcFirmsQuery, TError, TData>
    ) =>
    useQuery<GetAllVcFirmsQuery, TError, TData>(
      variables === undefined ? ['GetAllVCFirms'] : ['GetAllVCFirms', variables],
      fetcher<GetAllVcFirmsQuery, GetAllVcFirmsQueryVariables>(GetAllVcFirmsDocument, variables),
      options
    );
useGetAllVcFirmsQuery.document = GetAllVcFirmsDocument;


useGetAllVcFirmsQuery.getKey = (variables?: GetAllVcFirmsQueryVariables) => variables === undefined ? ['GetAllVCFirms'] : ['GetAllVCFirms', variables];
;

useGetAllVcFirmsQuery.fetcher = (variables?: GetAllVcFirmsQueryVariables, options?: RequestInit['headers']) => fetcher<GetAllVcFirmsQuery, GetAllVcFirmsQueryVariables>(GetAllVcFirmsDocument, variables, options);
export const GetSentimentByVcFirmIdDocument = `
    query GetSentimentByVcFirmId($vcFirmId: Int!) {
  vc_firms_by_pk(id: $vcFirmId) {
    sentiment
    slug
  }
}
    `;
export const useGetSentimentByVcFirmIdQuery = <
      TData = GetSentimentByVcFirmIdQuery,
      TError = Error
    >(
      variables: GetSentimentByVcFirmIdQueryVariables,
      options?: UseQueryOptions<GetSentimentByVcFirmIdQuery, TError, TData>
    ) =>
    useQuery<GetSentimentByVcFirmIdQuery, TError, TData>(
      ['GetSentimentByVcFirmId', variables],
      fetcher<GetSentimentByVcFirmIdQuery, GetSentimentByVcFirmIdQueryVariables>(GetSentimentByVcFirmIdDocument, variables),
      options
    );
useGetSentimentByVcFirmIdQuery.document = GetSentimentByVcFirmIdDocument;


useGetSentimentByVcFirmIdQuery.getKey = (variables: GetSentimentByVcFirmIdQueryVariables) => ['GetSentimentByVcFirmId', variables];
;

useGetSentimentByVcFirmIdQuery.fetcher = (variables: GetSentimentByVcFirmIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetSentimentByVcFirmIdQuery, GetSentimentByVcFirmIdQueryVariables>(GetSentimentByVcFirmIdDocument, variables, options);
export const UpdateSentimentByVcFirmIdDocument = `
    mutation UpdateSentimentByVcFirmId($vcFirmId: Int!, $sentiment: jsonb!) {
  update_vc_firms_by_pk(
    pk_columns: {id: $vcFirmId}
    _set: {sentiment: $sentiment}
  ) {
    sentiment
  }
}
    `;
export const useUpdateSentimentByVcFirmIdMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateSentimentByVcFirmIdMutation, TError, UpdateSentimentByVcFirmIdMutationVariables, TContext>) =>
    useMutation<UpdateSentimentByVcFirmIdMutation, TError, UpdateSentimentByVcFirmIdMutationVariables, TContext>(
      ['UpdateSentimentByVcFirmId'],
      (variables?: UpdateSentimentByVcFirmIdMutationVariables) => fetcher<UpdateSentimentByVcFirmIdMutation, UpdateSentimentByVcFirmIdMutationVariables>(UpdateSentimentByVcFirmIdDocument, variables)(),
      options
    );
useUpdateSentimentByVcFirmIdMutation.fetcher = (variables: UpdateSentimentByVcFirmIdMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateSentimentByVcFirmIdMutation, UpdateSentimentByVcFirmIdMutationVariables>(UpdateSentimentByVcFirmIdDocument, variables, options);
export const GetVcFirmsByDateDocument = `
    query GetVcFirmsByDate($date: timestamptz, $library: jsonb) {
  vc_firms(
    where: {_and: [{status: {_eq: "published"}}, {updated_at: {_gte: $date}}, {library: {_contains: $library}}]}
  ) {
    id
    name
    logo
    slug
  }
}
    `;
export const useGetVcFirmsByDateQuery = <
      TData = GetVcFirmsByDateQuery,
      TError = Error
    >(
      variables?: GetVcFirmsByDateQueryVariables,
      options?: UseQueryOptions<GetVcFirmsByDateQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsByDateQuery, TError, TData>(
      variables === undefined ? ['GetVcFirmsByDate'] : ['GetVcFirmsByDate', variables],
      fetcher<GetVcFirmsByDateQuery, GetVcFirmsByDateQueryVariables>(GetVcFirmsByDateDocument, variables),
      options
    );
useGetVcFirmsByDateQuery.document = GetVcFirmsByDateDocument;


useGetVcFirmsByDateQuery.getKey = (variables?: GetVcFirmsByDateQueryVariables) => variables === undefined ? ['GetVcFirmsByDate'] : ['GetVcFirmsByDate', variables];
;

useGetVcFirmsByDateQuery.fetcher = (variables?: GetVcFirmsByDateQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsByDateQuery, GetVcFirmsByDateQueryVariables>(GetVcFirmsByDateDocument, variables, options);
export const UpdateVcFirmTagsByPkDocument = `
    mutation UpdateVcFirmTagsByPk($id: Int!, $tags: jsonb) {
  update_vc_firms_by_pk(_set: {tags: $tags}, pk_columns: {id: $id}) {
    id
  }
}
    `;
export const useUpdateVcFirmTagsByPkMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateVcFirmTagsByPkMutation, TError, UpdateVcFirmTagsByPkMutationVariables, TContext>) =>
    useMutation<UpdateVcFirmTagsByPkMutation, TError, UpdateVcFirmTagsByPkMutationVariables, TContext>(
      ['UpdateVcFirmTagsByPk'],
      (variables?: UpdateVcFirmTagsByPkMutationVariables) => fetcher<UpdateVcFirmTagsByPkMutation, UpdateVcFirmTagsByPkMutationVariables>(UpdateVcFirmTagsByPkDocument, variables)(),
      options
    );
useUpdateVcFirmTagsByPkMutation.fetcher = (variables: UpdateVcFirmTagsByPkMutationVariables, options?: RequestInit['headers']) => fetcher<UpdateVcFirmTagsByPkMutation, UpdateVcFirmTagsByPkMutationVariables>(UpdateVcFirmTagsByPkDocument, variables, options);
export const GetVcFirmsInvestmentsDocument = `
    query GetVcFirmsInvestments {
  vc_firms {
    id
    investments {
      investment_round {
        company {
          id
          tags
        }
      }
    }
  }
}
    `;
export const useGetVcFirmsInvestmentsQuery = <
      TData = GetVcFirmsInvestmentsQuery,
      TError = Error
    >(
      variables?: GetVcFirmsInvestmentsQueryVariables,
      options?: UseQueryOptions<GetVcFirmsInvestmentsQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsInvestmentsQuery, TError, TData>(
      variables === undefined ? ['GetVcFirmsInvestments'] : ['GetVcFirmsInvestments', variables],
      fetcher<GetVcFirmsInvestmentsQuery, GetVcFirmsInvestmentsQueryVariables>(GetVcFirmsInvestmentsDocument, variables),
      options
    );
useGetVcFirmsInvestmentsQuery.document = GetVcFirmsInvestmentsDocument;


useGetVcFirmsInvestmentsQuery.getKey = (variables?: GetVcFirmsInvestmentsQueryVariables) => variables === undefined ? ['GetVcFirmsInvestments'] : ['GetVcFirmsInvestments', variables];
;

useGetVcFirmsInvestmentsQuery.fetcher = (variables?: GetVcFirmsInvestmentsQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsInvestmentsQuery, GetVcFirmsInvestmentsQueryVariables>(GetVcFirmsInvestmentsDocument, variables, options);
export const GetVcFirmByIdDocument = `
    query GetVcFirmById($id: Int!) {
  vc_firms(where: {id: {_eq: $id}}) {
    id
    name
    status
  }
}
    `;
export const useGetVcFirmByIdQuery = <
      TData = GetVcFirmByIdQuery,
      TError = Error
    >(
      variables: GetVcFirmByIdQueryVariables,
      options?: UseQueryOptions<GetVcFirmByIdQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmByIdQuery, TError, TData>(
      ['GetVcFirmById', variables],
      fetcher<GetVcFirmByIdQuery, GetVcFirmByIdQueryVariables>(GetVcFirmByIdDocument, variables),
      options
    );
useGetVcFirmByIdQuery.document = GetVcFirmByIdDocument;


useGetVcFirmByIdQuery.getKey = (variables: GetVcFirmByIdQueryVariables) => ['GetVcFirmById', variables];
;

useGetVcFirmByIdQuery.fetcher = (variables: GetVcFirmByIdQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmByIdQuery, GetVcFirmByIdQueryVariables>(GetVcFirmByIdDocument, variables, options);
export const GetVcFirmInsightByLocationDocument = `
    query GetVcFirmInsightByLocation($where: vc_firms_bool_exp!) {
  vc_firms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetVcFirmInsightByLocationQuery = <
      TData = GetVcFirmInsightByLocationQuery,
      TError = Error
    >(
      variables: GetVcFirmInsightByLocationQueryVariables,
      options?: UseQueryOptions<GetVcFirmInsightByLocationQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmInsightByLocationQuery, TError, TData>(
      ['GetVcFirmInsightByLocation', variables],
      fetcher<GetVcFirmInsightByLocationQuery, GetVcFirmInsightByLocationQueryVariables>(GetVcFirmInsightByLocationDocument, variables),
      options
    );
useGetVcFirmInsightByLocationQuery.document = GetVcFirmInsightByLocationDocument;


useGetVcFirmInsightByLocationQuery.getKey = (variables: GetVcFirmInsightByLocationQueryVariables) => ['GetVcFirmInsightByLocation', variables];
;

useGetVcFirmInsightByLocationQuery.fetcher = (variables: GetVcFirmInsightByLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmInsightByLocationQuery, GetVcFirmInsightByLocationQueryVariables>(GetVcFirmInsightByLocationDocument, variables, options);
export const GetPersonalizedVcFirmsDocument = `
    query GetPersonalizedVcFirms($limit: Int, $offset: Int, $orderBy: [vc_firms_order_by!], $where: vc_firms_bool_exp!) {
  vc_firms(where: $where, order_by: $orderBy, limit: $limit, offset: $offset) {
    id
    slug
    logo
    name
    num_of_investments
    year_founded
    investment_amount_total
    tags
    location_json
    overview
    website
    linkedin
    twitter
    follows {
      id
      list_id
    }
  }
  vc_firms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;
export const useGetPersonalizedVcFirmsQuery = <
      TData = GetPersonalizedVcFirmsQuery,
      TError = Error
    >(
      variables: GetPersonalizedVcFirmsQueryVariables,
      options?: UseQueryOptions<GetPersonalizedVcFirmsQuery, TError, TData>
    ) =>
    useQuery<GetPersonalizedVcFirmsQuery, TError, TData>(
      ['GetPersonalizedVcFirms', variables],
      fetcher<GetPersonalizedVcFirmsQuery, GetPersonalizedVcFirmsQueryVariables>(GetPersonalizedVcFirmsDocument, variables),
      options
    );
useGetPersonalizedVcFirmsQuery.document = GetPersonalizedVcFirmsDocument;


useGetPersonalizedVcFirmsQuery.getKey = (variables: GetPersonalizedVcFirmsQueryVariables) => ['GetPersonalizedVcFirms', variables];
;

useGetPersonalizedVcFirmsQuery.fetcher = (variables: GetPersonalizedVcFirmsQueryVariables, options?: RequestInit['headers']) => fetcher<GetPersonalizedVcFirmsQuery, GetPersonalizedVcFirmsQueryVariables>(GetPersonalizedVcFirmsDocument, variables, options);
export const GetVcFirmsByTagsAndLocationDocument = `
    query GetVcFirmsByTagsAndLocation($limit: Int, $where: vc_firms_bool_exp!) {
  vc_firms(where: $where, limit: $limit) {
    id
  }
}
    `;
export const useGetVcFirmsByTagsAndLocationQuery = <
      TData = GetVcFirmsByTagsAndLocationQuery,
      TError = Error
    >(
      variables: GetVcFirmsByTagsAndLocationQueryVariables,
      options?: UseQueryOptions<GetVcFirmsByTagsAndLocationQuery, TError, TData>
    ) =>
    useQuery<GetVcFirmsByTagsAndLocationQuery, TError, TData>(
      ['GetVcFirmsByTagsAndLocation', variables],
      fetcher<GetVcFirmsByTagsAndLocationQuery, GetVcFirmsByTagsAndLocationQueryVariables>(GetVcFirmsByTagsAndLocationDocument, variables),
      options
    );
useGetVcFirmsByTagsAndLocationQuery.document = GetVcFirmsByTagsAndLocationDocument;


useGetVcFirmsByTagsAndLocationQuery.getKey = (variables: GetVcFirmsByTagsAndLocationQueryVariables) => ['GetVcFirmsByTagsAndLocation', variables];
;

useGetVcFirmsByTagsAndLocationQuery.fetcher = (variables: GetVcFirmsByTagsAndLocationQueryVariables, options?: RequestInit['headers']) => fetcher<GetVcFirmsByTagsAndLocationQuery, GetVcFirmsByTagsAndLocationQueryVariables>(GetVcFirmsByTagsAndLocationDocument, variables, options);
export const UpsertWaitlistEmailDocument = `
    mutation UpsertWaitlistEmail($email: String) {
  insert_waitlist_emails(
    objects: [{email: $email}]
    on_conflict: {constraint: waitlist_emails_email_key, update_columns: [email]}
  ) {
    returning {
      id
      email
    }
  }
}
    `;
export const useUpsertWaitlistEmailMutation = <
      TError = Error,
      TContext = unknown
    >(options?: UseMutationOptions<UpsertWaitlistEmailMutation, TError, UpsertWaitlistEmailMutationVariables, TContext>) =>
    useMutation<UpsertWaitlistEmailMutation, TError, UpsertWaitlistEmailMutationVariables, TContext>(
      ['UpsertWaitlistEmail'],
      (variables?: UpsertWaitlistEmailMutationVariables) => fetcher<UpsertWaitlistEmailMutation, UpsertWaitlistEmailMutationVariables>(UpsertWaitlistEmailDocument, variables)(),
      options
    );
useUpsertWaitlistEmailMutation.fetcher = (variables?: UpsertWaitlistEmailMutationVariables, options?: RequestInit['headers']) => fetcher<UpsertWaitlistEmailMutation, UpsertWaitlistEmailMutationVariables>(UpsertWaitlistEmailDocument, variables, options);