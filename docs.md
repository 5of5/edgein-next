To create documentation for all the API routes in the `api` directory, we can summarize the functionality of each route based on the provided code snippets. Here's a structured documentation for each API route:

### API Documentation

#### 1. `/api/generate-first-list`

- **Method**: POST
- **Description**: Generates a list of companies, VC firms, and people based on the user's onboarding information, including industry and location tags.
- **Response**: Returns a list of companies, VC firms, and people.
- **Error Handling**: Returns 403 if the user is not authenticated, 405 if the method is not POST, and 500 for server errors.

```1:88:pages/api/generate-first-list.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import compact from 'lodash/compact';
import take from 'lodash/take';
import uniqBy from 'lodash/uniqBy';
import { z } from 'zod';
import {
  GetCompaniesByTagsAndLocationQuery,
  GetPeopleByTagsAndLocationQuery,
  GetVcFirmsByTagsAndLocationQuery,
} from '@/graphql/types';
import CookieService from '@/utils/cookie';
import {
  getAutoGeneratedCompanies,
  getAutoGeneratedPeople,
  getAutoGeneratedVcFirms,
  upsertFollow,
  upsertList,
} from '@/utils/lists';
import { addOnboardingSchema } from '@/utils/schema';
import {
  AUTO_GENERATED_LIST_MAXIMUM_COMPANIES,
  AUTO_GENERATED_LIST_MAXIMUM_INVESTORS,
  AUTO_GENERATED_LIST_MAXIMUM_PEOPLE,
} from '@/utils/constants';

export type OnboardingInformation = z.infer<typeof addOnboardingSchema>;

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') return res.status(405).end();

  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  try {
    const onboardingInformation =
      user?.onboarding_information as OnboardingInformation;

    const locationDetails = onboardingInformation?.locationDetails ?? [];

    const locationTags = compact(
      locationDetails.map(locationDetail => locationDetail.city),
    );

    const industryTags = onboardingInformation?.industryTags ?? [];

    const companies = await generatedCompanies(industryTags, locationTags);

    const vcFirms = await generatedVcFirms(industryTags, locationTags);

    const people = await generatedPeople(industryTags, locationTags);

    if (companies.length > 0 || vcFirms.length > 0 || people.length > 0) {
      const displayName = user.display_name || '';
      const firstName =
        displayName.indexOf(' ') !== -1
          ? displayName.split(' ')[0]
          : displayName;
      const listName = `${firstName}'s first list`;

      const list = await upsertList(listName, user, token);

      await Promise.all([
        companies.map(async company => {
          await upsertFollow(
            list?.id || 0,
            company.id,
            'companies',
            user,
            token,
          );
        }),
        vcFirms.map(async vcFirm => {
          await upsertFollow(list?.id || 0, vcFirm.id, 'vc_firms', user, token);
        }),
        people.map(async person => {
          await upsertFollow(list?.id || 0, person.id, 'people', user, token);
        }),
      ]);
    }

    return res.status(200).send({ companies, vcFirms, people });
  } catch (error) {
    return res
      .status(500)
      .send({ error: 'Something went wrong. Please try again later.' });
  }
};
```

#### 2. `/api/data-runs`

- **Method**: GET
- **Description**: Processes raw data to classify and update data runs.
- **Response**: Returns success status.
- **Error Handling**: Returns 405 if the method is not GET.

```1:196:pages/api/data-runs.ts
import { getClient } from '@/scripts/postgres-helpers';
import { NextApiResponse, NextApiRequest } from 'next';

const DATA_RAW = 'data_raw';
const DATA_RUNS = 'data_runs';
const now = Date.now();
const REDUCED_DATA_RAW = `reduced_data_raw_${now}`;
const TOTAL_WEIGHT_DATA = `total_weight_data_${now}`;
const DATA_SET = `data_set_${now}`;
const TOTAL_WEIGTH_TABLE = `total_weight_${now}`;
const WINNERS_TABLE = `winners_${now}`;
const CLASSIFIED_DATA = `classified_data_${now}`;

const CREATE_TEMP_REDUCED_DATA_RUN = `
CREATE TEMP TABLE ${REDUCED_DATA_RAW} AS (
  -- only count latest record of same partner-user
  SELECT partner, user_id, resource, resource_id, field, value, created_at, id, accuracy_weight FROM
  (SELECT *,
    ROW_NUMBER() OVER (
      PARTITION BY partner, user_id, resource, resource_id, field
      ORDER BY created_at DESC) AS row_number
  FROM ${DATA_RAW} WHERE is_active = true) AS t1
  WHERE t1.row_number = 1
)
`;

const CREATE_TEMP_TOTAL_WEIGHT_DATA = `
-- build total weight data from data raw
CREATE TEMP TABLE ${TOTAL_WEIGHT_DATA} AS (
  SELECT resource, resource_id, field, value, SUM(accuracy_weight) AS total_weight
  FROM ${REDUCED_DATA_RAW}
  GROUP BY resource, resource_id, field, value
)
`;
const CREATE_TEMP_DATA_SET = `
CREATE TEMP TABLE ${DATA_SET} AS (
  SELECT
    resource,
    resource_id,
    field,
    total_weight,
    ROW_NUMBER() OVER (
      PARTITION BY resource,
      resource_id,
      field
    ORDER BY
      total_weight DESC
    ) AS ROW_NUMBER
  FROM ${TOTAL_WEIGHT_DATA}
)
`;

const CREATE_TEMP_TOTAL_WEIGHT_TABLE = `
CREATE TEMP TABLE ${TOTAL_WEIGTH_TABLE} AS
(
  SELECT * FROM ${TOTAL_WEIGHT_DATA} LEFT JOIN (
    -- build max, second max and ambiguity score from total_weight_data
    -- then join it with total_weight_data
    SELECT
      t1.resource,
      t1.resource_id,
      t1.field,
      t1.total_weight AS max_weight,
      t2.total_weight AS second_max,
      (t1.total_weight - t2.total_weight)/t1.total_weight::decimal as ambiguity_score
    FROM
      (
        -- build largest weight table as t1
        SELECT
          resource,
          resource_id,
          field,
          total_weight
        FROM
          ${DATA_SET}
        WHERE
          ROW_NUMBER = 1
      ) AS t1
    LEFT JOIN (
        -- build second largest weight table as t2
        SELECT
          resource,
          resource_id,
          field,
          total_weight
        FROM
        ${DATA_SET}
        WHERE
          ROW_NUMBER = 2
      ) AS t2
    USING (resource, resource_id, field)
  ) AS T USING (resource, resource_id, field)
)
`;
const CREATE_TEMP_WINNERS_TABLE = `
CREATE TEMP TABLE ${WINNERS_TABLE} AS (
  SELECT partner, user_id, resource, resource_id, field, value, created_at, id, accuracy_weight, max_weight FROM(
    SELECT
    -- If there're many records (can be a winner), choose the earliest record as a winner
      *, ROW_NUMBER() OVER (PARTITION BY resource, resource_id, field ORDER BY created_at) AS row_number
    FROM ${REDUCED_DATA_RAW} AS t1
       INNER JOIN (
        -- Get winner candidates that has total_weight = max_weight
        SELECT resource, resource_id, field, value, max_weight FROM ${TOTAL_WEIGTH_TABLE}  WHERE total_weight = max_weight
       ) AS t2
       USING (resource, resource_id, field, value)) AS t3
    WHERE row_number = 1
)
`;

const CREATE_TEMP_CLASSIFIED_DATA = `
CREATE TEMP TABLE ${CLASSIFIED_DATA} AS (
  SELECT
    t1.id,
    t1.resource,
    t1.resource_id,
    t1.field,
    t1.value,
    CASE
      WHEN (t2.id is null) THEN 'incorrect'
      WHEN (t2.id = t1.id) THEN 'new'
      WHEN (t2.id != t1.id) THEN 'validated'
    END
    AS classification,
    CASE
      WHEN (t2.id is null) THEN -1
      WHEN (t2.id = t1.id) THEN 5
      WHEN (t2.id != t1.id) THEN 1
    END
    AS weight,
    CASE
      WHEN (t2.id is not null) THEN t2.max_weight
    END
    AS max_weight,
    '${new Date().toISOString()}'::timestamp AS run_at
  FROM ${REDUCED_DATA_RAW} AS t1 LEFT JOIN ${WINNERS_TABLE} AS t2
  USING (resource, resource_id, field, value)
  )
`;
...
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const client = await getClient();
  // Reduce data raw
  await client.query(CREATE_TEMP_REDUCED_DATA_RUN);
  //Calculate total weight for each resource_id-resource-field-value combination
  await client.query(CREATE_TEMP_TOTAL_WEIGHT_DATA);
  //Get top 2 total weight of each combination
  await client.query(CREATE_TEMP_DATA_SET);
  /*
  total_weight sample
  resource|resource_id|field  |value            |total_weight|max|second_max|ambiguity_score       |
  --------+-----------+-------+-----------------+------------+---+----------+----------------------+
  company |       1394|twitter|"twitter1"       |           2|  4|         2|0.50000000000000000000|
  company |       1394|website|"website1"       |           1|  2|         1|0.50000000000000000000|
  company |       1394|twitter|"twitter2"       |           1|  4|         2|0.50000000000000000000|
  company |       1394|website|"website2"       |           2|  2|         1|0.50000000000000000000|
  company |       1394|twitter|"twitter3"       |           4|  4|         2|0.50000000000000000000|
  company |       1394|website|"website3"       |           1|  2|         1|0.50000000000000000000|
  */
  //Build total weight table
  await client.query(CREATE_TEMP_TOTAL_WEIGHT_TABLE);
  //Build winner table')
  await client.query(CREATE_TEMP_WINNERS_TABLE);
  //Classify all reduced data_raw records
  await client.query(CREATE_TEMP_CLASSIFIED_DATA);
  //Insert result into data_runs table
  await client.query(INSERT_DATA_RUN);

  await client.end();

  res.send({ success: true });
};
```

#### 3. `/api/notes`

- **Methods**: POST, PUT, DELETE
- **Description**: Manages notes associated with resources. Allows creating, updating, and deleting notes.
- **Response**: Returns the created, updated, or deleted note.
- **Error Handling**: Returns 403 if the user is not authenticated or unauthorized, 405 if the method is not allowed.

```1:108:pages/api/notes.ts
import { mutate } from '@/graphql/hasuraAdmin';
import {
  DeleteNoteByIdDocument,
  DeleteNoteByIdMutation,
  InsertNoteDocument,
  InsertNoteMutation,
  UpdateNoteDocument,
  UpdateNoteMutation,
} from '@/graphql/types';
import GroupService from '@/utils/groups';
import type { NextApiRequest, NextApiResponse } from 'next';
import CookieService from '../../utils/cookie';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  const notes: string = req.body.notes;
  const groupId: string | number = req.body.groupId;
  const resource_type = req.body.resourceType;
  const resource_id = req.body.resourceId;
  const created_by = user.id;

  const id = req.body.id;

  if (id && req.method !== 'POST') {
    const note = await GroupService.onFindNoteById(id);

    if (note?.created_by !== created_by) {
      return res
        .status(403)
        .json({ message: `You are not allowed to add/edit notes` });
    }
  }

  switch (req.method) {
    case 'POST': {
      const isCustomAudience = typeof groupId === 'string';

      const user_group_id = isCustomAudience ? null : groupId;
      const audience = isCustomAudience ? groupId : null;

      const {
        data: { insert_notes_one },
      } = await mutate<InsertNoteMutation>({
        mutation: InsertNoteDocument,
        variables: {
          object: {
            notes,
            user_group_id: user_group_id,
            resource_type,
            resource_id,
            created_by,
            audience,
          },
        },
      });

      return res.send(insert_notes_one);
    }
    case 'PUT': {
      const {
        data: { update_notes },
      } = await mutate<UpdateNoteMutation>({
        mutation: UpdateNoteDocument,
        variables: {
          id,
          notes,
        },
      });
      return res.send(update_notes?.returning[0]);
    }

    case 'DELETE': {
      const note = await GroupService.onFindNoteById(id);
      const isNoteCreator = user.id === note?.created_by;
      if (!isNoteCreator) {
        return res
          .status(403)
          .json({ message: "You don't have permission to delete this note" });
      }

      const {
        data: { delete_notes },
      } = await mutate<DeleteNoteByIdMutation>({
        mutation: DeleteNoteByIdDocument,
        variables: {
          id,
        },
      });

      // Delete likes of note
      await GroupService.onDeleteLikesByNoteId(id);

      // Delete comments of note
      await GroupService.onDeleteCommentsByNoteId(id);

      return res.send(delete_notes?.returning[0]);
    }

    default:
      return res.status(405).json({ message: 'Method not allowed' });
  }
};

export default handler;
```

#### 4. `/api/user`

- **Description**: Placeholder for user-related operations (details not provided).

```39:39:pages/api/user.ts
export default handler;
```

#### 5. `/api/groups`

- **Methods**: POST, PUT, DELETE
- **Description**: Manages user groups, including creating, updating, and deleting groups.
- **Response**: Returns the created, updated, or deleted group.
- **Error Handling**: Returns 403 if the user is not authenticated or unauthorized, 405 if the method is not allowed.

```1:75:pages/api/groups.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import GroupService from '@/utils/groups';
import CookieService from '../../utils/cookie';
import { groupSchema, Group } from '@/utils/schema';
import { extractErrors, zodValidate } from '@/utils/validation';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  const id = req.body.id;
  const payload = req.body.payload;

  if (req.method !== 'DELETE') {
    const { errors: fieldErrors } = zodValidate(payload, groupSchema);
    if (fieldErrors) {
      const errors = extractErrors<Group>(fieldErrors);
      return res.status(400).send({ errors });
    }
  }

  switch (req.method) {
    case 'POST': {
      const data = await GroupService.onInsertGroup({
        ...payload,
        created_by_user_id: user.id,
      });
      if (data?.id) {
        await GroupService.onAddGroupMember(user.id, data?.id);
      }
      return res.send(data);
    }

    case 'PUT': {
      const isCreator = await GroupService.isUserCreatorOfGroup(id, user.id);
      if (!isCreator) {
        return res
          .status(403)
          .json({ message: "You don't have permission to edit this group" });
      }

      // Update a group
      const updatedGroup = await GroupService.onUpdateGroup(id, payload);
      return res.send(updatedGroup);
    }

    case 'DELETE': {
      const isCreator = await GroupService.isUserCreatorOfGroup(id, user.id);
      if (!isCreator) {
        return res
          .status(403)
          .json({ message: "You don't have permission to delete this group" });
      }
      // Delete invites of group
      await GroupService.onDeleteGroupInvites(id);

      // Delete members of group
      await GroupService.onDeleteGroupMembers(id);

      // Delete notes of group
      await GroupService.onDeleteNotesByGroupId(id);

      // Delete a group
      const deletedGroup = await GroupService.onDeleteGroup(id);

      return res.send(deletedGroup);
    }

    default:
      return res.status(405).json({ message: 'Method not allowed' });
  }
};

export default handler;
```

#### 6. `/api/update-list`

- **Description**: Placeholder for list update operations (details not provided).

```58:58:pages/api/update-list.ts
export default handler;
```

#### 7. `/api/stripe-load`

- **Method**: POST
- **Description**: Handles Stripe subscription and billing portal sessions for authenticated users.
- **Response**: Returns a redirect URL for the Stripe billing portal or checkout session.
- **Error Handling**: Returns 403 if the user is not authenticated, 405 if the method is not POST.

```1:73:pages/api/stripe-load.ts
import { ROUTES } from '@/routes';
import type { NextApiRequest, NextApiResponse } from 'next';
import CookieService from '../../utils/cookie';
import UserService from '../../utils/users';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2022-08-01',
});

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method === 'POST') {
    try {
      const token = CookieService.getAuthToken(req.cookies);
      const user = await CookieService.getUser(token);
      if (!user) return res.status(403).end();

      const dbuser = await UserService.findOneUserById(user.id);

      if (
        dbuser.billing_org?.customer_id &&
        dbuser.billing_org?.status !== 'canceled'
      ) {
        const subscriptions = await stripe.subscriptions.list({
          customer: dbuser.billing_org?.customer_id,
          limit: 1,
        });
        const latestSubscription = subscriptions.data[0];
        if (latestSubscription) {
          // check if user already has a subscription
          // Authenticate your user.
          const session = await stripe.billingPortal.sessions.create({
            customer: dbuser.billing_org?.customer_id,
            return_url: `${req.headers.origin}${ROUTES.ACCOUNT}`,
          });
          return res.send({ success: true, redirect: session.url });
        }
      }
      // Create Checkout Sessions from body params.
      const metadata = {
        userId: user.id,
      };
      const session = await stripe.checkout.sessions.create({
        line_items: [
          {
            // Provide the exact Price ID (for example, pr_1234) of the product you want to sell
            price: process.env.STRIPE_PRICING_KEY,
            quantity: 1,
          },
        ],
        metadata,
        mode: 'subscription',
        customer: dbuser.billing_org?.customer_id,
        subscription_data: {
          trial_period_days: 7,
        },
        allow_promotion_codes: true,
        consent_collection: {
          terms_of_service: 'required',
        },
        client_reference_id: user.id.toString(),
        success_url: `${req.headers.origin}/api/refresh-user/?redirect=${ROUTES.ACCOUNT}/?success=true`,
        cancel_url: `${req.headers.origin}${ROUTES.ACCOUNT}/?canceled=true`,
      });
      res.send({ success: true, redirect: session.url });
    } catch (err: any) {
      console.log(err);
      res.status(err.statusCode || 500).json(err.message);
    }
  } else {
    res.setHeader('Allow', 'POST');
    res.status(405).end('Method Not Allowed');
  }
```

#### 8. `/api/update-company`

- **Description**: Placeholder for company update operations (details not provided).

```49:49:pages/api/update-company.ts
export default handler;
```

#### 9. `/api/stripe-webhook`

- **Description**: Placeholder for Stripe webhook handling (details not provided).

```182:190:pages/api/stripe-webhook.ts
};

// export const config = {
//   api: {
//     bodyParser: false,
//   },
// }

export default handler;
```

#### 10. `/api/revalidate`

- **Method**: GET
- **Description**: Revalidates a page based on a secret token.
- **Response**: Returns revalidation status.
- **Error Handling**: Returns 401 for invalid tokens, 500 for revalidation errors.

```1:26:pages/api/revalidate.ts
import type { NextApiRequest, NextApiResponse } from 'next';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Check for secret to confirm this is a valid request
  if (req.query.secret !== process.env.REVALIDATION_SECRET_TOKEN) {
    return res
      .status(401)
      .json({ message: 'Invalid token', secret: req.query.secret });
  }

  try {
    const path =
      typeof req.query.page === 'string' ? req.query.page : req.query.page[0];
    await res.unstable_revalidate(
      `${path}?revalidation_auth=${process.env.REVALIDATION_AUTH_TOKEN}`,
    );
    return res.json({ revalidated: true });
  } catch (err) {
    // If there was an error, Next.js will continue
    // to show the last successfully generated page
    console.log(err);
    return res
      .status(500)
      .send(`Error revalidating ${JSON.stringify(err, null, 2)}`);
  }
};
```

#### 11. `/api/leads/create-leads`

- **Method**: POST
- **Description**: Creates leads for users with admin roles.
- **Response**: Returns the result of the lead creation.
- **Error Handling**: Returns 401 if unauthorized, 405 if the method is not POST, 400 for invalid request body, and 500 for server errors.

```1:35:pages/api/leads/create-leads.ts
import { NextApiResponse, NextApiRequest } from 'next';
import UserService, { USER_ROLES } from '@/utils/users';
import { CreateLeadsReqSchema } from './schema';
import { createLeads } from './mutation';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    res.status(405).json({ message: 'Method not allowed' });
  }

  const { role } = (await UserService.getUserByCookies(req.cookies)) ?? {};
  if (role !== USER_ROLES.ADMIN) {
    return res.status(401).json({
      message: 'You are unauthorized for this operation!',
    });
  }

  const parseResponse = CreateLeadsReqSchema.safeParse(req.body);
  if (!parseResponse.success) {
    return res.status(400).json({
      error: parseResponse.error.errors,
      message: 'Invalid request body',
    });
  }

  try {
    const result = await createLeads(parseResponse.data);
    res.send({ result });
  } catch (err) {
    const errMessage = err instanceof Error ? err.message : err;
    return res
      .status(500)
      .send({ message: 'Failed to create leads', error: errMessage });
  }
};
```

#### 12. `/api/multiple-resources-to-list`

- **Method**: POST
- **Description**: Adds multiple resources (companies, VC firms, people) to a user's list based on sentiment.
- **Response**: Returns reactions for companies, VC firms, and people.
- **Error Handling**: Returns 403 if the user is not authenticated, 405 if the method is not POST, and 500 for server errors.

```1:64:pages/api/multiple-resources-to-list.ts
import { NextApiResponse, NextApiRequest } from 'next';
import CookieService from '../../utils/cookie';
import map from 'lodash/map';
import {
  updateResourceSentimentCount,
  upsertFollow,
  upsertList,
} from '@/utils/lists';
import { UpsertListMutation } from '@/graphql/types';
import { User } from '@/models/user';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') return res.status(405).end();

  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  const sentimentType: string = req.body.sentiment;
  const companyIds: number[] = req.body.companyIds;
  const vcFirmIds: number[] = req.body.vcFirmIds;
  const peopleIds: number[] = req.body.peopleIds;

  // console.log('starting reaction for user', {token,user,companyId,sentimentType,pathname})
  // check if user has a list for sentiment
  const listname = `sentiment-${user.id}-${sentimentType}`;

  try {
    // upsertList
    const list = await upsertList(listname, user, token);

    const companyReactions = await upsertFollowToList(
      'companies',
      companyIds,
      list,
      user,
      token,
      sentimentType,
    );

    const vcFirmReactions = await upsertFollowToList(
      'vc_firms',
      vcFirmIds,
      list,
      user,
      token,
      sentimentType,
    );

    const peopleReactions = await upsertFollowToList(
      'people',
      peopleIds,
      list,
      user,
      token,
      sentimentType,
    );

    res.send({ companyReactions, vcFirmReactions, peopleReactions });
  } catch (error: any) {
    return res
      .status(500)
      .send({ error: 'Something went wrong. Please try again later.' });
  }
```

#### 13. `/api/sync-algolia`

- **Description**: Synchronizes data with Algolia (details not provided).

```18:113:pages/api/sync-algolia.ts
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { role } = (await UserService.getUserByCookies(req.cookies)) ?? {};
  if (role !== USER_ROLES.ADMIN) {
    return res.status(401).json({
      message: 'You are unauthorized for this operation!',
    });
  }
  // get the last sync datetime from db
  const lastSyncArray = await queryForLastSync();
  if (!lastSyncArray.length) return res.status(405).end();

  const syncWeb3CompaniesOutput = await syncCompanies({
    client,
    lastSyncArray,
    key: 'sync_web3_companies',
    library: 'Web3',
    index: 'companies',
  });
  const syncAICompaniesOutput = await syncCompanies({
    client,
    lastSyncArray,
    key: 'sync_ai_companies',
    library: 'AI',
    index: 'ai_companies',
  });
  const syncWeb3VcFirmsOutput = await syncVcFirms({
    client,
    lastSyncArray,
    key: 'sync_web3_vc_firms',
    library: 'Web3',
    index: 'vc_firms',
  });
  const syncAIVcFirmsOutput = await syncVcFirms({
    client,
    lastSyncArray,
    key: 'sync_ai_vc_firms',
    library: 'AI',
    index: 'ai_vc_firms',
  });
  const syncWeb3PeopleOutput = await syncPeople({
    client,
    lastSyncArray,
    key: 'sync_web3_people',
    library: 'Web3',
    index: 'people',
  });
  const syncAIPeopleOutput = await syncPeople({
    client,
    lastSyncArray,
    key: 'sync_ai_people',
    library: 'AI',
    index: 'ai_people',
  });
  const syncWeb3EventsOutput = await syncEvents({
    client,
    lastSyncArray,
    key: 'sync_web3_events',
    library: 'Web3',
    index: 'events',
  });
  const syncAIEventsOutput = await syncEvents({
    client,
    lastSyncArray,
    key: 'sync_ai_events',
    library: 'AI',
    index: 'ai_events',
  });
  const syncWeb3NewsOutput = await syncNews({
    client,
    lastSyncArray,
    key: 'sync_web3_news',
    library: 'Web3',
    index: 'news',
  });
  const syncAINewsOutput = await syncNews({
    client,
    lastSyncArray,
    key: 'sync_ai_news',
    library: 'AI',
    index: 'ai_news',
  });
  const output: Record<string, any> = {
    ...syncWeb3CompaniesOutput,
    ...syncAICompaniesOutput,
    ...syncWeb3VcFirmsOutput,
    ...syncAIVcFirmsOutput,
    ...syncWeb3PeopleOutput,
    ...syncAIPeopleOutput,
    ...syncWeb3EventsOutput,
    ...syncAIEventsOutput,
    ...syncWeb3NewsOutput,
    ...syncAINewsOutput,
  };

  res.send({ success: true, ...output });
};
```

#### 14. `/api/toggle-show-draft-data`

- **Method**: POST
- **Description**: Toggles the visibility of draft data for the authenticated user.
- **Response**: Returns success status.
- **Error Handling**: Returns 403 if the user is not authenticated, 405 if the method is not POST, and 404 for errors.

```1:33:pages/api/toggle-show-draft-data.ts
import UserService from '../../utils/users';
import CookieService from '../../utils/cookie';
import type { NextApiRequest, NextApiResponse } from 'next';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    res.status(405).json({ message: 'Method not allowed' });
  }

  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  const showDraftData: boolean = req.body.showDraftData;

  try {
    const userData = await UserService.findOneUserByIdForToken(user.id);

    const userToken = UserService.createToken(
      { ...userData, showDraftData },
      false,
    );

    const token = await CookieService.createUserToken(userToken);
    CookieService.setTokenCookie(res, token);

    return res.send({ success: true });
  } catch (ex: any) {
    return res.status(404).send({ message: ex.message });
  }
};

export default handler;
```

#### 15. `/api/ingest/people`

- **Method**: POST
- **Description**: Ingests people data into the system.
- **Response**: Returns the inserted people data.
- **Error Handling**: Returns 500 for insertion errors.

```12:86:pages/api/ingest/people.ts
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    res.status(405).json({ message: 'Method not allowed' });
  }

  const parseResponse = IngestPeopleReqSchema.safeParse(req.body);

  if (!parseResponse.success) {
    return res.status(400).json({
      error: parseResponse.error.errors,
      message: 'Invalid request body',
    });
  }

  const { apiKey, people, enrichmentPriority } = parseResponse.data;

  if (!apiKey) {
    const token = CookieService.getAuthToken(req.cookies);
    const user = await CookieService.getUser(token);

    if (!user) {
      return res.status(401).json({
        message: 'Missing token and apiKey',
      });
    }
  } else {
    const partner = await partnerLookUp(apiKey);

    if (!partner) {
      return res.status(401).json({
        message: 'Invalid api key',
      });
    }
  }

  const insertPeopleData = people.map(linkedInUrl => {
    try {
      const { pathname } = new URL(linkedInUrl);

      const slug = pathname.split('/').at(2);

      if (!slug) {
        throw Error('Error while parsing slug');
      }

      return {
        status: 'to_be_enriched',
        linkedin: linkedInUrl,
        slug: slugify(slug),
        enrichment_priority: enrichmentPriority,
      };
    } catch (error) {
      return res.status(400).json({
        error: error,
        message: `Invalid linkedIn url ${linkedInUrl}`,
      });
    }
  });
  try {
    const response = await mutate<InsertPeopleMutation>({
      mutation: InsertPeopleDocument,
      variables: {
        objects: insertPeopleData,
      },
    });

    return res.status(201).json(response.data);
  } catch (error) {
    return res.status(500).json({
      error,
      message: 'Error while inserting people',
    });
  }
};
```

#### 16. `/api/add-list`

- **Method**: POST
- **Description**: Adds a new list for the authenticated user.
- **Response**: Returns the created list.
- **Error Handling**: Returns 403 if the user is not authenticated, 405 if the method is not POST, and 400 for validation errors.

```1:30:pages/api/add-list.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { upsertList } from '@/utils/lists';
import { listSchema } from '@/utils/schema';
import { zodValidate } from '@/utils/validation';
import CookieService from '../../utils/cookie';

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') return res.status(405).end();

  const token = CookieService.getAuthToken(req.cookies);
  const user = await CookieService.getUser(token);
  if (!user) return res.status(403).end();

  const { listName } = req.body;

  // check if user has a list for sentiment
  // upsertList

  const { errors } = zodValidate({ ...req.body, name: listName }, listSchema);
  if (errors) {
    return res
      .status(400)
      .send({ error: errors['name']?.[0] || 'Invalid parameters' });
  } else {
    const list = await upsertList(req.body.listName, user, token);
    return res.send({ list });
  }
};

export default handler;
```

#### 17. `/api/batch-job`

- **Description**: Executes batch jobs for updating VC firms and follows (details not provided).

```107:213:pages/api/batch-job.ts
};

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    res.status(405).json({ message: 'Method not allowed' });
  }

  const parseResponse = BatchJobReqSchema.safeParse(req.body);
  if (!parseResponse.success) {
    return res.status(400).json({
      error: parseResponse.error.errors,
      message: 'Invalid request body',
    });
  }

  const { apiKey } = parseResponse.data;
  if (!apiKey) {
    const { role } = (await UserService.getUserByCookies(req.cookies)) ?? {};
    if (role !== USER_ROLES.ADMIN) {
      return res.status(401).json({
        message: 'You are unauthorized for this operation!',
      });
    }
  } else {
    const partner = await partnerLookUp(apiKey);
    if (!partner) {
      return res.status(401).json({
        message: 'Invalid api key',
      });
    }
  }

  const client = await getClient();
  await handleUserTransactions(client);

  await client.query(
    `UPDATE vc_firms vc SET latest_investment = (SELECT round_date
    FROM investments
    INNER JOIN investment_rounds
      ON investments.round_id = investment_rounds.id
    WHERE
      investments.vc_firm_id = vc.id
      ORDER BY round_date DESC
      LIMIT 1)`,
    [],
  );

  await client.query(
    `UPDATE vc_firms vc SET num_of_investments = (SELECT count(*)
    FROM investments
    WHERE investments.vc_firm_id = vc.id)`,
    [],
  );
  await client.query(
    `UPDATE vc_firms vc SET num_of_exits = (
    SELECT COUNT(company_id) FROM (
      SELECT DISTINCT t1.company_id, t2.vc_firm_id
      FROM investment_rounds AS t1 INNER JOIN investments AS t2
      ON t1.id = t2.round_id
      WHERE t1.company_id IS NOT NULL AND t2.vc_firm_id IS NOT NULL
        AND t1.round IN ('Acquisition', 'Token Round')
    ) AS t3
    WHERE vc_firm_id = vc.id
    GROUP BY vc_firm_id)`,
    [],
  );

  await client.query(
    `UPDATE vc_firms vc SET investment_amount_total = (SELECT SUM(investment_rounds.amount)
    FROM investments
    INNER JOIN investment_rounds
      ON investments.round_id = investment_rounds.id
    WHERE
      investments.vc_firm_id = vc.id)`,
    [],
  );

  await client.query(
    `UPDATE vc_firms vc SET team_size = (SELECT count(*)
    FROM investors
    WHERE
    investors.vc_firm_id = vc.id)`,
    [],
  );

  // Reset invested companies of porfolio lists
  await client.query(
    `DELETE FROM follows WHERE list_id IN
    (SELECT id FROM lists WHERE "type" = 'portfolio')
    AND resource_type = 'companies'`,
    [],
  );

  // Add invested companies of vc_firms into follows table
  await client.query(
    `INSERT INTO follows (resource_type, list_id, resource_id, created_by_user_id)
    (
    SELECT 'companies', t1.id, t4.company_id, t1.created_by_id FROM (
      SELECT id, created_by_id FROM lists WHERE "type" = 'portfolio') AS t1
      INNER JOIN follows_vc_firms AS t2 ON t1.id = t2.list_id
      INNER JOIN investments AS t3 ON t2.resource_id = t3.vc_firm_id
      INNER JOIN investment_rounds AS t4 ON t3.round_id = t4.id
    WHERE t3.vc_firm_id IS NOT NULL AND t4.company_id IS NOT NULL
  ) ON CONFLICT DO NOTHING`,
    [],
  );
```

#### 18. `/api/bulk-save-people`

- **Description**: Saves multiple people records in bulk (details not provided).

```25:112:pages/api/bulk-save-people.ts
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  ...
  res.send({ success: true });
};

export default handler;
```

#### 19. `/api/ingest/companies`

- **Method**: POST
- **Description**: Ingests company data into the system.
- **Response**: Returns success status.
- **Error Handling**: Returns 405 if the method is not POST, 400 for invalid request body, and 401 for missing or invalid API key.

```15:77:pages/api/ingest/companies.ts
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    res.status(405).json({ message: 'Method not allowed' });
  }

  const parseResponse = IngestCompaniesReqSchema.safeParse(req.body);

  if (!parseResponse.success) {
    return res.status(400).json({
      error: parseResponse.error.errors,
      message: 'Invalid request body',
    });
  }

  const { apiKey, companies, enrichmentPriority } = parseResponse.data;

  if (!apiKey) {
    const token = CookieService.getAuthToken(req.cookies);
    const user = await CookieService.getUser(token);

    if (!user) {
      return res.status(401).json({
        message: 'Missing token and apiKey',
      });
    }
  } else {
    const partner = await partnerLookUp(apiKey);

    if (!partner) {
      return res.status(401).json({
        message: 'Invalid api key',
      });
    }
  }

  const insertCompaniesData = companies.map(website => {
    try {
      const url =
        website.startsWith('http://') || website.startsWith('https://')
          ? website
          : `https://${website}`;

      const { hostname } = new URL(url);

      const slug = hostname.split('.').at(0);

      if (!slug) {
        throw Error('Error while parsing slug');
      }

      return {
        status: 'to_be_enriched',
        website,
        slug: slugify(slug),
        enrichment_priority: enrichmentPriority,
      };
    } catch (error) {
      return res.status(400).json({
        error: error,
        message: `Invalid website url ${website}`,
      });
    }
  });
```

#### 20. `/api/graphql`

- **Description**: Placeholder for GraphQL API operations (details not provided).

```55:55:pages/api/graphql.ts
export default handler;
```

This documentation provides an overview of each API route, including the HTTP methods, descriptions, responses, and error handling. For more detailed information, you may need to refer to the actual code implementation.
